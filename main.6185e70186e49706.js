(self.webpackChunkimage_classifier=self.webpackChunkimage_classifier||[]).push([[179],{951:(It,Ct,K)=>{"use strict";var He={};K.r(He),K.d(He,{arraysEqual:()=>Oi,assert:()=>D,assertNonNegativeIntegerDimensions:()=>v1,assertNonNull:()=>Au,assertShapesMatch:()=>Jr,bytesFromStringArray:()=>FL,bytesPerElement:()=>b1,checkConversionForErrors:()=>$L,clamp:()=>Qp,computeStrides:()=>Td,createScalarValue:()=>Eae,createShuffledIndices:()=>Bie,decodeString:()=>Rb,distSquared:()=>Mie,encodeString:()=>sf,fetch:()=>kae,fingerPrint64:()=>Cae,flatten:()=>Ru,getArrayFromDType:()=>RL,getTypedArrayFromDType:()=>AL,hasEncodingLoss:()=>Wie,hexToLong:()=>nf,indexToLoc:()=>jie,inferDtype:()=>Tb,inferFromImplicitShape:()=>Uie,isBoolean:()=>ML,isFunction:()=>ul,isInt:()=>Sd,isNumber:()=>PL,isPromise:()=>Ou,isScalarShape:()=>Pie,isString:()=>ll,isTypedArray:()=>zr,isValidDtype:()=>OL,locToIndex:()=>Hie,makeOnesTypedArray:()=>_1,makeZerosNestedTypedArray:()=>Gie,makeZerosTypedArray:()=>Eb,nearestDivisor:()=>Cb,nearestLargerEven:()=>$ie,now:()=>rf,parseAxisParam:()=>ef,randUniform:()=>Fie,repeatedTry:()=>zie,rightPad:()=>Jp,shuffle:()=>NL,shuffleCombo:()=>Rie,sizeFromShape:()=>gn,sizeToSquarishShape:()=>Vie,squeezeShape:()=>DL,sum:()=>Oie,swap:()=>Sb,tanh:()=>Lie,toNestedArray:()=>$u,toTypedArray:()=>Ab});var tr={};K.r(tr),K.d(tr,{assertTypesMatch:()=>MB,getTensorsInContainer:()=>P1,isTensorInList:()=>Uae,makeTypesMatch:()=>In});var Xe={};K.r(Xe),K.d(Xe,{isBrowser:()=>BB,isMobile:()=>Xae,mockIsMobile:()=>Kae});var en={};K.r(en),K.d(en,{browserFiles:()=>Ole,browserHTTPRequest:()=>Vle,concatenateArrayBuffers:()=>G1,copyModel:()=>wle,decodeWeights:()=>WB,encodeWeights:()=>Zae,fromMemory:()=>zle,fromMemorySync:()=>uz,getLoadHandlers:()=>lle,getModelArtifactsForJSON:()=>H1,getModelArtifactsForJSONSync:()=>qB,getModelArtifactsInfoForJSON:()=>hf,getSaveHandlers:()=>ale,getWeightSpecs:()=>KB,http:()=>aC,isHTTPScheme:()=>iC,listModels:()=>_le,loadWeights:()=>Fle,moveModel:()=>xle,registerLoadRouter:()=>ile,registerSaveRouter:()=>ole,removeModel:()=>vle,weightsLoaderFactory:()=>oz,withSaveHandler:()=>Ule,withSaveHandlerSync:()=>Wle});var ht={};K.r(ht),K.d(ht,{confusionMatrix:()=>fue});var We={};K.r(We),K.d(We,{assertAndGetBroadcastShape:()=>Qn,getBroadcastDims:()=>dz,getReductionAxes:()=>uC});var ut={};K.r(ut),K.d(ut,{fromPixels:()=>pz,fromPixelsAsync:()=>_ue,toPixels:()=>vue});var Ae={};K.r(Ae),K.d(Ae,{prepareAndValidate:()=>fz});var J={};K.r(J),K.d(J,{calculateShapes:()=>mz,validateInput:()=>fC,validateUpdateShape:()=>pC});var ye={};K.r(ye),K.d(ye,{assertParamsValid:()=>xue,computeFlatOffset:()=>Iue,computeOutShape:()=>Tue,getNormalizedAxes:()=>Cue,isSliceContinous:()=>Eue,maskToAxes:()=>Sue,parseSliceParams:()=>kue,sliceInfo:()=>Nue,startForAxis:()=>xz,startIndicesWithElidedDims:()=>_z,stopForAxis:()=>Sz,stopIndicesWithElidedDims:()=>vz,stridesForAxis:()=>wz,stridesWithElidedDims:()=>gz});var ve={};K.r(ve),K.d(ve,{Serializable:()=>Cz,SerializationMap:()=>fl,registerClass:()=>ml});var ae={};K.r(ae),K.d(ae,{TEST_EPSILON_FLOAT16:()=>Ez,createVideoElement:()=>Lue,encodeStrings:()=>Iz,expectArrayBuffersEqual:()=>Pue,expectArraysClose:()=>Rue,expectArraysEqual:()=>Oue,expectNumbersClose:()=>Fue,expectPromiseToFail:()=>$ue,expectValuesInRange:()=>Mue,play:()=>Vue,testEpsilon:()=>gC});var ge={};K.r(ge),K.d(ge,{conv2d:()=>kpe,depthwiseConv2d:()=>Ope,matMul:()=>Mpe});var $e={};K.r($e),K.d($e,{collectGatherOpShapeInfo:()=>uge,computeOutShape:()=>lge,segOpComputeOptimalWindowSize:()=>age});var Le={};K.r(Le),K.d(Le,{ERF_A1:()=>kme,ERF_A2:()=>Nme,ERF_A3:()=>Dme,ERF_A4:()=>Ame,ERF_A5:()=>Rme,ERF_P:()=>Ime,PARALLELIZE_THRESHOLD:()=>hE,RowPartitionType:()=>ci,SELU_SCALE:()=>Eme,SELU_SCALEALPHA:()=>Cme,applyActivation:()=>c_,assertAndGetBroadcastShape:()=>Qn,assertAxesAreInnerMostDims:()=>fde,assertParamsConsistent:()=>hme,assignToTypedArray:()=>Lme,axesAreInnerMostDims:()=>NC,calculateShapes:()=>mz,checkEinsumDimSizes:()=>Gme,checkPadOnDimRoundingMode:()=>No,combineLocations:()=>_4,combineRaggedTensorToTensorShapes:()=>fme,complexWithEvenIndex:()=>Fme,complexWithOddIndex:()=>Mme,computeConv2DInfo:()=>gf,computeConv3DInfo:()=>Uz,computeDefaultPad:()=>xC,computeDilation2DInfo:()=>fce,computeOptimalWindowSize:()=>bme,computeOutAndReduceShapes:()=>pde,computeOutShape:()=>pme,computePool2DInfo:()=>zz,computePool3DInfo:()=>mce,convertConv2DDataFormat:()=>Wz,decodeEinsumEquation:()=>Ume,eitherStridesOrDilationsAreOne:()=>Ca,expandShapeToKeepDim:()=>wf,exponent:()=>Bme,exponents:()=>Vme,fromStringArrayToUint8:()=>dge,fromUint8ToStringArray:()=>cge,getAxesPermutation:()=>mde,getBroadcastDims:()=>dz,getComplexWithIndex:()=>Pme,getEinsumComputePath:()=>Hme,getEinsumPermutation:()=>Wme,getFusedBiasGradient:()=>u_,getFusedDyActivation:()=>l_,getImageCenter:()=>_me,getInnerMostAxes:()=>yde,getPermuted:()=>wme,getRaggedRank:()=>gme,getReductionAxes:()=>uC,getReshaped:()=>vme,getReshapedPermuted:()=>xme,getRowPartitionTypesHelper:()=>mme,getSliceBeginCoords:()=>Sme,getSliceSize:()=>Tme,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Xme,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Yme,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Zme,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>ege,getSparseReshapeInputOutputMismatchErrorMessage:()=>nge,getSparseReshapeInputOutputMultipleErrorMessage:()=>tge,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Qme,getSparseReshapeNegativeOutputDimErrorMessage:()=>Jme,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>ige,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>rge,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>sge,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>oge,getUndoAxesPermutation:()=>gde,isIdentityPermutation:()=>jme,log:()=>gae,mergeRealAndImagArrays:()=>$me,prepareAndValidate:()=>fz,prepareSplitSize:()=>Kme,segment_util:()=>$e,shouldFuse:()=>d_,slice_util:()=>ye,splitRealAndImagArrays:()=>Ome,tupleValuesAreOne:()=>yf,upcastType:()=>Bb,validateDefaultValueShape:()=>yme,validateInput:()=>fC,validateUpdateShape:()=>pC,warn:()=>cl});var Gt={};K.r(Gt),K.d(Gt,{nonMaxSuppressionV3Impl:()=>PU,nonMaxSuppressionV4Impl:()=>LU,nonMaxSuppressionV5Impl:()=>VU,whereImpl:()=>IU});var nr={};K.r(nr),K.d(nr,{Abs:()=>UL,Acos:()=>WL,Acosh:()=>GL,AdadeltaOptimizer:()=>jb,AdagradOptimizer:()=>qb,AdamOptimizer:()=>Kb,AdamaxOptimizer:()=>Xb,Add:()=>T1,AddN:()=>HL,All:()=>jL,Any:()=>qL,ArgMax:()=>KL,ArgMin:()=>XL,Asin:()=>YL,Asinh:()=>ZL,Atan:()=>QL,Atan2:()=>e3,Atanh:()=>JL,AvgPool:()=>t3,AvgPool3D:()=>n3,AvgPool3DGrad:()=>Jie,AvgPoolGrad:()=>Qie,BatchMatMul:()=>r3,BatchToSpaceND:()=>s3,Bincount:()=>o3,BroadcastArgs:()=>a3,BroadcastTo:()=>eae,Cast:()=>C1,Ceil:()=>l3,ClipByValue:()=>u3,Complex:()=>c3,ComplexAbs:()=>d3,Concat:()=>h3,Conv2D:()=>p3,Conv2DBackpropFilter:()=>f3,Conv2DBackpropInput:()=>m3,Conv3D:()=>g3,Conv3DBackpropFilterV2:()=>tae,Conv3DBackpropInputV2:()=>y3,Cos:()=>b3,Cosh:()=>_3,CropAndResize:()=>x3,Cumprod:()=>v3,Cumsum:()=>w3,DataStorage:()=>Aie,DenseBincount:()=>S3,DepthToSpace:()=>T3,DepthwiseConv2dNative:()=>C3,DepthwiseConv2dNativeBackpropFilter:()=>E3,DepthwiseConv2dNativeBackpropInput:()=>I3,Diag:()=>k3,Dilation2D:()=>N3,Dilation2DBackpropFilter:()=>rae,Dilation2DBackpropInput:()=>nae,ENV:()=>w1,Einsum:()=>A3,Elu:()=>R3,EluGrad:()=>sae,Environment:()=>BL,Equal:()=>O3,Erf:()=>$3,Exp:()=>F3,ExpandDims:()=>M3,Expm1:()=>P3,FFT:()=>L3,Fill:()=>V3,FlipLeftRight:()=>B3,Floor:()=>z3,FloorDiv:()=>U3,FromPixels:()=>k1,FusedBatchNorm:()=>W3,FusedConv2D:()=>D1,FusedDepthwiseConv2D:()=>A1,GatherNd:()=>H3,GatherV2:()=>G3,Greater:()=>j3,GreaterEqual:()=>q3,IFFT:()=>K3,Identity:()=>E1,Imag:()=>X3,IsFinite:()=>Y3,IsInf:()=>Z3,IsNan:()=>Q3,KernelBackend:()=>kL,LRN:()=>lV,LRNGrad:()=>lae,LeakyRelu:()=>J3,Less:()=>eV,LessEqual:()=>tV,LinSpace:()=>nV,Log:()=>rV,Log1p:()=>sV,LogSoftmax:()=>iae,LogicalAnd:()=>oV,LogicalNot:()=>iV,LogicalOr:()=>aV,LogicalXor:()=>oae,LowerBound:()=>aae,Max:()=>uV,MaxPool:()=>dV,MaxPool3D:()=>hV,MaxPool3DGrad:()=>cae,MaxPoolGrad:()=>uae,MaxPoolWithArgmax:()=>pV,Maximum:()=>cV,Mean:()=>fV,Min:()=>mV,Minimum:()=>gV,MirrorPad:()=>yV,Mod:()=>bV,MomentumOptimizer:()=>Yb,Multinomial:()=>_V,Multiply:()=>vV,Neg:()=>wV,NonMaxSuppressionV3:()=>SV,NonMaxSuppressionV4:()=>TV,NonMaxSuppressionV5:()=>CV,NotEqual:()=>xV,OP_SCOPE_SUFFIX:()=>B1,OneHot:()=>IV,OnesLike:()=>EV,Optimizer:()=>gl,OptimizerConstructors:()=>yl,Pack:()=>kV,PadV2:()=>NV,Pool:()=>dae,Pow:()=>DV,Prelu:()=>AV,Prod:()=>RV,RMSPropOptimizer:()=>Zb,RaggedGather:()=>$V,RaggedTensorToTensor:()=>OV,Range:()=>FV,Rank:()=>Fb,Real:()=>MV,RealDiv:()=>D3,Reciprocal:()=>PV,Reduction:()=>Wr,Relu:()=>LV,Relu6:()=>UV,Reshape:()=>VV,ResizeBilinear:()=>zV,ResizeBilinearGrad:()=>pae,ResizeNearestNeighbor:()=>BV,ResizeNearestNeighborGrad:()=>hae,Reverse:()=>WV,RotateWithOffset:()=>IB,Round:()=>GV,Rsqrt:()=>HV,SGDOptimizer:()=>mf,ScatterNd:()=>jV,SearchSorted:()=>qV,Select:()=>KV,Selu:()=>XV,Sigmoid:()=>eB,Sign:()=>JV,Sin:()=>ZV,Sinh:()=>QV,Slice:()=>YV,Softmax:()=>iB,Softplus:()=>tB,SpaceToBatchND:()=>sB,SparseFillEmptyRows:()=>aB,SparseReshape:()=>lB,SparseSegmentMean:()=>uB,SparseSegmentSum:()=>cB,SparseToDense:()=>dB,SplitV:()=>oB,Sqrt:()=>nB,Square:()=>fae,SquaredDifference:()=>hB,Step:()=>EB,StridedSlice:()=>pB,StringNGrams:()=>fB,StringSplit:()=>mB,StringToHashBucketFast:()=>gB,Sub:()=>yB,Sum:()=>rB,Tan:()=>bB,Tanh:()=>_B,Tensor:()=>En,TensorBuffer:()=>Ob,Tile:()=>I1,TopK:()=>vB,Transform:()=>wB,Transpose:()=>Ib,Unique:()=>xB,Unpack:()=>SB,UnsortedSegmentSum:()=>TB,UpperBound:()=>mae,Variable:()=>cf,ZerosLike:()=>CB,_FusedMatMul:()=>N1,abs:()=>Rs,acos:()=>Nz,acosh:()=>Dz,add:()=>qe,addN:()=>Az,all:()=>Rz,any:()=>$z,argMax:()=>Oz,argMin:()=>Fz,asin:()=>Mz,asinh:()=>Pz,atan:()=>Lz,atan2:()=>Vz,atanh:()=>Bz,avgPool:()=>TC,avgPool3d:()=>Gz,backend:()=>aue,backend_util:()=>Le,basicLSTMCell:()=>Hz,batchNorm:()=>bf,batchNorm2d:()=>jz,batchNorm3d:()=>qz,batchNorm4d:()=>Kz,batchToSpaceND:()=>CC,bincount:()=>EC,booleanMaskAsync:()=>kU,broadcastArgs:()=>Xz,broadcastTo:()=>_f,broadcast_util:()=>We,browser:()=>ut,buffer:()=>Pi,cast:()=>_n,ceil:()=>Yz,clipByValue:()=>Zz,clone:()=>Ta,complex:()=>Sa,concat:()=>Ur,concat1d:()=>Qz,concat2d:()=>Jz,concat3d:()=>e4,concat4d:()=>t4,conv1d:()=>n4,conv2d:()=>vf,conv2dTranspose:()=>s4,conv3d:()=>o4,conv3dTranspose:()=>i4,copyRegisteredKernels:()=>vae,cos:()=>a4,cosh:()=>l4,cosineWindow:()=>a_,cumprod:()=>u4,cumsum:()=>c4,customGrad:()=>zi,denseBincount:()=>d4,deprecationWarn:()=>cz,depthToSpace:()=>h4,depthwiseConv2d:()=>e_,device_util:()=>Xe,diag:()=>p4,dilation2d:()=>f4,disableDeprecationWarnings:()=>Kle,dispose:()=>ws,disposeVariables:()=>Xle,div:()=>sn,divNoNan:()=>m4,dot:()=>g4,dropout:()=>$U,einsum:()=>y4,elu:()=>kC,enableDebugMode:()=>qle,enableProdMode:()=>jle,enclosingPowerOfTwo:()=>oE,engine:()=>Yle,env:()=>at,equal:()=>IC,erf:()=>b4,euclideanNorm:()=>w4,exp:()=>bl,expandDims:()=>_l,expm1:()=>x4,eye:()=>DC,fft:()=>o_,fill:()=>Rd,findBackend:()=>sue,findBackendFactory:()=>oue,floor:()=>AC,floorDiv:()=>vC,fused:()=>ge,gather:()=>RC,gatherND:()=>RU,gather_util:()=>Ae,getBackend:()=>nue,getGradient:()=>R1,getKernel:()=>kb,getKernelsForBackend:()=>Nb,grad:()=>Kue,grads:()=>Xue,greater:()=>Sf,greaterEqual:()=>$C,ifft:()=>If,imag:()=>pf,image:()=>dE,inTopKAsync:()=>OU,io:()=>en,irfft:()=>JC,isFinite:()=>S4,isInf:()=>T4,isNaN:()=>C4,keep:()=>Li,kernel_impls:()=>Gt,leakyRelu:()=>OC,less:()=>E4,lessEqual:()=>n_,linalg:()=>GU,linspace:()=>I4,localResponseNormalization:()=>k4,log:()=>Md,log1p:()=>FC,logSigmoid:()=>N4,logSoftmax:()=>D4,logSumExp:()=>PC,logicalAnd:()=>Tf,logicalNot:()=>LC,logicalOr:()=>VC,logicalXor:()=>A4,losses:()=>HU,lowerBound:()=>R4,matMul:()=>Wt,math:()=>ht,max:()=>Wu,maxPool:()=>BC,maxPool3d:()=>$4,maxPoolWithArgmax:()=>O4,maximum:()=>wC,mean:()=>Cf,memory:()=>Zle,meshgrid:()=>F4,min:()=>t_,minimum:()=>zC,mirrorPad:()=>M4,mod:()=>P4,moments:()=>L4,movingAverage:()=>NU,mul:()=>xe,multiRNNCell:()=>V4,multinomial:()=>B4,neg:()=>Vi,nextFrame:()=>dme,norm:()=>xf,notEqual:()=>UC,oneHot:()=>Gb,ones:()=>wl,onesLike:()=>z4,op:()=>M,outerProduct:()=>U4,pad:()=>Pd,pad1d:()=>W4,pad2d:()=>G4,pad3d:()=>H4,pad4d:()=>j4,pool:()=>q4,pow:()=>$d,prelu:()=>GC,print:()=>nC,prod:()=>K4,profile:()=>Qle,raggedGather:()=>X4,raggedTensorToTensor:()=>Y4,rand:()=>Z4,randomGamma:()=>Q4,randomNormal:()=>qC,randomStandardNormal:()=>J4,randomUniform:()=>KC,range:()=>Ld,ready:()=>tue,real:()=>Ad,reciprocal:()=>eU,registerBackend:()=>iue,registerGradient:()=>yae,registerKernel:()=>kB,relu:()=>Ef,relu6:()=>XC,removeBackend:()=>rue,reshape:()=>ie,reverse:()=>Sl,reverse1d:()=>tU,reverse2d:()=>nU,reverse3d:()=>rU,reverse4d:()=>sU,rfft:()=>i_,round:()=>YC,rsqrt:()=>oU,scalar:()=>Tt,scatterND:()=>DU,scatter_util:()=>J,searchSorted:()=>s_,selu:()=>iU,separableConv2d:()=>aU,serialization:()=>ve,setBackend:()=>eue,setPlatform:()=>lue,setdiff1dAsync:()=>lU,sigmoid:()=>zu,sign:()=>uU,signal:()=>WU,sin:()=>cU,sinh:()=>dU,slice:()=>Xt,slice1d:()=>hU,slice2d:()=>pU,slice3d:()=>fU,slice4d:()=>mU,slice_util:()=>ye,softmax:()=>QC,softplus:()=>MC,spaceToBatchND:()=>WC,sparse:()=>jU,sparseToDense:()=>AU,spectral:()=>UU,split:()=>Vd,sqrt:()=>Bi,square:()=>ko,squaredDifference:()=>eE,squeeze:()=>kf,stack:()=>Ui,step:()=>tE,stridedSlice:()=>gU,string:()=>qU,sub:()=>yt,sum:()=>on,sumOutType:()=>zae,tan:()=>yU,tanh:()=>Jb,tensor:()=>ui,tensor1d:()=>Do,tensor2d:()=>Bd,tensor3d:()=>cC,tensor4d:()=>bU,tensor5d:()=>_U,tensor6d:()=>vU,tensor_util:()=>tr,test_util:()=>ae,tidy:()=>Lt,tile:()=>Fd,time:()=>Jle,topk:()=>wU,train:()=>ume,transpose:()=>ff,truncatedNormal:()=>xU,unique:()=>SU,unregisterGradient:()=>_ae,unregisterKernel:()=>bae,unsortedSegmentSum:()=>TU,unstack:()=>Tl,upcastType:()=>Bb,upperBound:()=>CU,util:()=>He,valueAndGrad:()=>Yue,valueAndGrads:()=>Zue,variable:()=>EU,variableGrads:()=>kz,version_core:()=>Bue,where:()=>Uu,whereAsync:()=>rE,zeros:()=>vl,zerosLike:()=>As});var Kn={};K.r(Kn),K.d(Kn,{json:()=>pge});var mo={};K.r(mo),K.d(mo,{json:()=>fge});var zs={};K.r(zs),K.d(zs,{json:()=>mge});var kt={};K.r(kt),K.d(kt,{json:()=>gge});var Mt={};K.r(Mt),K.d(Mt,{json:()=>yge});var Pt={};K.r(Pt),K.d(Pt,{json:()=>bge});var ce={};K.r(ce),K.d(ce,{json:()=>_ge});var oe={};K.r(oe),K.d(oe,{json:()=>vge});var O={};K.r(O),K.d(O,{json:()=>wge});var we={};K.r(we),K.d(we,{json:()=>xge});var je={};K.r(je),K.d(je,{json:()=>Sge});var Nt={};K.r(Nt),K.d(Nt,{json:()=>Tge});var gt={};K.r(gt),K.d(gt,{json:()=>Cge});var Bt={};K.r(Bt),K.d(Bt,{json:()=>Ege});var On={};K.r(On),K.d(On,{json:()=>Ige});var Bn={};K.r(Bn),K.d(Bn,{json:()=>kge});var rr={};K.r(rr),K.d(rr,{json:()=>Nge});var Sn={};K.r(Sn),K.d(Sn,{json:()=>Dge});var Kr={};K.r(Kr),K.d(Kr,{json:()=>Age});var wt={};K.r(wt),K.d(wt,{OP_SCOPE_SUFFIX:()=>B1,abs:()=>Rs,acos:()=>Nz,acosh:()=>Dz,add:()=>qe,addN:()=>Az,all:()=>Rz,any:()=>$z,argMax:()=>Oz,argMin:()=>Fz,asin:()=>Mz,asinh:()=>Pz,atan:()=>Lz,atan2:()=>Vz,atanh:()=>Bz,avgPool:()=>TC,avgPool3d:()=>Gz,basicLSTMCell:()=>Hz,batchNorm:()=>bf,batchNorm2d:()=>jz,batchNorm3d:()=>qz,batchNorm4d:()=>Kz,batchToSpaceND:()=>CC,bincount:()=>EC,booleanMaskAsync:()=>kU,broadcastArgs:()=>Xz,broadcastTo:()=>_f,buffer:()=>Pi,cast:()=>_n,ceil:()=>Yz,clipByValue:()=>Zz,clone:()=>Ta,complex:()=>Sa,concat:()=>Ur,concat1d:()=>Qz,concat2d:()=>Jz,concat3d:()=>e4,concat4d:()=>t4,conv1d:()=>n4,conv2d:()=>vf,conv2dTranspose:()=>s4,conv3d:()=>o4,conv3dTranspose:()=>i4,cos:()=>a4,cosh:()=>l4,cosineWindow:()=>a_,cumprod:()=>u4,cumsum:()=>c4,denseBincount:()=>d4,depthToSpace:()=>h4,depthwiseConv2d:()=>e_,diag:()=>p4,dilation2d:()=>f4,div:()=>sn,divNoNan:()=>m4,dot:()=>g4,dropout:()=>$U,einsum:()=>y4,elu:()=>kC,enclosingPowerOfTwo:()=>oE,equal:()=>IC,erf:()=>b4,euclideanNorm:()=>w4,exp:()=>bl,expandDims:()=>_l,expm1:()=>x4,eye:()=>DC,fft:()=>o_,fill:()=>Rd,floor:()=>AC,floorDiv:()=>vC,fused:()=>ge,gather:()=>RC,gatherND:()=>RU,greater:()=>Sf,greaterEqual:()=>$C,ifft:()=>If,imag:()=>pf,image:()=>dE,inTopKAsync:()=>OU,irfft:()=>JC,isFinite:()=>S4,isInf:()=>T4,isNaN:()=>C4,leakyRelu:()=>OC,less:()=>E4,lessEqual:()=>n_,linalg:()=>GU,linspace:()=>I4,localResponseNormalization:()=>k4,log:()=>Md,log1p:()=>FC,logSigmoid:()=>N4,logSoftmax:()=>D4,logSumExp:()=>PC,logicalAnd:()=>Tf,logicalNot:()=>LC,logicalOr:()=>VC,logicalXor:()=>A4,losses:()=>HU,lowerBound:()=>R4,matMul:()=>Wt,max:()=>Wu,maxPool:()=>BC,maxPool3d:()=>$4,maxPoolWithArgmax:()=>O4,maximum:()=>wC,mean:()=>Cf,meshgrid:()=>F4,min:()=>t_,minimum:()=>zC,mirrorPad:()=>M4,mod:()=>P4,moments:()=>L4,movingAverage:()=>NU,mul:()=>xe,multiRNNCell:()=>V4,multinomial:()=>B4,neg:()=>Vi,norm:()=>xf,notEqual:()=>UC,oneHot:()=>Gb,ones:()=>wl,onesLike:()=>z4,op:()=>M,outerProduct:()=>U4,pad:()=>Pd,pad1d:()=>W4,pad2d:()=>G4,pad3d:()=>H4,pad4d:()=>j4,pool:()=>q4,pow:()=>$d,prelu:()=>GC,print:()=>nC,prod:()=>K4,raggedGather:()=>X4,raggedTensorToTensor:()=>Y4,rand:()=>Z4,randomGamma:()=>Q4,randomNormal:()=>qC,randomStandardNormal:()=>J4,randomUniform:()=>KC,range:()=>Ld,real:()=>Ad,reciprocal:()=>eU,relu:()=>Ef,relu6:()=>XC,reshape:()=>ie,reverse:()=>Sl,reverse1d:()=>tU,reverse2d:()=>nU,reverse3d:()=>rU,reverse4d:()=>sU,rfft:()=>i_,round:()=>YC,rsqrt:()=>oU,scalar:()=>Tt,scatterND:()=>DU,searchSorted:()=>s_,selu:()=>iU,separableConv2d:()=>aU,setdiff1dAsync:()=>lU,sigmoid:()=>zu,sign:()=>uU,signal:()=>WU,sin:()=>cU,sinh:()=>dU,slice:()=>Xt,slice1d:()=>hU,slice2d:()=>pU,slice3d:()=>fU,slice4d:()=>mU,softmax:()=>QC,softplus:()=>MC,spaceToBatchND:()=>WC,sparse:()=>jU,sparseToDense:()=>AU,spectral:()=>UU,split:()=>Vd,sqrt:()=>Bi,square:()=>ko,squaredDifference:()=>eE,squeeze:()=>kf,stack:()=>Ui,step:()=>tE,stridedSlice:()=>gU,string:()=>qU,sub:()=>yt,sum:()=>on,tan:()=>yU,tanh:()=>Jb,tensor:()=>ui,tensor1d:()=>Do,tensor2d:()=>Bd,tensor3d:()=>cC,tensor4d:()=>bU,tensor5d:()=>_U,tensor6d:()=>vU,tile:()=>Fd,topk:()=>wU,transpose:()=>ff,truncatedNormal:()=>xU,unique:()=>SU,unsortedSegmentSum:()=>TU,unstack:()=>Tl,upperBound:()=>CU,variable:()=>EU,where:()=>Uu,whereAsync:()=>rE,zeros:()=>vl,zerosLike:()=>As});var Mr={};K.r(Mr),K.d(Mr,{assertParamsValid:()=>hk,computeFlatOffset:()=>mk,computeOutShape:()=>pk,getNormalizedAxes:()=>__e,isSliceContinous:()=>fk,maskToAxes:()=>b_e,parseSliceParams:()=>Fv,sliceInfo:()=>gk,startForAxis:()=>NG,startIndicesWithElidedDims:()=>EG,stopForAxis:()=>DG,stopIndicesWithElidedDims:()=>IG,stridesForAxis:()=>kG,stridesWithElidedDims:()=>SG});var Ha={};K.r(Ha),K.d(Ha,{collectGatherOpShapeInfo:()=>fN,computeOutShape:()=>$H,segOpComputeOptimalWindowSize:()=>RH});var I0={};K.r(I0),K.d(I0,{ERF_A1:()=>eN,ERF_A2:()=>tN,ERF_A3:()=>nN,ERF_A4:()=>rN,ERF_A5:()=>sN,ERF_P:()=>Jk,PARALLELIZE_THRESHOLD:()=>Kk,RowPartitionType:()=>Vo,SELU_SCALE:()=>Jv,SELU_SCALEALPHA:()=>Qv,applyActivation:()=>Kv,assertAndGetBroadcastShape:()=>tt,assertAxesAreInnerMostDims:()=>$r,assertParamsConsistent:()=>qk,assignToTypedArray:()=>gH,axesAreInnerMostDims:()=>Ek,calculateShapes:()=>qm,checkEinsumDimSizes:()=>uN,checkPadOnDimRoundingMode:()=>is,combineLocations:()=>VG,combineRaggedTensorToTensorShapes:()=>lH,complexWithEvenIndex:()=>fH,complexWithOddIndex:()=>mH,computeConv2DInfo:()=>xr,computeConv3DInfo:()=>Ml,computeDefaultPad:()=>bk,computeDilation2DInfo:()=>Fm,computeOptimalWindowSize:()=>Zv,computeOutAndReduceShapes:()=>Sr,computeOutShape:()=>Xi,computePool2DInfo:()=>Fo,computePool3DInfo:()=>Da,convertConv2DDataFormat:()=>Aa,decodeEinsumEquation:()=>aN,eitherStridesOrDilationsAreOne:()=>Rr,expandShapeToKeepDim:()=>Hn,exponent:()=>bH,exponents:()=>yH,fromStringArrayToUint8:()=>OH,fromUint8ToStringArray:()=>ac,getAxesPermutation:()=>Dn,getBroadcastDims:()=>nh,getComplexWithIndex:()=>oN,getEinsumComputePath:()=>cN,getEinsumPermutation:()=>lN,getFusedBiasGradient:()=>qv,getFusedDyActivation:()=>jv,getImageCenter:()=>Xk,getInnerMostAxes:()=>jn,getPermuted:()=>Hm,getRaggedRank:()=>cH,getReductionAxes:()=>cr,getReshaped:()=>Gm,getReshapedPermuted:()=>jm,getRowPartitionTypesHelper:()=>uH,getSliceBeginCoords:()=>Yk,getSliceSize:()=>Zk,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>wH,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>xH,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>SH,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>EH,getSparseReshapeInputOutputMismatchErrorMessage:()=>kH,getSparseReshapeInputOutputMultipleErrorMessage:()=>IH,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>TH,getSparseReshapeNegativeOutputDimErrorMessage:()=>CH,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>AH,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>pN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>NH,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>DH,getUndoAxesPermutation:()=>Ll,isIdentityPermutation:()=>dN,log:()=>Mye,mergeRealAndImagArrays:()=>Ma,prepareAndValidate:()=>Qk,prepareSplitSize:()=>hN,segment_util:()=>Ha,shouldFuse:()=>Xv,slice_util:()=>Mr,splitRealAndImagArrays:()=>pH,stridesOrDilationsArePositive:()=>nc,tupleValuesAreOne:()=>Pl,upcastType:()=>Fs,validateDefaultValueShape:()=>dH,validateInput:()=>pxe,validateUpdateShape:()=>hH,warn:()=>to});var k0={};function Fn(n){return"function"==typeof n}function N0(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}K.r(k0),K.d(k0,{addImpl:()=>h8,bincountImpl:()=>SD,bincountReduceImpl:()=>b8,castImpl:()=>d8,ceilImpl:()=>_8,concatImpl:()=>v8,equalImpl:()=>S8,expImpl:()=>C8,expm1Impl:()=>I8,floorImpl:()=>D8,gatherNdImpl:()=>A8,gatherV2Impl:()=>R8,greaterEqualImpl:()=>O8,greaterImpl:()=>$8,lessEqualImpl:()=>M8,lessImpl:()=>F8,linSpaceImpl:()=>P8,logImpl:()=>L8,maxImpl:()=>V8,maximumImpl:()=>z8,minimumImpl:()=>U8,multiplyImpl:()=>TD,negImpl:()=>G8,notEqualImpl:()=>H8,prodImpl:()=>X8,raggedGatherImpl:()=>Z8,raggedRangeImpl:()=>J8,raggedTensorToTensorImpl:()=>n5,rangeImpl:()=>r5,rsqrtImpl:()=>s5,scatterImpl:()=>vh,sigmoidImpl:()=>zIe,simpleAbsImpl:()=>f8,sliceImpl:()=>y8,sparseFillEmptyRowsImpl:()=>i5,sparseReshapeImpl:()=>a5,sparseSegmentReductionImpl:()=>DD,sqrtImpl:()=>cRe,squaredDifferenceImpl:()=>l5,stridedSliceImpl:()=>u5,stringNGramsImpl:()=>c5,stringSplitImpl:()=>d5,stringToHashBucketFastImpl:()=>h5,subImpl:()=>k8,tileImpl:()=>p5,topKImpl:()=>m5,transposeImpl:()=>wD,uniqueImpl:()=>y5});const D0=N0(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function Rg(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class hs{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(Fn(r))try{r()}catch(o){t=o instanceof D0?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{RA(o)}catch(i){t=null!=t?t:[],i instanceof D0?t=[...t,...i.errors]:t.push(i)}}if(t)throw new D0(t)}}add(t){var e;if(t&&t!==this)if(this.closed)RA(t);else{if(t instanceof hs){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&Rg(e,t)}remove(t){const{_finalizers:e}=this;e&&Rg(e,t),t instanceof hs&&t._removeParent(this)}}hs.EMPTY=(()=>{const n=new hs;return n.closed=!0,n})();const DA=hs.EMPTY;function AA(n){return n instanceof hs||n&&"closed"in n&&Fn(n.remove)&&Fn(n.add)&&Fn(n.unsubscribe)}function RA(n){Fn(n)?n():n.unsubscribe()}const au={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},$g={setTimeout(n,t,...e){const{delegate:r}=$g;return(null==r?void 0:r.setTimeout)?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=$g;return((null==t?void 0:t.clearTimeout)||clearTimeout)(n)},delegate:void 0};function $A(n){$g.setTimeout(()=>{const{onUnhandledError:t}=au;if(!t)throw n;t(n)})}function A0(){}const KK=R0("C",void 0,void 0);function R0(n,t,e){return{kind:n,value:t,error:e}}let lu=null;function Og(n){if(au.useDeprecatedSynchronousErrorHandling){const t=!lu;if(t&&(lu={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=lu;if(lu=null,e)throw r}}else n()}class $0 extends hs{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,AA(t)&&t.add(this)):this.destination=t7}static create(t,e,r){return new Bh(t,e,r)}next(t){this.isStopped?F0(function YK(n){return R0("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?F0(function XK(n){return R0("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?F0(KK,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const QK=Function.prototype.bind;function O0(n,t){return QK.call(n,t)}class JK{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){Fg(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){Fg(r)}else Fg(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){Fg(e)}}}class Bh extends $0{constructor(t,e,r){let s;if(super(),Fn(t)||!t)s={next:null!=t?t:void 0,error:null!=e?e:void 0,complete:null!=r?r:void 0};else{let o;this&&au.useDeprecatedNextContext?(o=Object.create(t),o.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&O0(t.next,o),error:t.error&&O0(t.error,o),complete:t.complete&&O0(t.complete,o)}):s=t}this.destination=new JK(s)}}function Fg(n){au.useDeprecatedSynchronousErrorHandling?function ZK(n){au.useDeprecatedSynchronousErrorHandling&&lu&&(lu.errorThrown=!0,lu.error=n)}(n):$A(n)}function F0(n,t){const{onStoppedNotification:e}=au;e&&$g.setTimeout(()=>e(n,t))}const t7={closed:!0,next:A0,error:function e7(n){throw n},complete:A0},M0="function"==typeof Symbol&&Symbol.observable||"@@observable";function ja(n){return n}let sr=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const o=function r7(n){return n&&n instanceof $0||function n7(n){return n&&Fn(n.next)&&Fn(n.error)&&Fn(n.complete)}(n)&&AA(n)}(e)?e:new Bh(e,r,s);return Og(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=FA(r))((s,o)=>{const i=new Bh({next:a=>{try{e(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[M0](){return this}pipe(...e){return function OA(n){return 0===n.length?ja:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}(e)(this)}toPromise(e){return new(e=FA(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return n.create=t=>new n(t),n})();function FA(n){var t;return null!==(t=null!=n?n:au.Promise)&&void 0!==t?t:Promise}const s7=N0(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let go=(()=>{class n extends sr{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new MA(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new s7}next(e){Og(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Og(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Og(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:o}=this;return r||s?DA:(this.currentObservers=null,o.push(e),new hs(()=>{this.currentObservers=null,Rg(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:o}=this;r?e.error(s):o&&e.complete()}asObservable(){const e=new sr;return e.source=this,e}}return n.create=(t,e)=>new MA(t,e),n})();class MA extends go{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:DA}}function PA(n){return Fn(null==n?void 0:n.lift)}function or(n){return t=>{if(PA(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Xn(n,t,e,r,s){return new o7(n,t,e,r,s)}class o7 extends $0{constructor(t,e,r,s,o,i){super(t),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function bn(n,t){return or((e,r)=>{let s=0;e.subscribe(Xn(r,o=>{r.next(n.call(t,o,s++))}))})}function uu(n){return this instanceof uu?(this.v=n,this):new uu(n)}function l7(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),o=[];return s={},i("next"),i("throw"),i("return"),s[Symbol.asyncIterator]=function(){return this},s;function i(h){r[h]&&(s[h]=function(p){return new Promise(function(f,m){o.push([h,p,f,m])>1||a(h,p)})})}function a(h,p){try{!function l(h){h.value instanceof uu?Promise.resolve(h.value.v).then(u,c):d(o[0][2],h)}(r[h](p))}catch(f){d(o[0][3],f)}}function u(h){a("next",h)}function c(h){a("throw",h)}function d(h,p){h(p),o.shift(),o.length&&a(o[0][0],o[0][1])}}function u7(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function BA(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=n[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(u){o({value:u,done:a})},i)}(a,l,(i=n[o](i)).done,i.value)})}}}const zA=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function UA(n){return Fn(null==n?void 0:n.then)}function WA(n){return Fn(n[M0])}function GA(n){return Symbol.asyncIterator&&Fn(null==n?void 0:n[Symbol.asyncIterator])}function HA(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const jA=function d7(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function qA(n){return Fn(null==n?void 0:n[jA])}function KA(n){return l7(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield uu(e.read());if(s)return yield uu(void 0);yield yield uu(r)}}finally{e.releaseLock()}})}function XA(n){return Fn(null==n?void 0:n.getReader)}function yo(n){if(n instanceof sr)return n;if(null!=n){if(WA(n))return function h7(n){return new sr(t=>{const e=n[M0]();if(Fn(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(zA(n))return function p7(n){return new sr(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(UA(n))return function f7(n){return new sr(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,$A)})}(n);if(GA(n))return YA(n);if(qA(n))return function m7(n){return new sr(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(XA(n))return function g7(n){return YA(KA(n))}(n)}throw HA(n)}function YA(n){return new sr(t=>{(function y7(n,t){var e,r,s,o;return function i7(n,t,e,r){return new(e||(e=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof e?o:new e(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=u7(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function oa(n,t,e,r=0,s=!1){const o=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(o),!s)return o}function Nr(n,t,e=1/0){return Fn(t)?Nr((r,s)=>bn((o,i)=>t(r,o,s,i))(yo(n(r,s))),e):("number"==typeof t&&(e=t),or((r,s)=>function b7(n,t,e,r,s,o,i,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&t.complete()},p=m=>u<r?f(m):l.push(m),f=m=>{o&&t.next(m),u++;let g=!1;yo(e(m,c++)).subscribe(Xn(t,y=>{null==s||s(y),o?p(y):t.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(u--;l.length&&u<r;){const y=l.shift();i?oa(t,i,()=>f(y)):f(y)}h()}catch(y){t.error(y)}}))};return n.subscribe(Xn(t,p,()=>{d=!0,h()})),()=>{null==a||a()}}(r,s,n,e)))}function zh(n=1/0){return Nr(ja,n)}const ia=new sr(n=>n.complete());function ZA(n){return n&&Fn(n.schedule)}function L0(n){return n[n.length-1]}function Uh(n){return ZA(L0(n))?n.pop():void 0}function QA(n,t=0){return or((e,r)=>{e.subscribe(Xn(r,s=>oa(r,n,()=>r.next(s),t),()=>oa(r,n,()=>r.complete(),t),s=>oa(r,n,()=>r.error(s),t)))})}function JA(n,t=0){return or((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function e2(n,t){if(!n)throw new Error("Iterable cannot be null");return new sr(e=>{oa(e,t,()=>{const r=n[Symbol.asyncIterator]();oa(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function Xr(n,t){return t?function I7(n,t){if(null!=n){if(WA(n))return function x7(n,t){return yo(n).pipe(JA(t),QA(t))}(n,t);if(zA(n))return function T7(n,t){return new sr(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(UA(n))return function S7(n,t){return yo(n).pipe(JA(t),QA(t))}(n,t);if(GA(n))return e2(n,t);if(qA(n))return function C7(n,t){return new sr(e=>{let r;return oa(e,t,()=>{r=n[jA](),oa(e,t,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void e.error(i)}o?e.complete():e.next(s)},0,!0)}),()=>Fn(null==r?void 0:r.return)&&r.return()})}(n,t);if(XA(n))return function E7(n,t){return e2(KA(n),t)}(n,t)}throw HA(n)}(n,t):yo(n)}function V0(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new Bh({next:()=>{r.unsubscribe(),n()}});return t(...e).subscribe(r)}function tn(n){for(let t in n)if(n[t]===tn)return t;throw Error("Could not find renamed property on target object.")}function B0(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function qt(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(qt).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function z0(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const D7=tn({__forward_ref__:tn});function U0(n){return n.__forward_ref__=U0,n.toString=function(){return qt(this())},n}function pt(n){return function t2(n){return"function"==typeof n&&n.hasOwnProperty(D7)&&n.__forward_ref__===U0}(n)?n():n}class Oe extends Error{constructor(t,e){super(function W0(n,t){return`NG0${Math.abs(n)}${t?": "+t:""}`}(t,e)),this.code=t}}function st(n){return"string"==typeof n?n:null==n?"":String(n)}function Pr(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():st(n)}function Mg(n,t){const e=t?` in ${t}`:"";throw new Oe(-201,`No provider for ${Pr(n)} found${e}`)}function Ws(n,t){null==n&&function Kt(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function lt(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function ps(n){return{providers:n.providers||[],imports:n.imports||[]}}function G0(n){return n2(n,Pg)||n2(n,s2)}function n2(n,t){return n.hasOwnProperty(t)?n[t]:null}function r2(n){return n&&(n.hasOwnProperty(H0)||n.hasOwnProperty(P7))?n[H0]:null}const Pg=tn({\u0275prov:tn}),H0=tn({\u0275inj:tn}),s2=tn({ngInjectableDef:tn}),P7=tn({ngInjectorDef:tn});var et=(()=>((et=et||{})[et.Default=0]="Default",et[et.Host=1]="Host",et[et.Self=2]="Self",et[et.SkipSelf=4]="SkipSelf",et[et.Optional=8]="Optional",et))();let j0;function qa(n){const t=j0;return j0=n,t}function o2(n,t,e){const r=G0(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&et.Optional?null:void 0!==t?t:void Mg(qt(n),"Injector")}function Ka(n){return{toString:n}.toString()}var qo=(()=>((qo=qo||{})[qo.OnPush=0]="OnPush",qo[qo.Default=1]="Default",qo))(),Ko=(()=>{return(n=Ko||(Ko={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",Ko;var n})();const V7="undefined"!=typeof globalThis&&globalThis,B7="undefined"!=typeof window&&window,z7="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Qt=V7||"undefined"!=typeof global&&global||B7||z7,Ic={},nn=[],Lg=tn({\u0275cmp:tn}),q0=tn({\u0275dir:tn}),K0=tn({\u0275pipe:tn}),a2=tn({\u0275mod:tn}),la=tn({\u0275fac:tn}),Wh=tn({__NG_ELEMENT_ID__:tn});let U7=0;function cu(n){return Ka(()=>{const e={},r={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===qo.OnPush,directiveDefs:null,pipeDefs:null,selectors:n.selectors||nn,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||Ko.Emulated,id:"c",styles:n.styles||nn,_:null,setInput:null,schemas:n.schemas||null,tView:null},s=n.directives,o=n.features,i=n.pipes;return r.id+=U7++,r.inputs=d2(n.inputs,e),r.outputs=d2(n.outputs),o&&o.forEach(a=>a(r)),r.directiveDefs=s?()=>("function"==typeof s?s():s).map(l2):null,r.pipeDefs=i?()=>("function"==typeof i?i():i).map(u2):null,r})}function l2(n){return Vr(n)||function Xa(n){return n[q0]||null}(n)}function u2(n){return function du(n){return n[K0]||null}(n)}const c2={};function Is(n){return Ka(()=>{const t={type:n.type,bootstrap:n.bootstrap||nn,declarations:n.declarations||nn,imports:n.imports||nn,exports:n.exports||nn,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null};return null!=n.id&&(c2[n.id]=n.type),t})}function d2(n,t){if(null==n)return Ic;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,t&&(t[s]=o)}return e}const Lr=cu;function ks(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,onDestroy:n.type.prototype.ngOnDestroy||null}}function Vr(n){return n[Lg]||null}function bo(n,t){const e=n[a2]||null;if(!e&&!0===t)throw new Error(`Type ${qt(n)} does not have '\u0275mod' property.`);return e}function Si(n){return Array.isArray(n)&&"object"==typeof n[1]}function Yo(n){return Array.isArray(n)&&!0===n[1]}function Z0(n){return 0!=(8&n.flags)}function Ug(n){return 2==(2&n.flags)}function Wg(n){return 1==(1&n.flags)}function Zo(n){return null!==n.template}function K7(n){return 0!=(512&n[2])}function mu(n,t){return n.hasOwnProperty(la)?n[la]:null}class Z7{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function p2(n){return n.type.prototype.ngOnChanges&&(n.setInput=J7),Q7}function Q7(){const n=m2(this),t=null==n?void 0:n.current;if(t){const e=n.previous;if(e===Ic)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function J7(n,t,e,r){const s=m2(n)||function e9(n,t){return n[f2]=t}(n,{previous:Ic,current:null}),o=s.current||(s.current={}),i=s.previous,a=this.declaredInputs[e],l=i[a];o[a]=new Z7(l&&l.currentValue,t,i===Ic),n[r]=t}const f2="__ngSimpleChanges__";function m2(n){return n[f2]||null}let nx;function Un(n){return!!n.listen}const g2={createRenderer:(n,t)=>function rx(){return void 0!==nx?nx:"undefined"!=typeof document?document:void 0}()};function ir(n){for(;Array.isArray(n);)n=n[0];return n}function Gg(n,t){return ir(t[n])}function Hs(n,t){return ir(t[n.index])}function sx(n,t){return n.data[t]}function Rc(n,t){return n[t]}function js(n,t){const e=t[n];return Si(e)?e:e[0]}function y2(n){return 4==(4&n[2])}function ox(n){return 128==(128&n[2])}function Ya(n,t){return null==t?null:n[t]}function b2(n){n[18]=0}function ix(n,t){n[5]+=t;let e=n,r=n[3];for(;null!==r&&(1===t&&1===e[5]||-1===t&&0===e[5]);)r[5]+=t,e=r,r=r[3]}const ot={lFrame:k2(null),bindingsEnabled:!0};function v2(){return ot.bindingsEnabled}function ue(){return ot.lFrame.lView}function Ft(){return ot.lFrame.tView}function mr(){let n=x2();for(;null!==n&&64===n.type;)n=n.parent;return n}function x2(){return ot.lFrame.currentTNode}function Ti(n,t){const e=ot.lFrame;e.currentTNode=n,e.isParent=t}function ax(){return ot.lFrame.isParent}function lx(){ot.lFrame.isParent=!1}function $c(){return ot.lFrame.bindingIndex++}function y9(n,t){const e=ot.lFrame;e.bindingIndex=e.bindingRootIndex=n,ux(t)}function ux(n){ot.lFrame.currentDirectiveIndex=n}function C2(){return ot.lFrame.currentQueryIndex}function dx(n){ot.lFrame.currentQueryIndex=n}function _9(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function E2(n,t,e){if(e&et.SkipSelf){let s=t,o=n;for(;!(s=s.parent,null!==s||e&et.Host||(s=_9(o),null===s||(o=o[15],10&s.type))););if(null===s)return!1;t=s,n=o}const r=ot.lFrame=I2();return r.currentTNode=t,r.lView=n,!0}function jg(n){const t=I2(),e=n[1];ot.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function I2(){const n=ot.lFrame,t=null===n?null:n.child;return null===t?k2(n):t}function k2(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function N2(){const n=ot.lFrame;return ot.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const D2=N2;function qg(){const n=N2();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function gs(){return ot.lFrame.selectedIndex}function Za(n){ot.lFrame.selectedIndex=n}function Mn(){const n=ot.lFrame;return sx(n.tView,n.selectedIndex)}function Kg(){ot.lFrame.currentNamespace="svg"}function Xg(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const o=n.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=o;i&&(n.contentHooks||(n.contentHooks=[])).push(-e,i),a&&((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&&(n.viewHooks||(n.viewHooks=[])).push(-e,l),u&&((n.viewHooks||(n.viewHooks=[])).push(e,u),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,u)),null!=c&&(n.destroyHooks||(n.destroyHooks=[])).push(e,c)}}function Yg(n,t,e){A2(n,t,3,e)}function Zg(n,t,e,r){(3&n[2])===e&&A2(n,t,e,r)}function hx(n,t){let e=n[2];(3&e)===t&&(e&=2047,e+=1,n[2]=e)}function A2(n,t,e,r){const o=null!=r?r:-1,i=t.length-1;let a=0;for(let l=void 0!==r?65535&n[18]:0;l<i;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=r&&a>=r)break}else t[l]<0&&(n[18]+=65536),(a<o||-1==o)&&(I9(n,e,t,l),n[18]=(4294901760&n[18])+l+2),l++}function I9(n,t,e,r){const s=e[r]<0,o=e[r+1],a=n[s?-e[r]:e[r]];if(s){if(n[2]>>11<n[18]>>16&&(3&n[2])===t){n[2]+=2048;try{o.call(a)}finally{}}}else try{o.call(a)}finally{}}class Kh{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Qg(n,t,e){const r=Un(n);let s=0;for(;s<e.length;){const o=e[s];if("number"==typeof o){if(0!==o)break;s++;const i=e[s++],a=e[s++],l=e[s++];r?n.setAttribute(t,a,l,i):t.setAttributeNS(i,a,l)}else{const i=o,a=e[++s];fx(i)?r&&n.setProperty(t,i,a):r?n.setAttribute(t,i,a):t.setAttribute(i,a),s++}}return s}function R2(n){return 3===n||4===n||6===n}function fx(n){return 64===n.charCodeAt(0)}function Jg(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||$2(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function $2(n,t,e,r,s){let o=0,i=n.length;if(-1===t)i=-1;else for(;o<n.length;){const a=n[o++];if("number"==typeof a){if(a===t){i=-1;break}if(a>t){i=o-1;break}}}for(;o<n.length;){const a=n[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[o+1]=s));if(r===n[o+1])return void(n[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(n.splice(i,0,t),o=i+1),n.splice(o++,0,e),null!==r&&n.splice(o++,0,r),null!==s&&n.splice(o++,0,s)}function O2(n){return-1!==n}function Oc(n){return 32767&n}function Fc(n,t){let e=function R9(n){return n>>16}(n),r=t;for(;e>0;)r=r[15],e--;return r}let mx=!0;function ey(n){const t=mx;return mx=n,t}let $9=0;function Yh(n,t){const e=yx(n,t);if(-1!==e)return e;const r=t[1];r.firstCreatePass&&(n.injectorIndex=t.length,gx(r.data,n),gx(t,null),gx(r.blueprint,null));const s=ty(n,t),o=n.injectorIndex;if(O2(s)){const i=Oc(s),a=Fc(s,t),l=a[1].data;for(let u=0;u<8;u++)t[o+u]=a[i+u]|l[i+u]}return t[o+8]=s,o}function gx(n,t){n.push(0,0,0,0,0,0,0,0,t)}function yx(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function ty(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){const o=s[1],i=o.type;if(r=2===i?o.declTNode:1===i?s[6]:null,null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function ny(n,t,e){!function O9(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(Wh)&&(r=e[Wh]),null==r&&(r=e[Wh]=$9++);const s=255&r;t.data[n+(s>>5)]|=1<<s}(n,t,e)}function P2(n,t,e){if(e&et.Optional)return n;Mg(t,"NodeInjector")}function L2(n,t,e,r){if(e&et.Optional&&void 0===r&&(r=null),0==(e&(et.Self|et.Host))){const s=n[9],o=qa(void 0);try{return s?s.get(t,r,e&et.Optional):o2(t,r,e&et.Optional)}finally{qa(o)}}return P2(r,t,e)}function V2(n,t,e,r=et.Default,s){if(null!==n){const o=function L9(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(Wh)?n[Wh]:void 0;return"number"==typeof t?t>=0?255&t:M9:t}(e);if("function"==typeof o){if(!E2(t,n,r))return r&et.Host?P2(s,e,r):L2(t,e,r,s);try{const i=o(r);if(null!=i||r&et.Optional)return i;Mg(e)}finally{D2()}}else if("number"==typeof o){let i=null,a=yx(n,t),l=-1,u=r&et.Host?t[16][6]:null;for((-1===a||r&et.SkipSelf)&&(l=-1===a?ty(n,t):t[a+8],-1!==l&&U2(r,!1)?(i=t[1],a=Oc(l),t=Fc(l,t)):a=-1);-1!==a;){const c=t[1];if(z2(o,a,c.data)){const d=P9(a,t,e,i,r,u);if(d!==B2)return d}l=t[a+8],-1!==l&&U2(r,t[1].data[a+8]===u)&&z2(o,a,t)?(i=c,a=Oc(l),t=Fc(l,t)):a=-1}}}return L2(t,e,r,s)}const B2={};function M9(){return new Mc(mr(),ue())}function P9(n,t,e,r,s,o){const i=t[1],a=i.data[n+8],c=ry(a,i,e,null==r?Ug(a)&&mx:r!=i&&0!=(3&a.type),s&et.Host&&o===a);return null!==c?Zh(t,i,c,a):B2}function ry(n,t,e,r,s){const o=n.providerIndexes,i=t.data,a=1048575&o,l=n.directiveStart,c=o>>20,h=s?a+c:n.directiveEnd;for(let p=r?a:a+c;p<h;p++){const f=i[p];if(p<l&&e===f||p>=l&&f.type===e)return p}if(s){const p=i[l];if(p&&Zo(p)&&p.type===e)return l}return null}function Zh(n,t,e,r){let s=n[e];const o=t.data;if(function k9(n){return n instanceof Kh}(s)){const i=s;i.resolving&&function A7(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new Oe(-200,`Circular dependency in DI detected for ${n}${e}`)}(Pr(o[e]));const a=ey(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?qa(i.injectImpl):null;E2(n,r,et.Default);try{s=n[e]=i.factory(void 0,o,n,r),t.firstCreatePass&&e>=r.directiveStart&&function E9(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=t.type.prototype;if(r){const i=p2(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,i)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,s),o&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o))}(e,o[e],t)}finally{null!==l&&qa(l),ey(a),i.resolving=!1,D2()}}return s}function z2(n,t,e){return!!(e[t+(n>>5)]&1<<n)}function U2(n,t){return!(n&et.Self||n&et.Host&&t)}class Mc{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return V2(this._tNode,this._lView,t,r,e)}}const Lc="__parameters__";function Bc(n,t,e){return Ka(()=>{const r=function _x(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,u,c){const d=l.hasOwnProperty(Lc)?l[Lc]:Object.defineProperty(l,Lc,{value:[]})[Lc];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(i),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}class Qe{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=lt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const z9=new Qe("AnalyzeForEntryComponents");function wo(n,t){void 0===t&&(t=n);for(let e=0;e<n.length;e++){let r=n[e];Array.isArray(r)?(t===n&&(t=n.slice(0,e)),wo(r,t)):t!==n&&t.push(r)}return t}function Ci(n,t){n.forEach(e=>Array.isArray(e)?Ci(e,t):t(e))}function G2(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function sy(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function tp(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function qs(n,t,e){let r=zc(n,t);return r>=0?n[1|r]=e:(r=~r,function G9(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function wx(n,t){const e=zc(n,t);if(e>=0)return n[1|e]}function zc(n,t){return function q2(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const o=r+(s-r>>1),i=n[o<<e];if(t===i)return o<<e;i>t?s=o:r=o+1}return~(s<<e)}(n,t,1)}const np={},Sx="__NG_DI_FLAG__",iy="ngTempTokenPath",Z9=/\n/gm,X2="__source",J9=tn({provide:String,useValue:tn});let rp;function Y2(n){const t=rp;return rp=n,t}function eX(n,t=et.Default){if(void 0===rp)throw new Oe(203,"");return null===rp?o2(n,void 0,t):rp.get(n,t&et.Optional?null:void 0,t)}function Ce(n,t=et.Default){return(function L7(){return j0}()||eX)(pt(n),t)}const Tx=Ce;function Cx(n){const t=[];for(let e=0;e<n.length;e++){const r=pt(n[e]);if(Array.isArray(r)){if(0===r.length)throw new Oe(900,"");let s,o=et.Default;for(let i=0;i<r.length;i++){const a=r[i],l=tX(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}t.push(Ce(s,o))}else t.push(Ce(r))}return t}function sp(n,t){return n[Sx]=t,n.prototype[Sx]=t,n}function tX(n){return n[Sx]}const ay=sp(Bc("Inject",n=>({token:n})),-1),Ja=sp(Bc("Optional"),8),op=sp(Bc("SkipSelf"),4);var Ks=(()=>((Ks=Ks||{})[Ks.Important=1]="Important",Ks[Ks.DashCase=2]="DashCase",Ks))();const sR="__ngContext__";function Zr(n,t){n[sR]=t}function kx(n){const t=function ap(n){return n[sR]||null}(n);return t?Array.isArray(t)?t:t.lView:null}function Dx(n,t){return undefined(n,t)}function lp(n){const t=n[3];return Yo(t)?t[3]:t}function Ax(n){return dR(n[13])}function Rx(n){return dR(n[4])}function dR(n){for(;null!==n&&!Yo(n);)n=n[4];return n}function Wc(n,t,e,r,s){if(null!=r){let o,i=!1;Yo(r)?o=r:Si(r)&&(i=!0,r=r[0]);const a=ir(r);0===n&&null!==e?null==s?yR(t,e,a):yu(t,e,a,s||null,!0):1===n&&null!==e?yu(t,e,a,s||null,!0):2===n?function Vx(n,t,e){const r=uy(n,t);r&&function RX(n,t,e,r){Un(n)?n.removeChild(t,e,r):t.removeChild(e)}(n,r,t,e)}(t,a,i):3===n&&t.destroyNode(a),null!=o&&function FX(n,t,e,r,s){const o=e[7];o!==ir(e)&&Wc(t,n,r,o,s);for(let a=10;a<e.length;a++){const l=e[a];up(l[1],l,n,t,r,o)}}(t,n,o,e,s)}}function Ox(n,t,e){if(Un(n))return n.createElement(t,e);{const r=null!==e?function s9(n){const t=n.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(e):null;return null===r?n.createElement(t):n.createElementNS(r,t)}}function pR(n,t){const e=n[9],r=e.indexOf(t),s=t[3];1024&t[2]&&(t[2]&=-1025,ix(s,-1)),e.splice(r,1)}function Fx(n,t){if(n.length<=10)return;const e=10+t,r=n[e];if(r){const s=r[17];null!==s&&s!==n&&pR(s,r),t>0&&(n[e-1][4]=r[4]);const o=sy(n,10+t);!function TX(n,t){up(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(r[1],r);const i=o[19];null!==i&&i.detachView(o[1]),r[3]=null,r[4]=null,r[2]&=-129}return r}function fR(n,t){if(!(256&t[2])){const e=t[11];Un(e)&&e.destroyNode&&up(n,t,e,3,null,null),function IX(n){let t=n[13];if(!t)return Mx(n[1],n);for(;t;){let e=null;if(Si(t))e=t[13];else{const r=t[10];r&&(e=r)}if(!e){for(;t&&!t[4]&&t!==n;)Si(t)&&Mx(t[1],t),t=t[3];null===t&&(t=n),Si(t)&&Mx(t[1],t),e=t&&t[4]}t=e}}(t)}}function Mx(n,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function AX(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof Kh)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];try{l.call(a)}finally{}}else try{o.call(s)}finally{}}}}(n,t),function DX(n,t){const e=n.cleanup,r=t[7];let s=-1;if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+1],a="function"==typeof i?i(t):ir(t[i]),l=r[s=e[o+2]],u=e[o+3];"boolean"==typeof u?a.removeEventListener(e[o],l,u):u>=0?r[s=u]():r[s=-u].unsubscribe(),o+=2}else{const i=r[s=e[o+1]];e[o].call(i)}if(null!==r){for(let o=s+1;o<r.length;o++)r[o]();t[7]=null}}(n,t),1===t[1].type&&Un(t[11])&&t[11].destroy();const e=t[17];if(null!==e&&Yo(t[3])){e!==t[3]&&pR(e,t);const r=t[19];null!==r&&r.detachView(n)}}}function mR(n,t,e){return function gR(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[0];if(2&r.flags){const s=n.data[r.directiveStart].encapsulation;if(s===Ko.None||s===Ko.Emulated)return null}return Hs(r,e)}(n,t.parent,e)}function yu(n,t,e,r,s){Un(n)?n.insertBefore(t,e,r,s):t.insertBefore(e,r,s)}function yR(n,t,e){Un(n)?n.appendChild(t,e):t.appendChild(e)}function bR(n,t,e,r,s){null!==r?yu(n,t,e,r,s):yR(n,t,e)}function uy(n,t){return Un(n)?n.parentNode(t):t.parentNode}function _R(n,t,e){return wR(n,t,e)}let wR=function vR(n,t,e){return 40&n.type?Hs(n,e):null};function cy(n,t,e,r){const s=mR(n,r,t),o=t[11],a=_R(r.parent||t[6],r,t);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)bR(o,s,e[l],a,!1);else bR(o,s,e,a,!1)}function dy(n,t){if(null!==t){const e=t.type;if(3&e)return Hs(t,n);if(4&e)return Lx(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return dy(n,r);{const s=n[t.index];return Yo(s)?Lx(-1,s):ir(s)}}if(32&e)return Dx(t,n)()||ir(n[t.index]);{const r=SR(n,t);return null!==r?Array.isArray(r)?r[0]:dy(lp(n[16]),r):dy(n,t.next)}}return null}function SR(n,t){return null!==t?n[16][6].projection[t.projection]:null}function Lx(n,t){const e=10+n+1;if(e<t.length){const r=t[e],s=r[1].firstChild;if(null!==s)return dy(r,s)}return t[7]}function Bx(n,t,e,r,s,o,i){for(;null!=e;){const a=r[e.index],l=e.type;if(i&&0===t&&(a&&Zr(ir(a),r),e.flags|=4),64!=(64&e.flags))if(8&l)Bx(n,t,e.child,r,s,o,!1),Wc(t,n,s,a,o);else if(32&l){const u=Dx(e,r);let c;for(;c=u();)Wc(t,n,s,c,o);Wc(t,n,s,a,o)}else 16&l?TR(n,t,r,e,s,o):Wc(t,n,s,a,o);e=i?e.projectionNext:e.next}}function up(n,t,e,r,s,o){Bx(e,r,n.firstChild,t,s,o,!1)}function TR(n,t,e,r,s,o){const i=e[16],l=i[6].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)Wc(t,n,s,l[u],o);else Bx(n,t,l,i[3],s,o,!0)}function CR(n,t,e){Un(n)?n.setAttribute(t,"style",e):t.style.cssText=e}function zx(n,t,e){Un(n)?""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e):t.className=e}function Yx(n){return n.ngOriginalError}function pY(n,...t){n.error(...t)}class pp{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),r=function hY(n){return n&&n.ngErrorLogger||pY}(t);r(this._console,"ERROR",t),e&&r(this._console,"ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&Yx(t);for(;e&&Yx(e);)e=Yx(e);return e||null}}const vY=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(Qt))();function Ii(n){return n instanceof Function?n():n}function VR(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const o=t.length;if(s+o===r||n.charCodeAt(s+o)<=32)return s}e=s+1}}const BR="ng-template";function TY(n,t,e){let r=0;for(;r<n.length;){let s=n[r++];if(e&&"class"===s){if(s=n[r],-1!==VR(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<n.length&&"string"==typeof(s=n[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function zR(n){return 4===n.type&&n.value!==BR}function CY(n,t,e){return t===(4!==n.type||e?n.value:BR)}function EY(n,t,e){let r=4;const s=n.attrs||[],o=function NY(n){for(let t=0;t<n.length;t++)if(R2(n[t]))return t;return n.length}(s);let i=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!CY(n,l,e)||""===l&&1===t.length){if(Qo(r))return!1;i=!0}}else{const u=8&r?l:t[++a];if(8&r&&null!==n.attrs){if(!TY(n.attrs,u,e)){if(Qo(r))return!1;i=!0}continue}const d=IY(8&r?"class":l,s,zR(n),e);if(-1===d){if(Qo(r))return!1;i=!0;continue}if(""!==u){let h;h=d>o?"":s[d+1].toLowerCase();const p=8&r?h:null;if(p&&-1!==VR(p,u,0)||2&r&&u!==h){if(Qo(r))return!1;i=!0}}}}else{if(!i&&!Qo(r)&&!Qo(l))return!1;if(i&&Qo(l))continue;i=!1,r=l|1&r}}return Qo(r)||i}function Qo(n){return 0==(1&n)}function IY(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let o=!1;for(;s<t.length;){const i=t[s];if(i===n)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function DY(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function UR(n,t,e=!1){for(let r=0;r<t.length;r++)if(EY(n,t[r],e))return!0;return!1}function AY(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let s=0;s<n.length;s++)if(n[s]!==r[s])continue e;return!0}}return!1}function WR(n,t){return n?":not("+t.trim()+")":t}function RY(n){let t=n[0],e=1,r=2,s="",o=!1;for(;e<n.length;){let i=n[e];if("string"==typeof i)if(2&r){const a=n[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!Qo(i)&&(t+=WR(o,s),s=""),r=i,o=o||!Qo(r);e++}return""!==s&&(t+=WR(o,s)),t}const it={};function da(n){GR(Ft(),ue(),gs()+n,!1)}function GR(n,t,e,r){if(!r)if(3==(3&t[2])){const o=n.preOrderCheckHooks;null!==o&&Yg(t,o,e)}else{const o=n.preOrderHooks;null!==o&&Zg(t,o,0,e)}Za(e)}function gy(n,t){return n<<17|t<<2}function Jo(n){return n>>17&32767}function Zx(n){return 2|n}function ha(n){return(131068&n)>>2}function Qx(n,t){return-131069&n|t<<2}function Jx(n){return 1|n}function t$(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],o=e[r+1];if(-1!==o){const i=n.data[o];dx(s),i.contentQueries(2,t[o],o)}}}function fp(n,t,e,r,s,o,i,a,l,u){const c=t.blueprint.slice();return c[0]=s,c[2]=140|r,b2(c),c[3]=c[15]=n,c[8]=e,c[10]=i||n&&n[10],c[11]=a||n&&n[11],c[12]=l||n&&n[12]||null,c[9]=u||n&&n[9]||null,c[6]=o,c[16]=2==t.type?n[16]:c,c}function Hc(n,t,e,r,s){let o=n.data[t];if(null===o)o=function lS(n,t,e,r,s){const o=x2(),i=ax(),l=n.data[t]=function YY(n,t,e,r,s,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=l),null!==o&&(i?null==o.child&&null!==l.parent&&(o.child=l):null===o.next&&(o.next=l)),l}(n,t,e,r,s),function g9(){return ot.lFrame.inI18n}()&&(o.flags|=64);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function qh(){const n=ot.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return Ti(o,!0),o}function jc(n,t,e,r){if(0===e)return-1;const s=t.length;for(let o=0;o<e;o++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function mp(n,t,e){jg(t);try{const r=n.viewQuery;null!==r&&yS(1,r,e);const s=n.template;null!==s&&n$(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&t$(n,t),n.staticViewQueries&&yS(2,n.viewQuery,e);const o=n.components;null!==o&&function qY(n,t){for(let e=0;e<t.length;e++)fZ(n,t[e])}(t,o)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[2]&=-5,qg()}}function qc(n,t,e,r){const s=t[2];if(256!=(256&s)){jg(t);try{b2(t),function S2(n){return ot.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&n$(n,t,e,2,r);const i=3==(3&s);if(i){const u=n.preOrderCheckHooks;null!==u&&Yg(t,u,null)}else{const u=n.preOrderHooks;null!==u&&Zg(t,u,0,null),hx(t,0)}if(function hZ(n){for(let t=Ax(n);null!==t;t=Rx(t)){if(!t[2])continue;const e=t[9];for(let r=0;r<e.length;r++){const s=e[r],o=s[3];0==(1024&s[2])&&ix(o,1),s[2]|=1024}}}(t),function dZ(n){for(let t=Ax(n);null!==t;t=Rx(t))for(let e=10;e<t.length;e++){const r=t[e],s=r[1];ox(r)&&qc(s,r,s.template,r[8])}}(t),null!==n.contentQueries&&t$(n,t),i){const u=n.contentCheckHooks;null!==u&&Yg(t,u)}else{const u=n.contentHooks;null!==u&&Zg(t,u,1),hx(t,1)}!function HY(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)Za(~s);else{const o=s,i=e[++r],a=e[++r];y9(i,o),a(2,t[o])}}}finally{Za(-1)}}(n,t);const a=n.components;null!==a&&function jY(n,t){for(let e=0;e<t.length;e++)pZ(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&yS(2,l,r),i){const u=n.viewCheckHooks;null!==u&&Yg(t,u)}else{const u=n.viewHooks;null!==u&&Zg(t,u,2),hx(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[2]&=-73,1024&t[2]&&(t[2]&=-1025,ix(t[3],-1))}finally{qg()}}}function KY(n,t,e,r){const s=t[10],i=y2(t);try{!i&&s.begin&&s.begin(),i&&mp(n,t,r),qc(n,t,e,r)}finally{!i&&s.end&&s.end()}}function n$(n,t,e,r,s){const o=gs(),i=2&r;try{Za(-1),i&&t.length>20&&GR(n,t,20,!1),e(r,s)}finally{Za(o)}}function uS(n,t,e){!v2()||(function rZ(n,t,e,r){const s=e.directiveStart,o=e.directiveEnd;n.firstCreatePass||Yh(e,t),Zr(r,t);const i=e.initialInputs;for(let a=s;a<o;a++){const l=n.data[a],u=Zo(l);u&&lZ(t,e,l);const c=Zh(t,n,a,e);Zr(c,t),null!==i&&uZ(0,a-s,c,l,0,i),u&&(js(e.index,t)[8]=c)}}(n,t,e,Hs(e,t)),128==(128&e.flags)&&function sZ(n,t,e){const r=e.directiveStart,s=e.directiveEnd,i=e.index,a=function b9(){return ot.lFrame.currentDirectiveIndex}();try{Za(i);for(let l=r;l<s;l++){const u=n.data[l],c=t[l];ux(l),(null!==u.hostBindings||0!==u.hostVars||null!==u.hostAttrs)&&d$(u,c)}}finally{Za(-1),ux(a)}}(n,t,e))}function cS(n,t,e=Hs){const r=t.localNames;if(null!==r){let s=t.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(t,n):n[i];n[s++]=a}}}function s$(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=_y(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function _y(n,t,e,r,s,o,i,a,l,u){const c=20+r,d=c+s,h=function XY(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:it);return e}(c,d),p="function"==typeof u?u():u;return h[1]={type:n,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:t,data:h.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function a$(n,t,e,r){const s=y$(t);null===e?s.push(r):(s.push(e),n.firstCreatePass&&b$(n).push(r,s.length-1))}function l$(n,t,e){for(let r in n)if(n.hasOwnProperty(r)){const s=n[r];(e=null===e?{}:e).hasOwnProperty(r)?e[r].push(t,s):e[r]=[t,s]}return e}function dS(n,t,e,r){let s=!1;if(v2()){const o=function oZ(n,t,e){const r=n.directiveRegistry;let s=null;if(r)for(let o=0;o<r.length;o++){const i=r[o];UR(e,i.selectors,!1)&&(s||(s=[]),ny(Yh(e,t),n,i.type),Zo(i)?(h$(n,e),s.unshift(i)):s.push(i))}return s}(n,t,e),i=null===r?null:{"":-1};if(null!==o){s=!0,p$(e,n.data.length,o.length);for(let c=0;c<o.length;c++){const d=o[c];d.providersResolver&&d.providersResolver(d)}let a=!1,l=!1,u=jc(n,t,o.length,null);for(let c=0;c<o.length;c++){const d=o[c];e.mergedAttrs=Jg(e.mergedAttrs,d.hostAttrs),f$(n,e,t,u,d),aZ(u,d,i),null!==d.contentQueries&&(e.flags|=8),(null!==d.hostBindings||null!==d.hostAttrs||0!==d.hostVars)&&(e.flags|=128);const h=d.type.prototype;!a&&(h.ngOnChanges||h.ngOnInit||h.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),a=!0),!l&&(h.ngOnChanges||h.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),l=!0),u++}!function ZY(n,t){const r=t.directiveEnd,s=n.data,o=t.attrs,i=[];let a=null,l=null;for(let u=t.directiveStart;u<r;u++){const c=s[u],d=c.inputs,h=null===o||zR(t)?null:cZ(d,o);i.push(h),a=l$(d,u,a),l=l$(c.outputs,u,l)}null!==a&&(a.hasOwnProperty("class")&&(t.flags|=16),a.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=i,t.inputs=a,t.outputs=l}(n,e)}i&&function iZ(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const o=e[t[s+1]];if(null==o)throw new Oe(-301,!1);r.push(t[s],o)}}}(e,r,i)}return e.mergedAttrs=Jg(e.mergedAttrs,e.attrs),s}function c$(n,t,e,r,s,o){const i=o.hostBindings;if(i){let a=n.hostBindingOpCodes;null===a&&(a=n.hostBindingOpCodes=[]);const l=~t.index;(function nZ(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(a)!=l&&a.push(l),a.push(r,s,i)}}function d$(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function h$(n,t){t.flags|=2,(n.components||(n.components=[])).push(t.index)}function aZ(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;Zo(t)&&(e[""]=n)}}function p$(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}function f$(n,t,e,r,s){n.data[r]=s;const o=s.factory||(s.factory=mu(s.type)),i=new Kh(o,Zo(s),null);n.blueprint[r]=i,e[r]=i,c$(n,t,0,r,jc(n,e,s.hostVars,it),s)}function lZ(n,t,e){const r=Hs(t,n),s=s$(e),o=n[10],i=vy(n,fp(n,s,null,e.onPush?64:16,r,t,o,o.createRenderer(r,e),null,null));n[t.index]=i}function ki(n,t,e,r,s,o){const i=Hs(n,t);!function hS(n,t,e,r,s,o,i){if(null==o)Un(n)?n.removeAttribute(t,s,e):t.removeAttribute(s);else{const a=null==i?st(o):i(o,r||"",s);Un(n)?n.setAttribute(t,s,a,e):e?t.setAttributeNS(e,s,a):t.setAttribute(s,a)}}(t[11],i,o,n.value,e,r,s)}function uZ(n,t,e,r,s,o){const i=o[t];if(null!==i){const a=r.setInput;for(let l=0;l<i.length;){const u=i[l++],c=i[l++],d=i[l++];null!==a?r.setInput(e,d,u,c):e[c]=d}}}function cZ(n,t){let e=null,r=0;for(;r<t.length;){const s=t[r];if(0!==s)if(5!==s){if("number"==typeof s)break;n.hasOwnProperty(s)&&(null===e&&(e=[]),e.push(s,n[s],t[r+1])),r+=2}else r+=2;else r+=4}return e}function m$(n,t,e,r){return new Array(n,!0,!1,t,null,0,r,e,null,null)}function pZ(n,t){const e=js(t,n);if(ox(e)){const r=e[1];80&e[2]?qc(r,e,r.template,e[8]):e[5]>0&&pS(e)}}function pS(n){for(let r=Ax(n);null!==r;r=Rx(r))for(let s=10;s<r.length;s++){const o=r[s];if(1024&o[2]){const i=o[1];qc(i,o,i.template,o[8])}else o[5]>0&&pS(o)}const e=n[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=js(e[r],n);ox(s)&&s[5]>0&&pS(s)}}function fZ(n,t){const e=js(t,n),r=e[1];(function mZ(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])})(r,e),mp(r,e,e[8])}function vy(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function fS(n){for(;n;){n[2]|=64;const t=lp(n);if(K7(n)&&!t)return n;n=t}return null}function g$(n){!function mS(n){for(let t=0;t<n.components.length;t++){const e=n.components[t],r=kx(e),s=r[1];KY(s,r,s.template,e)}}(n[8])}function yS(n,t,e){dx(0),t(n,e)}const yZ=(()=>Promise.resolve(null))();function y$(n){return n[7]||(n[7]=[])}function b$(n){return n.cleanup||(n.cleanup=[])}function v$(n,t){const e=n[9],r=e?e.get(pp,null):null;r&&r.handleError(t)}function w$(n,t,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++],l=t[i],u=n.data[i];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function pa(n,t,e){const r=Gg(t,n);!function hR(n,t,e){Un(n)?n.setValue(t,e):t.textContent=e}(n[11],r,e)}function wy(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,o=0;if(null!==t)for(let i=0;i<t.length;i++){const a=t[i];"number"==typeof a?o=a:1==o?s=z0(s,a):2==o&&(r=z0(r,a+": "+t[++i]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}const bS=new Qe("INJECTOR",-1);class x${get(t,e=np){if(e===np){const r=new Error(`NullInjectorError: No provider for ${qt(t)}!`);throw r.name="NullInjectorError",r}return e}}const _S=new Qe("Set Injector scope."),gp={},vZ={};let vS;function S$(){return void 0===vS&&(vS=new x$),vS}function T$(n,t=null,e=null,r){const s=C$(n,t,e,r);return s._resolveInjectorDefTypes(),s}function C$(n,t=null,e=null,r){return new wZ(n,e,t||S$(),r)}class wZ{constructor(t,e,r,s=null){this.parent=r,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const o=[];e&&Ci(e,a=>this.processProvider(a,t,e)),Ci([t],a=>this.processInjectorType(a,[],o)),this.records.set(bS,Kc(void 0,this));const i=this.records.get(_S);this.scope=null!=i?i.value:null,this.source=s||("object"==typeof t?null:qt(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=np,r=et.Default){this.assertNotDestroyed();const s=Y2(this),o=qa(void 0);try{if(!(r&et.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function NZ(n){return"function"==typeof n||"object"==typeof n&&n instanceof Qe}(t)&&G0(t);a=l&&this.injectableDefInScope(l)?Kc(wS(t),gp):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&et.Self?S$():this.parent).get(t,e=r&et.Optional&&e===np?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[iy]=i[iy]||[]).unshift(qt(t)),s)throw i;return function nX(n,t,e,r){const s=n[iy];throw t[X2]&&s.unshift(t[X2]),n.message=function rX(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.substr(2):n;let s=qt(t);if(Array.isArray(t))s=t.map(qt).join(" -> ");else if("object"==typeof t){let o=[];for(let i in t)if(t.hasOwnProperty(i)){let a=t[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):qt(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace(Z9,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[iy]=null,n}(i,t,"R3InjectorError",this.source)}throw i}finally{qa(o),Y2(s)}}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((r,s)=>t.push(qt(s))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Oe(205,!1)}processInjectorType(t,e,r){if(!(t=pt(t)))return!1;let s=r2(t);const o=null==s&&t.ngModule||void 0,i=void 0===o?t:o,a=-1!==r.indexOf(i);if(void 0!==o&&(s=r2(o)),null==s)return!1;if(null!=s.imports&&!a){let c;r.push(i);try{Ci(s.imports,d=>{this.processInjectorType(d,e,r)&&(void 0===c&&(c=[]),c.push(d))})}finally{}if(void 0!==c)for(let d=0;d<c.length;d++){const{ngModule:h,providers:p}=c[d];Ci(p,f=>this.processProvider(f,h,p||nn))}}this.injectorDefTypes.add(i);const l=mu(i)||(()=>new i);this.records.set(i,Kc(l,gp));const u=s.providers;if(null!=u&&!a){const c=t;Ci(u,d=>this.processProvider(d,c,u))}return void 0!==o&&void 0!==t.providers}processProvider(t,e,r){let s=Xc(t=pt(t))?t:pt(t&&t.provide);const o=function SZ(n,t,e){return I$(n)?Kc(void 0,n.useValue):Kc(function E$(n,t,e){let r;if(Xc(n)){const s=pt(n);return mu(s)||wS(s)}if(I$(n))r=()=>pt(n.useValue);else if(function CZ(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...Cx(n.deps||[]));else if(function TZ(n){return!(!n||!n.useExisting)}(n))r=()=>Ce(pt(n.useExisting));else{const s=pt(n&&(n.useClass||n.provide));if(!function IZ(n){return!!n.deps}(n))return mu(s)||wS(s);r=()=>new s(...Cx(n.deps))}return r}(n),gp)}(t);if(Xc(t)||!0!==t.multi)this.records.get(s);else{let i=this.records.get(s);i||(i=Kc(void 0,gp,!0),i.factory=()=>Cx(i.multi),this.records.set(s,i)),s=t,i.multi.push(t)}this.records.set(s,o)}hydrate(t,e){return e.value===gp&&(e.value=vZ,e.value=e.factory()),"object"==typeof e.value&&e.value&&function kZ(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=pt(t.providedIn);return"string"==typeof e?"any"===e||e===this.scope:this.injectorDefTypes.has(e)}}function wS(n){const t=G0(n),e=null!==t?t.factory:mu(n);if(null!==e)return e;if(n instanceof Qe)throw new Oe(204,!1);if(n instanceof Function)return function xZ(n){const t=n.length;if(t>0)throw tp(t,"?"),new Oe(204,!1);const e=function F7(n){const t=n&&(n[Pg]||n[s2]);if(t){const e=function M7(n){if(n.hasOwnProperty("name"))return n.name;const t=(""+n).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),t}return null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new Oe(204,!1)}function Kc(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function I$(n){return null!==n&&"object"==typeof n&&J9 in n}function Xc(n){return"function"==typeof n}let Ys=(()=>{class n{static create(e,r){var s;if(Array.isArray(e))return T$({name:""},r,e,"");{const o=null!==(s=e.name)&&void 0!==s?s:"";return T$({name:o},e.parent,e.providers,o)}}}return n.THROW_IF_NOT_FOUND=np,n.NULL=new x$,n.\u0275prov=lt({token:n,providedIn:"any",factory:()=>Ce(bS)}),n.__NG_ELEMENT_ID__=-1,n})();function PZ(n,t){Xg(kx(n)[1],mr())}function xy(n){let t=function V$(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(Zo(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Oe(903,"");s=t.\u0275dir}if(s){if(e){r.push(s);const i=n;i.inputs=TS(n.inputs),i.declaredInputs=TS(n.declaredInputs),i.outputs=TS(n.outputs);const a=s.hostBindings;a&&zZ(n,a);const l=s.viewQuery,u=s.contentQueries;if(l&&VZ(n,l),u&&BZ(n,u),B0(n.inputs,s.inputs),B0(n.declaredInputs,s.declaredInputs),B0(n.outputs,s.outputs),Zo(s)&&s.data.animation){const c=n.data;c.animation=(c.animation||[]).concat(s.data.animation)}}const o=s.features;if(o)for(let i=0;i<o.length;i++){const a=o[i];a&&a.ngInherit&&a(n),a===xy&&(e=!1)}}t=Object.getPrototypeOf(t)}!function LZ(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=Jg(s.hostAttrs,e=Jg(e,s.hostAttrs))}}(r)}function TS(n){return n===Ic?{}:n===nn?[]:n}function VZ(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function BZ(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,o)=>{t(r,s,o),e(r,s,o)}:t}function zZ(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}let Sy=null;function Yc(){if(!Sy){const n=Qt.Symbol;if(n&&n.iterator)Sy=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const r=t[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(Sy=r)}}}return Sy}function yp(n){return!!function CS(n){return null!==n&&("function"==typeof n||"object"==typeof n)}(n)&&(Array.isArray(n)||!(n instanceof Map)&&Yc()in n)}function Qr(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function rl(n,t,e,r){const s=ue();return Qr(s,$c(),t)&&(Ft(),ki(Mn(),s,n,t,e,r)),rl}function vu(n,t,e,r,s,o,i,a){const l=ue(),u=Ft(),c=n+20,d=u.firstCreatePass?function KZ(n,t,e,r,s,o,i,a,l){const u=t.consts,c=Hc(t,n,4,i||null,Ya(u,a));dS(t,e,c,Ya(u,l)),Xg(t,c);const d=c.tViews=_y(2,c,r,s,o,t.directiveRegistry,t.pipeRegistry,null,t.schemas,u);return null!==t.queries&&(t.queries.template(t,c),d.queries=t.queries.embeddedTView(c)),c}(c,u,l,t,e,r,s,o,i):u.data[c];Ti(d,!1);const h=l[11].createComment("");cy(u,l,h,d),Zr(h,l),vy(l,l[c]=m$(h,l,h,d)),Wg(d)&&uS(u,l,d),null!=i&&cS(l,d,a)}function Cy(n){return Rc(function m9(){return ot.lFrame.contextLView}(),20+n)}function De(n,t=et.Default){const e=ue();return null===e?Ce(n,t):V2(mr(),e,pt(n),t)}function DS(){throw new Error("invalid")}function fa(n,t,e){const r=ue();return Qr(r,$c(),t)&&function Xs(n,t,e,r,s,o,i,a){const l=Hs(t,e);let c,u=t.inputs;!a&&null!=u&&(c=u[r])?(w$(n,e,c,r,s),Ug(t)&&function JY(n,t){const e=js(t,n);16&e[2]||(e[2]|=64)}(e,t.index)):3&t.type&&(r=function QY(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=i?i(s,t.value||"",r):s,Un(o)?o.setProperty(l,r,s):fx(r)||(l.setProperty?l.setProperty(r,s):l[r]=s))}(Ft(),Mn(),r,n,t,r[11],e,!1),fa}function AS(n,t,e,r,s){const i=s?"class":"style";w$(n,e,t.inputs[i],i,r)}function ti(n,t,e,r){const s=ue(),o=Ft(),i=20+n,a=s[11],l=s[i]=Ox(a,t,function C9(){return ot.lFrame.currentNamespace}()),u=o.firstCreatePass?function mQ(n,t,e,r,s,o,i){const a=t.consts,u=Hc(t,n,2,s,Ya(a,o));return dS(t,e,u,Ya(a,i)),null!==u.attrs&&wy(u,u.attrs,!1),null!==u.mergedAttrs&&wy(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(i,o,s,0,t,e,r):o.data[i];Ti(u,!0);const c=u.mergedAttrs;null!==c&&Qg(a,l,c);const d=u.classes;null!==d&&zx(a,l,d);const h=u.styles;return null!==h&&CR(a,l,h),64!=(64&u.flags)&&cy(o,s,l,u),0===function c9(){return ot.lFrame.elementDepthCount}()&&Zr(l,s),function d9(){ot.lFrame.elementDepthCount++}(),Wg(u)&&(uS(o,s,u),function r$(n,t,e){if(Z0(t)){const s=t.directiveEnd;for(let o=t.directiveStart;o<s;o++){const i=n.data[o];i.contentQueries&&i.contentQueries(1,e[o],o)}}}(o,u,s)),null!==r&&cS(s,u),ti}function ni(){let n=mr();ax()?lx():(n=n.parent,Ti(n,!1));const t=n;!function h9(){ot.lFrame.elementDepthCount--}();const e=Ft();return e.firstCreatePass&&(Xg(e,n),Z0(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function D9(n){return 0!=(16&n.flags)}(t)&&AS(e,t,ue(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function A9(n){return 0!=(32&n.flags)}(t)&&AS(e,t,ue(),t.stylesWithoutHost,!1),ni}function ma(n,t,e,r){return ti(n,t,e,r),ni(),ma}function Iy(n){return!!n&&"function"==typeof n.then}const lO=function aO(n){return!!n&&"function"==typeof n.subscribe};function _p(n,t,e,r){const s=ue(),o=Ft(),i=mr();return function cO(n,t,e,r,s,o,i,a){const l=Wg(r),c=n.firstCreatePass&&b$(n),d=t[8],h=y$(t);let p=!0;if(3&r.type||a){const g=Hs(r,t),y=a?a(g):g,b=h.length,_=a?v=>a(ir(v[r.index])):r.index;if(Un(e)){let v=null;if(!a&&l&&(v=function yQ(n,t,e,r){const s=n.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=t[7],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(n,t,s,r.index)),null!==v)(v.__ngLastListenerFn__||v).__ngNextListenerFn__=o,v.__ngLastListenerFn__=o,p=!1;else{o=OS(r,t,d,o,!1);const w=e.listen(y,s,o);h.push(o,w),c&&c.push(s,_,b,b+1)}}else o=OS(r,t,d,o,!0),y.addEventListener(s,o,i),h.push(o),c&&c.push(s,_,b,i)}else o=OS(r,t,d,o,!1);const f=r.outputs;let m;if(p&&null!==f&&(m=f[s])){const g=m.length;if(g)for(let y=0;y<g;y+=2){const S=t[m[y]][m[y+1]].subscribe(o),T=h.length;h.push(o,S),c&&c.push(s,r.index,T,-(T+1))}}}(o,s,s[11],i,n,t,!!e,r),_p}function dO(n,t,e,r){try{return!1!==e(r)}catch(s){return v$(n,s),!1}}function OS(n,t,e,r,s){return function o(i){if(i===Function)return r;const a=2&n.flags?js(n.index,t):t;0==(32&t[2])&&fS(a);let l=dO(t,0,r,i),u=o.__ngNextListenerFn__;for(;u;)l=dO(t,0,u,i)&&l,u=u.__ngNextListenerFn__;return s&&!1===l&&(i.preventDefault(),i.returnValue=!1),l}}function ad(n=1){return function v9(n){return(ot.lFrame.contextLView=function w9(n,t){for(;n>0;)t=t[15],n--;return t}(n,ot.lFrame.contextLView))[8]}(n)}function bQ(n,t){let e=null;const r=function kY(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(0==(1&e))return t[e+1]}return null}(n);for(let s=0;s<t.length;s++){const o=t[s];if("*"!==o){if(null===r?UR(n,o,!0):AY(r,o))return s}else e=s}return e}function SO(n,t,e,r,s){const o=n[e+1],i=null===t;let a=r?Jo(o):ha(o),l=!1;for(;0!==a&&(!1===l||i);){const c=n[a+1];wQ(n[a],t)&&(l=!0,n[a+1]=r?Jx(c):Zx(c)),a=r?Jo(c):ha(c)}l&&(n[e+1]=r?Zx(o):Jx(o))}function wQ(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&zc(n,t)>=0}function ud(n,t,e){return ri(n,t,e,!1),ud}function cd(n,t){return ri(n,t,null,!0),cd}function ri(n,t,e,r){const s=ue(),o=Ft(),i=function ca(n){const t=ot.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}(2);o.firstUpdatePass&&function AO(n,t,e,r){const s=n.data;if(null===s[e+1]){const o=s[gs()],i=function DO(n,t){return t>=n.expandoStartIndex}(n,e);(function FO(n,t){return 0!=(n.flags&(t?16:32))})(o,r)&&null===t&&!i&&(t=!1),t=function DQ(n,t,e,r){const s=function cx(n){const t=ot.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let o=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=vp(e=MS(null,n,t,e,r),t.attrs,r),o=null);else{const i=t.directiveStylingLast;if(-1===i||n[i]!==s)if(e=MS(s,n,t,e,r),null===o){let l=function AQ(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==ha(r))return n[Jo(r)]}(n,t,r);void 0!==l&&Array.isArray(l)&&(l=MS(null,n,t,l[1],r),l=vp(l,t.attrs,r),function RQ(n,t,e,r){n[Jo(e?t.classBindings:t.styleBindings)]=r}(n,t,r,l))}else o=function $Q(n,t,e){let r;const s=t.directiveEnd;for(let o=1+t.directiveStylingLast;o<s;o++)r=vp(r,n[o].hostAttrs,e);return vp(r,t.attrs,e)}(n,t,r)}return void 0!==o&&(r?t.residualClasses=o:t.residualStyles=o),e}(s,o,t,r),function _Q(n,t,e,r,s,o){let i=o?t.classBindings:t.styleBindings,a=Jo(i),l=ha(i);n[r]=e;let c,u=!1;if(Array.isArray(e)){const d=e;c=d[1],(null===c||zc(d,c)>0)&&(u=!0)}else c=e;if(s)if(0!==l){const h=Jo(n[a+1]);n[r+1]=gy(h,a),0!==h&&(n[h+1]=Qx(n[h+1],r)),n[a+1]=function FY(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=gy(a,0),0!==a&&(n[a+1]=Qx(n[a+1],r)),a=r;else n[r+1]=gy(l,0),0===a?a=r:n[l+1]=Qx(n[l+1],r),l=r;u&&(n[r+1]=Zx(n[r+1])),SO(n,c,r,!0),SO(n,c,r,!1),function vQ(n,t,e,r,s){const o=s?n.residualClasses:n.residualStyles;null!=o&&"string"==typeof t&&zc(o,t)>=0&&(e[r+1]=Jx(e[r+1]))}(t,c,n,r,o),i=gy(a,l),o?t.classBindings=i:t.styleBindings=i}(s,o,t,e,i,r)}}(o,n,i,r),t!==it&&Qr(s,i,t)&&function $O(n,t,e,r,s,o,i,a){if(!(3&t.type))return;const l=n.data,u=l[a+1];ky(function qR(n){return 1==(1&n)}(u)?OO(l,t,e,s,ha(u),i):void 0)||(ky(o)||function jR(n){return 2==(2&n)}(u)&&(o=OO(l,null,e,s,a,i)),function MX(n,t,e,r,s){const o=Un(n);if(t)s?o?n.addClass(e,r):e.classList.add(r):o?n.removeClass(e,r):e.classList.remove(r);else{let i=-1===r.indexOf("-")?void 0:Ks.DashCase;if(null==s)o?n.removeStyle(e,r,i):e.style.removeProperty(r);else{const a="string"==typeof s&&s.endsWith("!important");a&&(s=s.slice(0,-10),i|=Ks.Important),o?n.setStyle(e,r,s,i):e.style.setProperty(r,s,a?"important":"")}}}(r,i,Gg(gs(),e),s,o))}(o,o.data[gs()],s,s[11],n,s[i+1]=function MQ(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=qt(function el(n){return n instanceof class NR{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}?n.changingThisBreaksApplicationSecurity:n}(n)))),n}(t,e),r,i)}function MS(n,t,e,r,s){let o=null;const i=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<i&&(o=t[a],r=vp(r,o.hostAttrs,s),o!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function vp(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let o=0;o<t.length;o++){const i=t[o];"number"==typeof i?s=i:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),qs(n,i,!!e||t[++o]))}return void 0===n?null:n}function OO(n,t,e,r,s,o){const i=null===t;let a;for(;s>0;){const l=n[s],u=Array.isArray(l),c=u?l[1]:l,d=null===c;let h=e[s+1];h===it&&(h=d?nn:void 0);let p=d?wx(h,r):c===r?h:void 0;if(u&&!ky(p)&&(p=wx(l,r)),ky(p)&&(a=p,i))return a;const f=n[s+1];s=i?Jo(f):ha(f)}if(null!==t){let l=o?t.residualClasses:t.residualStyles;null!=l&&(a=wx(l,r))}return a}function ky(n){return void 0!==n}function Ny(n,t=""){const e=ue(),r=Ft(),s=n+20,o=r.firstCreatePass?Hc(r,s,1,t,null):r.data[s],i=e[s]=function $x(n,t){return Un(n)?n.createText(t):n.createTextNode(t)}(e[11],t);cy(r,e,i,o),Ti(o,!1)}function Dy(n){return PS("",n,""),Dy}function PS(n,t,e){const r=ue(),s=function Qc(n,t,e,r){return Qr(n,$c(),e)?t+st(e)+r:it}(r,n,t,e);return s!==it&&pa(r,gs(),s),PS}const wu=void 0;var nJ=["en",[["a","p"],["AM","PM"],wu],[["AM","PM"],wu,wu],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],wu,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],wu,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",wu,"{1} 'at' {0}",wu],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function tJ(n){const e=Math.floor(Math.abs(n)),r=n.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===r?1:5}];let dd={};function bs(n){const t=function rJ(n){return n.toLowerCase().replace(/_/g,"-")}(n);let e=nF(t);if(e)return e;const r=t.split("-")[0];if(e=nF(r),e)return e;if("en"===r)return nJ;throw new Error(`Missing locale data for the locale "${n}".`)}function nF(n){return n in dd||(dd[n]=Qt.ng&&Qt.ng.common&&Qt.ng.common.locales&&Qt.ng.common.locales[n]),dd[n]}var ke=(()=>((ke=ke||{})[ke.LocaleId=0]="LocaleId",ke[ke.DayPeriodsFormat=1]="DayPeriodsFormat",ke[ke.DayPeriodsStandalone=2]="DayPeriodsStandalone",ke[ke.DaysFormat=3]="DaysFormat",ke[ke.DaysStandalone=4]="DaysStandalone",ke[ke.MonthsFormat=5]="MonthsFormat",ke[ke.MonthsStandalone=6]="MonthsStandalone",ke[ke.Eras=7]="Eras",ke[ke.FirstDayOfWeek=8]="FirstDayOfWeek",ke[ke.WeekendRange=9]="WeekendRange",ke[ke.DateFormat=10]="DateFormat",ke[ke.TimeFormat=11]="TimeFormat",ke[ke.DateTimeFormat=12]="DateTimeFormat",ke[ke.NumberSymbols=13]="NumberSymbols",ke[ke.NumberFormats=14]="NumberFormats",ke[ke.CurrencyCode=15]="CurrencyCode",ke[ke.CurrencySymbol=16]="CurrencySymbol",ke[ke.CurrencyName=17]="CurrencyName",ke[ke.Currencies=18]="Currencies",ke[ke.Directionality=19]="Directionality",ke[ke.PluralCase=20]="PluralCase",ke[ke.ExtraData=21]="ExtraData",ke))();const Ay="en-US";let rF=Ay;class kF{}class oee{resolveComponentFactory(t){throw function see(n){const t=Error(`No component factory found for ${qt(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let Cp=(()=>{class n{}return n.NULL=new oee,n})();function iee(){return pd(mr(),ue())}function pd(n,t){return new So(Hs(n,t))}let So=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=iee,n})();function aee(n){return n instanceof So?n.nativeElement:n}class Ep{}let cee=(()=>{class n{}return n.\u0275prov=lt({token:n,providedIn:"root",factory:()=>null}),n})();class fd{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const dee=new fd("13.3.12"),GS={};function Py(n,t,e,r,s=!1){for(;null!==e;){const o=t[e.index];if(null!==o&&r.push(ir(o)),Yo(o))for(let a=10;a<o.length;a++){const l=o[a],u=l[1].firstChild;null!==u&&Py(l[1],l,u,r)}const i=e.type;if(8&i)Py(n,t,e.child,r);else if(32&i){const a=Dx(e,t);let l;for(;l=a();)r.push(l)}else if(16&i){const a=SR(t,e);if(Array.isArray(a))r.push(...a);else{const l=lp(t[16]);Py(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Ip{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Py(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Yo(t)){const e=t[8],r=e?e.indexOf(this):-1;r>-1&&(Fx(t,r),sy(e,r))}this._attachedToViewContainer=!1}fR(this._lView[1],this._lView)}onDestroy(t){a$(this._lView[1],this._lView,null,t)}markForCheck(){fS(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){!function gS(n,t,e){const r=t[10];r.begin&&r.begin();try{qc(n,t,n.template,e)}catch(s){throw v$(t,s),s}finally{r.end&&r.end()}}(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Oe(902,"");this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function EX(n,t){up(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Oe(902,"");this._appRef=t}}class hee extends Ip{constructor(t){super(t),this._view=t}detectChanges(){g$(this._view)}checkNoChanges(){}get context(){return null}}class DF extends Cp{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Vr(t);return new HS(e,this.ngModule)}}function AF(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class HS extends kF{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function $Y(n){return n.map(RY).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return AF(this.componentDef.inputs)}get outputs(){return AF(this.componentDef.outputs)}create(t,e,r,s){const o=(s=s||this.ngModule)?function fee(n,t){return{get:(e,r,s)=>{const o=n.get(e,GS,s);return o!==GS||r===GS?o:t.get(e,r,s)}}}(t,s.injector):t,i=o.get(Ep,g2),a=o.get(cee,null),l=i.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",c=r?function i$(n,t,e){if(Un(n))return n.selectRootElement(t,e===Ko.ShadowDom);let r="string"==typeof t?n.querySelector(t):t;return r.textContent="",r}(l,r,this.componentDef.encapsulation):Ox(i.createRenderer(null,this.componentDef),u,function pee(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(u)),d=this.componentDef.onPush?576:528,h=function L$(n,t){return{components:[],scheduler:n||vY,clean:yZ,playerHandler:t||null,flags:0}}(),p=_y(0,null,null,1,0,null,null,null,null,null),f=fp(null,p,h,d,null,null,i,l,a,o);let m,g;jg(f);try{const y=function M$(n,t,e,r,s,o){const i=e[1];e[20]=n;const l=Hc(i,20,2,"#host",null),u=l.mergedAttrs=t.hostAttrs;null!==u&&(wy(l,u,!0),null!==n&&(Qg(s,n,u),null!==l.classes&&zx(s,n,l.classes),null!==l.styles&&CR(s,n,l.styles)));const c=r.createRenderer(n,t),d=fp(e,s$(t),null,t.onPush?64:16,e[20],l,r,c,o||null,null);return i.firstCreatePass&&(ny(Yh(l,e),i,t.type),h$(i,l),p$(l,e.length,1)),vy(e,d),e[20]=d}(c,this.componentDef,f,i,l);if(c)if(r)Qg(l,c,["ng-version",dee.full]);else{const{attrs:b,classes:_}=function OY(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let o=n[r];if("string"==typeof o)2===s?""!==o&&t.push(o,n[++r]):8===s&&e.push(o);else{if(!Qo(s))break;s=o}r++}return{attrs:t,classes:e}}(this.componentDef.selectors[0]);b&&Qg(l,c,b),_&&_.length>0&&zx(l,c,_.join(" "))}if(g=sx(p,20),void 0!==e){const b=g.projection=[];for(let _=0;_<this.ngContentSelectors.length;_++){const v=e[_];b.push(null!=v?Array.from(v):null)}}m=function P$(n,t,e,r,s){const o=e[1],i=function tZ(n,t,e){const r=mr();n.firstCreatePass&&(e.providersResolver&&e.providersResolver(e),f$(n,r,t,jc(n,t,1,null),e));const s=Zh(t,n,r.directiveStart,r);Zr(s,t);const o=Hs(r,t);return o&&Zr(o,t),s}(o,e,t);if(r.components.push(i),n[8]=i,s&&s.forEach(l=>l(i,t)),t.contentQueries){const l=mr();t.contentQueries(1,i,l.directiveStart)}const a=mr();return!o.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(Za(a.index),c$(e[1],a,0,a.directiveStart,a.directiveEnd,t),d$(t,i)),i}(y,this.componentDef,f,h,[PZ]),mp(p,f,null)}finally{qg()}return new gee(this.componentType,m,pd(g,f),f,g)}}class gee extends class ree{}{constructor(t,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=e,this.hostView=this.changeDetectorRef=new hee(s),this.componentType=t}get injector(){return new Mc(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}class ga{}class RF{}const md=new Map;class FF extends ga{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new DF(this);const r=bo(t);this._bootstrapComponents=Ii(r.bootstrap),this._r3Injector=C$(t,e,[{provide:ga,useValue:this},{provide:Cp,useValue:this.componentFactoryResolver}],qt(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Ys.THROW_IF_NOT_FOUND,r=et.Default){return t===Ys||t===ga||t===bS?this:this._r3Injector.get(t,e,r)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class jS extends RF{constructor(t){super(),this.moduleType=t,null!==bo(t)&&function bee(n){const t=new Set;!function e(r){const s=bo(r,!0),o=s.id;null!==o&&(function $F(n,t,e){if(t&&t!==e)throw new Error(`Duplicate module registered for ${n} - ${qt(t)} vs ${qt(t.name)}`)}(o,md.get(o),r),md.set(o,r));const i=Ii(s.imports);for(const a of i)t.has(a)||(t.add(a),e(a))}(n)}(t)}create(t){return new FF(this.moduleType,t)}}function MF(n,t,e,r,s,o){const i=t+e;return Qr(n,i,s)?function Ni(n,t,e){return n[t]=e}(n,i+1,o?r.call(o,s):r(s)):function kp(n,t){const e=n[t];return e===it?void 0:e}(n,i+1)}function qS(n,t){const e=Ft();let r;const s=n+20;e.firstCreatePass?(r=function Nee(n,t){if(t)for(let e=t.length-1;e>=0;e--){const r=t[e];if(n===r.name)return r}}(t,e.pipeRegistry),e.data[s]=r,r.onDestroy&&(e.destroyHooks||(e.destroyHooks=[])).push(s,r.onDestroy)):r=e.data[s];const o=r.factory||(r.factory=mu(r.type)),i=qa(De);try{const a=ey(!1),l=o();return ey(a),function XZ(n,t,e,r){e>=n.data.length&&(n.data[e]=null,n.blueprint[e]=null),t[e]=r}(e,ue(),s,l),l}finally{qa(i)}}function KS(n,t,e){const r=n+20,s=ue(),o=Rc(s,r);return function Np(n,t){return n[1].data[t].pure}(s,r)?MF(s,function ms(){const n=ot.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}(),t,o.transform,e,o):o.transform(e)}function XS(n){return t=>{setTimeout(n,void 0,t)}}const _s=class Oee extends go{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){var s,o,i;let a=t,l=e||(()=>null),u=r;if(t&&"object"==typeof t){const d=t;a=null===(s=d.next)||void 0===s?void 0:s.bind(d),l=null===(o=d.error)||void 0===o?void 0:o.bind(d),u=null===(i=d.complete)||void 0===i?void 0:i.bind(d)}this.__isAsync&&(l=XS(l),a&&(a=XS(a)),u&&(u=XS(u)));const c=super.subscribe({next:a,error:l,complete:u});return t instanceof hs&&t.add(c),c}};function Fee(){return this._results[Yc()]()}class YS{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Yc(),r=YS.prototype;r[e]||(r[e]=Fee)}get changes(){return this._changes||(this._changes=new _s)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=wo(t);(this._changesDetected=!function U9(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],o=t[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}Symbol;let ya=(()=>{class n{}return n.__NG_ELEMENT_ID__=Lee,n})();const Mee=ya,Pee=class extends Mee{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(t){const e=this._declarationTContainer.tViews,r=fp(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);r[17]=this._declarationLView[this._declarationTContainer.index];const o=this._declarationLView[19];return null!==o&&(r[19]=o.createEmbeddedView(e)),mp(e,r,t),new Ip(r)}};function Lee(){return Ly(mr(),ue())}function Ly(n,t){return 4&n.type?new Pee(t,n,pd(n,t)):null}let oi=(()=>{class n{}return n.__NG_ELEMENT_ID__=Vee,n})();function Vee(){return WF(mr(),ue())}const Bee=oi,zF=class extends Bee{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return pd(this._hostTNode,this._hostLView)}get injector(){return new Mc(this._hostTNode,this._hostLView)}get parentInjector(){const t=ty(this._hostTNode,this._hostLView);if(O2(t)){const e=Fc(t,this._hostLView),r=Oc(t);return new Mc(e[1].data[r+8],e)}return new Mc(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=UF(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,r){const s=t.createEmbeddedView(e||{});return this.insert(s,r),s}createComponent(t,e,r,s,o){const i=t&&!function ep(n){return"function"==typeof n}(t);let a;if(i)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,o=d.ngModuleRef}const l=i?t:new HS(Vr(t)),u=r||this.parentInjector;if(!o&&null==l.ngModule){const h=(i?u:this.parentInjector).get(ga,null);h&&(o=h)}const c=l.create(u,s,void 0,o);return this.insert(c.hostView,a),c}insert(t,e){const r=t._lView,s=r[1];if(function u9(n){return Yo(n[3])}(r)){const c=this.indexOf(t);if(-1!==c)this.detach(c);else{const d=r[3],h=new zF(d,d[6],d[3]);h.detach(h.indexOf(t))}}const o=this._adjustIndex(e),i=this._lContainer;!function kX(n,t,e,r){const s=10+r,o=e.length;r>0&&(e[s-1][4]=t),r<o-10?(t[4]=e[s],G2(e,10+r,t)):(e.push(t),t[4]=null),t[3]=e;const i=t[17];null!==i&&e!==i&&function NX(n,t){const e=n[9];t[16]!==t[3][3][16]&&(n[2]=!0),null===e?n[9]=[t]:e.push(t)}(i,t);const a=t[19];null!==a&&a.insertView(n),t[2]|=128}(s,r,i,o);const a=Lx(o,i),l=r[11],u=uy(l,i[7]);return null!==u&&function CX(n,t,e,r,s,o){r[0]=s,r[6]=t,up(n,r,e,1,s,o)}(s,i[6],l,r,u,a),t.attachToViewContainerRef(),G2(ZS(i),o,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=UF(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=Fx(this._lContainer,e);r&&(sy(ZS(this._lContainer),e),fR(r[1],r))}detach(t){const e=this._adjustIndex(t,-1),r=Fx(this._lContainer,e);return r&&null!=sy(ZS(this._lContainer),e)?new Ip(r):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function UF(n){return n[8]}function ZS(n){return n[8]||(n[8]=[])}function WF(n,t){let e;const r=t[n.index];if(Yo(r))e=r;else{let s;if(8&n.type)s=ir(r);else{const o=t[11];s=o.createComment("");const i=Hs(n,t);yu(o,uy(o,i),s,function $X(n,t){return Un(n)?n.nextSibling(t):t.nextSibling}(o,i),!1)}t[n.index]=e=m$(r,t,s,n),vy(t,e)}return new zF(e,n,t)}class QS{constructor(t){this.queryList=t,this.matches=null}clone(){return new QS(this.queryList)}setDirty(){this.queryList.setDirty()}}class JS{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new JS(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==KF(t,e).matches&&this.queries[e].setDirty()}}class GF{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class eT{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(t,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new eT(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class tT{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new tT(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(t,e,Wee(e,o)),this.matchTNodeWithReadOption(t,e,ry(e,t,o,!1,!1))}else r===ya?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,ry(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===So||s===oi||s===ya&&4&e.type)this.addMatch(e.index,-2);else{const o=ry(e,t,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function Wee(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function Hee(n,t,e,r){return-1===e?function Gee(n,t){return 11&n.type?pd(n,t):4&n.type?Ly(n,t):null}(t,n):-2===e?function jee(n,t,e){return e===So?pd(t,n):e===ya?Ly(t,n):e===oi?WF(t,n):void 0}(n,t,r):Zh(n,n[1],e,t)}function HF(n,t,e,r){const s=t[19].queries[r];if(null===s.matches){const o=n.data,i=e.matches,a=[];for(let l=0;l<i.length;l+=2){const u=i[l];a.push(u<0?null:Hee(t,o[u],i[l+1],e.metadata.read))}s.matches=a}return s.matches}function nT(n,t,e,r){const s=n.queries.getByIndex(e),o=s.matches;if(null!==o){const i=HF(n,t,s,e);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const u=o[a+1],c=t[-l];for(let d=10;d<c.length;d++){const h=c[d];h[17]===h[3]&&nT(h[1],h,u,r)}if(null!==c[9]){const d=c[9];for(let h=0;h<d.length;h++){const p=d[h];nT(p[1],p,u,r)}}}}}return r}function Dp(n){const t=ue(),e=Ft(),r=C2();dx(r+1);const s=KF(e,r);if(n.dirty&&y2(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const o=s.crossesNgTemplate?nT(e,t,r,[]):HF(e,t,s,r);n.reset(o,aee),n.notifyOnChanges()}return!0}return!1}function rT(n,t,e){const r=Ft();r.firstCreatePass&&(function qF(n,t,e){null===n.queries&&(n.queries=new eT),n.queries.track(new tT(t,e))}(r,new GF(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),function jF(n,t,e){const r=new YS(4==(4&e));a$(n,t,r,r.destroy),null===t[19]&&(t[19]=new JS),t[19].queries.push(new QS(r))}(r,ue(),t)}function Ap(){return function qee(n,t){return n[19].queries[t].queryList}(ue(),C2())}function KF(n,t){return n.queries.getByIndex(t)}function XF(n,t){return Ly(n,t)}function zy(...n){}const cT=new Qe("Application Initializer");let dT=(()=>{class n{constructor(e){this.appInits=e,this.resolve=zy,this.reject=zy,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const o=this.appInits[s]();if(Iy(o))e.push(o);else if(lO(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});e.push(i)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(Ce(cT,8))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const $p=new Qe("AppId",{providedIn:"root",factory:function hM(){return`${hT()}${hT()}${hT()}`}});function hT(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const pM=new Qe("Platform Initializer"),pT=new Qe("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),fM=new Qe("appBootstrapListener");let dte=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const ba=new Qe("LocaleId",{providedIn:"root",factory:()=>Tx(ba,et.Optional|et.SkipSelf)||function hte(){return"undefined"!=typeof $localize&&$localize.locale||Ay}()});class fte{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let mM=(()=>{class n{compileModuleSync(e){return new jS(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=Ii(bo(e).declarations).reduce((i,a)=>{const l=Vr(a);return l&&i.push(new HS(l)),i},[]);return new fte(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const gte=(()=>Promise.resolve(0))();function fT(n){"undefined"==typeof Zone?gte.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class Cn{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new _s(!1),this.onMicrotaskEmpty=new _s(!1),this.onStable=new _s(!1),this.onError=new _s(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function yte(){let n=Qt.requestAnimationFrame,t=Qt.cancelAnimationFrame;if("undefined"!=typeof Zone&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function vte(n){const t=()=>{!function _te(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(Qt,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,gT(n),n.isCheckStableRunning=!0,mT(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),gT(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return gM(n),e.invokeTask(s,o,i,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||n.shouldCoalesceRunChangeDetection)&&t(),yM(n)}},onInvoke:(e,r,s,o,i,a,l)=>{try{return gM(n),e.invoke(s,o,i,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),yM(n)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(n._hasPendingMicrotasks=o.microTask,gT(n),mT(n)):"macroTask"==o.change&&(n.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),n.runOutsideAngular(()=>n.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return"undefined"!=typeof Zone&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Cn.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Cn.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,t,bte,zy,zy);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const bte={};function mT(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function gT(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function gM(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function yM(n){n._nesting--,mT(n)}class wte{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new _s,this.onMicrotaskEmpty=new _s,this.onStable=new _s,this.onError=new _s}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}let yT=(()=>{class n{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Cn.assertNotInAngularZone(),fT(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())fT(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(Ce(Cn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})(),xte=(()=>{class n{constructor(){this._applications=new Map,bT.addToWindow(this)}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return bT.findTestabilityInTree(this,e,r)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();class Ste{addToWindow(t){}findTestabilityInTree(t,e,r){return null}}let bT=new Ste,xu=null;const bM=new Qe("AllowMultipleToken"),_M=new Qe("PlatformOnDestroy");class vM{constructor(t,e){this.name=t,this.token=e}}function wM(n,t,e=[]){const r=`Platform: ${t}`,s=new Qe(r);return(o=[])=>{let i=_T();if(!i||i.injector.get(bM,!1)){const a=[...e,...o,{provide:s,useValue:!0}];n?n(a):function Ite(n){if(xu&&!xu.get(bM,!1))throw new Oe(400,"");xu=n;const t=n.get(xM),e=n.get(pM,null);e&&e.forEach(r=>r())}(function Nte(n=[],t){return Ys.create({name:t,providers:[{provide:_S,useValue:"platform"},{provide:_M,useValue:()=>xu=null},...n]})}(a,r))}return function kte(n){const t=_T();if(!t)throw new Oe(401,"");return t}()}}function _T(){var n;return null!==(n=null==xu?void 0:xu.get(xM))&&void 0!==n?n:null}let xM=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const a=function Dte(n,t){let e;return e="noop"===n?new wte:("zone.js"===n?void 0:n)||new Cn({enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),e}(r?r.ngZone:void 0,{ngZoneEventCoalescing:r&&r.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:r&&r.ngZoneRunCoalescing||!1}),l=[{provide:Cn,useValue:a}];return a.run(()=>{const u=Ys.create({providers:l,parent:this.injector,name:e.moduleType.name}),c=e.create(u),d=c.injector.get(pp,null);if(!d)throw new Oe(402,"");return a.runOutsideAngular(()=>{const h=a.onError.subscribe({next:p=>{d.handleError(p)}});c.onDestroy(()=>{wT(this._modules,c),h.unsubscribe()})}),function Ate(n,t,e){try{const r=e();return Iy(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(d,a,()=>{const h=c.injector.get(dT);return h.runInitializers(),h.donePromise.then(()=>(function aJ(n){Ws(n,"Expected localeId to be defined"),"string"==typeof n&&(rF=n.toLowerCase().replace(/_/g,"-"))}(c.injector.get(ba,Ay)||Ay),this._moduleDoBootstrap(c),c))})})}bootstrapModule(e,r=[]){const s=SM({},r);return function Cte(n,t,e){const r=new jS(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(vT);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new Oe(403,"");e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Oe(404,"");this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(_M,null);null==e||e(),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Ce(Ys))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function SM(n,t){return Array.isArray(t)?t.reduce(SM,n):Object.assign(Object.assign({},n),t)}let vT=(()=>{class n{constructor(e,r,s,o){this._zone=e,this._injector=r,this._exceptionHandler=s,this._initStatus=o,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new sr(l=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{l.next(this._stable),l.complete()})}),a=new sr(l=>{let u;this._zone.runOutsideAngular(()=>{u=this._zone.onStable.subscribe(()=>{Cn.assertNotInAngularZone(),fT(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,l.next(!0))})})});const c=this._zone.onUnstable.subscribe(()=>{Cn.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{l.next(!1)}))});return()=>{u.unsubscribe(),c.unsubscribe()}});this.isStable=function k7(...n){const t=Uh(n),e=function w7(n,t){return"number"==typeof L0(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?yo(r[0]):zh(e)(Xr(r,t)):ia}(i,a.pipe(function N7(n={}){const{connector:t=(()=>new go),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return o=>{let i,a,l,u=0,c=!1,d=!1;const h=()=>{null==a||a.unsubscribe(),a=void 0},p=()=>{h(),i=l=void 0,c=d=!1},f=()=>{const m=i;p(),null==m||m.unsubscribe()};return or((m,g)=>{u++,!d&&!c&&h();const y=l=null!=l?l:t();g.add(()=>{u--,0===u&&!d&&!c&&(a=V0(f,s))}),y.subscribe(g),!i&&u>0&&(i=new Bh({next:b=>y.next(b),error:b=>{d=!0,h(),a=V0(p,e,b),y.error(b)},complete:()=>{c=!0,h(),a=V0(p,r),y.complete()}}),yo(m).subscribe(i))})(o)}}()))}bootstrap(e,r){if(!this._initStatus.done)throw new Oe(405,"");let s;s=e instanceof kF?e:this._injector.get(Cp).resolveComponentFactory(e),this.componentTypes.push(s.componentType);const o=function Ete(n){return n.isBoundToModule}(s)?void 0:this._injector.get(ga),a=s.create(Ys.NULL,[],r||s.selector,o),l=a.location.nativeElement,u=a.injector.get(yT,null),c=u&&a.injector.get(xte);return u&&c&&c.registerApplication(l,u),a.onDestroy(()=>{this.detachView(a.hostView),wT(this.components,a),c&&c.unregisterApplication(l)}),this._loadComponent(a),a}tick(){if(this._runningTick)throw new Oe(101,"");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;wT(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(fM,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return n.\u0275fac=function(e){return new(e||n)(Ce(Cn),Ce(Ys),Ce(pp),Ce(dT))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function wT(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}let CM=!0,Op=(()=>{class n{}return n.__NG_ELEMENT_ID__=Ote,n})();function Ote(n){return function Fte(n,t,e){if(Ug(n)&&!e){const r=js(n.index,t);return new Ip(r,r)}return 47&n.type?new Ip(t[16],t):null}(mr(),ue(),16==(16&n))}class DM{constructor(){}supports(t){return yp(t)}create(t){return new zte(t)}}const Bte=(n,t)=>t;class zte{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||Bte}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,o=null;for(;e||r;){const i=!r||e&&e.currentIndex<RM(r,s,o)?e:r,a=RM(i,s,o),l=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{o||(o=[]);const u=a-s,c=l-s;if(u!=c){for(let h=0;h<u;h++){const p=h<o.length?o[h]:o[h]=0,f=p+h;c<=f&&f<u&&(o[h]=p+1)}o[i.previousIndex]=c-u}}a!==l&&t(i,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!yp(t))throw new Oe(900,"");return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,o,i,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)o=t[a],i=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,o,i,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,i,a),r=!0),e=e._next}else s=0,function qZ(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[Yc()]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{i=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,a,i,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,i,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let o;return null===t?o=this._itTail:(o=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,o,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,o,s)):t=this._addAfter(new Ute(e,r),o,s),t}_verifyReinsertion(t,e,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?t=this._reinsertAfter(o,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,o=t._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new AM),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new AM),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class Ute{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class Wte{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class AM{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new Wte,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function RM(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}function OM(){return new Gy([new DM])}let Gy=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||OM()),deps:[[n,new op,new Ja]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new Oe(901,"")}}return n.\u0275prov=lt({token:n,providedIn:"root",factory:OM}),n})();const Kte=wM(null,"core",[]);let Xte=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Ce(vT))},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({}),n})(),Hy=null;function sl(){return Hy}const Yn=new Qe("DocumentToken");let Tu=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:function(){return function Jte(){return Ce(MM)}()},providedIn:"platform"}),n})();const ene=new Qe("Location Initialized");let MM=(()=>{class n extends Tu{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return sl().getBaseHref(this._doc)}onPopState(e){const r=sl().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=sl().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,r,s){PM()?this._history.pushState(e,r,s):this.location.hash=s}replaceState(e,r,s){PM()?this._history.replaceState(e,r,s):this.location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(Ce(Yn))},n.\u0275prov=lt({token:n,factory:function(){return function tne(){return new MM(Ce(Yn))}()},providedIn:"platform"}),n})();function PM(){return!!window.history.pushState}function ET(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function LM(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function _a(n){return n&&"?"!==n[0]?"?"+n:n}let yd=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:function(){return function nne(n){const t=Ce(Yn).location;return new VM(Ce(Tu),t&&t.origin||"")}()},providedIn:"root"}),n})();const IT=new Qe("appBaseHref");let VM=(()=>{class n extends yd{constructor(e,r){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==r&&(r=this._platformLocation.getBaseHrefFromDOM()),null==r)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=r}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return ET(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+_a(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,o){const i=this.prepareExternalUrl(s+_a(o));this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){const i=this.prepareExternalUrl(s+_a(o));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var r,s;null===(s=(r=this._platformLocation).historyGo)||void 0===s||s.call(r,e)}}return n.\u0275fac=function(e){return new(e||n)(Ce(Tu),Ce(IT,8))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})(),rne=(()=>{class n extends yd{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=ET(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,o){let i=this.prepareExternalUrl(s+_a(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){let i=this.prepareExternalUrl(s+_a(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var r,s;null===(s=(r=this._platformLocation).historyGo)||void 0===s||s.call(r,e)}}return n.\u0275fac=function(e){return new(e||n)(Ce(Tu),Ce(IT,8))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})(),kT=(()=>{class n{constructor(e,r){this._subject=new _s,this._urlChangeListeners=[],this._platformStrategy=e;const s=this._platformStrategy.getBaseHref();this._platformLocation=r,this._baseHref=LM(BM(s)),this._platformStrategy.onPopState(o=>{this._subject.emit({url:this.path(!0),pop:!0,state:o.state,type:o.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+_a(r))}normalize(e){return n.stripTrailingSlash(function one(n,t){return n&&t.startsWith(n)?t.substring(n.length):t}(this._baseHref,BM(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._platformStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+_a(r)),s)}replaceState(e,r="",s=null){this._platformStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+_a(r)),s)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var r,s;null===(s=(r=this._platformStrategy).historyGo)||void 0===s||s.call(r,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)}))}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return n.normalizeQueryParams=_a,n.joinWithSlash=ET,n.stripTrailingSlash=LM,n.\u0275fac=function(e){return new(e||n)(Ce(yd),Ce(Tu))},n.\u0275prov=lt({token:n,factory:function(){return function sne(){return new kT(Ce(yd),Ce(Tu))}()},providedIn:"root"}),n})();function BM(n){return n.replace(/\/index.html$/,"")}var Ns=(()=>((Ns=Ns||{})[Ns.Decimal=0]="Decimal",Ns[Ns.Percent=1]="Percent",Ns[Ns.Currency=2]="Currency",Ns[Ns.Scientific=3]="Scientific",Ns))(),Ge=(()=>((Ge=Ge||{})[Ge.Decimal=0]="Decimal",Ge[Ge.Group=1]="Group",Ge[Ge.List=2]="List",Ge[Ge.PercentSign=3]="PercentSign",Ge[Ge.PlusSign=4]="PlusSign",Ge[Ge.MinusSign=5]="MinusSign",Ge[Ge.Exponential=6]="Exponential",Ge[Ge.SuperscriptingExponent=7]="SuperscriptingExponent",Ge[Ge.PerMille=8]="PerMille",Ge[Ge.Infinity=9]="Infinity",Ge[Ge.NaN=10]="NaN",Ge[Ge.TimeSeparator=11]="TimeSeparator",Ge[Ge.CurrencyDecimal=12]="CurrencyDecimal",Ge[Ge.CurrencyGroup=13]="CurrencyGroup",Ge))();function To(n,t){const e=bs(n),r=e[ke.NumberSymbols][t];if(void 0===r){if(t===Ge.CurrencyDecimal)return e[ke.NumberSymbols][Ge.Decimal];if(t===Ge.CurrencyGroup)return e[ke.NumberSymbols][Ge.Group]}return r}const Ane=/^(\d+)?\.((\d+)(-(\d+))?)?$/;function MT(n){const t=parseInt(n);if(isNaN(t))throw new Error("Invalid integer literal when parsing "+n);return t}class Hne{constructor(t,e,r,s){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let XM=(()=>{class n{constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,o,i)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new Hne(s.item,this._ngForOf,-1,-1),null===i?void 0:i);else if(null==i)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,i),YM(a,s)}});for(let s=0,o=r.length;s<o;s++){const a=r.get(s).context;a.index=s,a.count=o,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{YM(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(De(oi),De(ya),De(Gy))},n.\u0275dir=Lr({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),n})();function YM(n,t){n.context.$implicit=t.item}let ZM=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new jne,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){QM("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){QM("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(De(oi),De(ya))},n.\u0275dir=Lr({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),n})();class jne{constructor(){this.$implicit=null,this.ngIf=null}}function QM(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${qt(t)}'.`)}class LT{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let tb=(()=>{class n{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(e){this._ngSwitch=e,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(e){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(e)}_matchCase(e){const r=e==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||r,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),r}_updateDefaultCases(e){if(this._defaultViews&&e!==this._defaultUsed){this._defaultUsed=e;for(let r=0;r<this._defaultViews.length;r++)this._defaultViews[r].enforceState(e)}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Lr({type:n,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"}}),n})(),JM=(()=>{class n{constructor(e,r,s){this.ngSwitch=s,s._addCase(),this._view=new LT(e,r)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return n.\u0275fac=function(e){return new(e||n)(De(oi),De(ya),De(tb,9))},n.\u0275dir=Lr({type:n,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"}}),n})();function ai(n,t){return new Oe(2100,"")}const rre=/(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;let tP=(()=>{class n{transform(e){if(null==e)return null;if("string"!=typeof e)throw ai();return e.replace(rre,r=>r[0].toUpperCase()+r.substr(1).toLowerCase())}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275pipe=ks({name:"titlecase",type:n,pure:!0}),n})(),rP=(()=>{class n{constructor(e){this._locale=e}transform(e,r,s){if(!function VT(n){return!(null==n||""===n||n!=n)}(e))return null;s=s||this._locale;try{return function Pne(n,t,e){return function OT(n,t,e,r,s,o,i=!1){let a="",l=!1;if(isFinite(n)){let u=function Vne(n){let r,s,o,i,a,t=Math.abs(n)+"",e=0;for((s=t.indexOf("."))>-1&&(t=t.replace(".","")),(o=t.search(/e/i))>0?(s<0&&(s=o),s+=+t.slice(o+1),t=t.substring(0,o)):s<0&&(s=t.length),o=0;"0"===t.charAt(o);o++);if(o===(a=t.length))r=[0],s=1;else{for(a--;"0"===t.charAt(a);)a--;for(s-=o,r=[],i=0;o<=a;o++,i++)r[i]=Number(t.charAt(o))}return s>22&&(r=r.splice(0,21),e=s-1,s=1),{digits:r,exponent:e,integerLen:s}}(n);i&&(u=function Lne(n){if(0===n.digits[0])return n;const t=n.digits.length-n.integerLen;return n.exponent?n.exponent+=2:(0===t?n.digits.push(0,0):1===t&&n.digits.push(0),n.integerLen+=2),n}(u));let c=t.minInt,d=t.minFrac,h=t.maxFrac;if(o){const b=o.match(Ane);if(null===b)throw new Error(`${o} is not a valid digit info`);const _=b[1],v=b[3],w=b[5];null!=_&&(c=MT(_)),null!=v&&(d=MT(v)),null!=w?h=MT(w):null!=v&&d>h&&(h=d)}!function Bne(n,t,e){if(t>e)throw new Error(`The minimum number of digits after fraction (${t}) is higher than the maximum (${e}).`);let r=n.digits,s=r.length-n.integerLen;const o=Math.min(Math.max(t,s),e);let i=o+n.integerLen,a=r[i];if(i>0){r.splice(Math.max(n.integerLen,i));for(let d=i;d<r.length;d++)r[d]=0}else{s=Math.max(0,s),n.integerLen=1,r.length=Math.max(1,i=o+1),r[0]=0;for(let d=1;d<i;d++)r[d]=0}if(a>=5)if(i-1<0){for(let d=0;d>i;d--)r.unshift(0),n.integerLen++;r.unshift(1),n.integerLen++}else r[i-1]++;for(;s<Math.max(0,o);s++)r.push(0);let l=0!==o;const u=t+n.integerLen,c=r.reduceRight(function(d,h,p,f){return f[p]=(h+=d)<10?h:h-10,l&&(0===f[p]&&p>=u?f.pop():l=!1),h>=10?1:0},0);c&&(r.unshift(c),n.integerLen++)}(u,d,h);let p=u.digits,f=u.integerLen;const m=u.exponent;let g=[];for(l=p.every(b=>!b);f<c;f++)p.unshift(0);for(;f<0;f++)p.unshift(0);f>0?g=p.splice(f,p.length):(g=p,p=[0]);const y=[];for(p.length>=t.lgSize&&y.unshift(p.splice(-t.lgSize,p.length).join(""));p.length>t.gSize;)y.unshift(p.splice(-t.gSize,p.length).join(""));p.length&&y.unshift(p.join("")),a=y.join(To(e,r)),g.length&&(a+=To(e,s)+g.join("")),m&&(a+=To(e,Ge.Exponential)+"+"+m)}else a=To(e,Ge.Infinity);return a=n<0&&!l?t.negPre+a+t.negSuf:t.posPre+a+t.posSuf,a}(n,function FT(n,t="-"){const e={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=n.split(";"),s=r[0],o=r[1],i=-1!==s.indexOf(".")?s.split("."):[s.substring(0,s.lastIndexOf("0")+1),s.substring(s.lastIndexOf("0")+1)],a=i[0],l=i[1]||"";e.posPre=a.substr(0,a.indexOf("#"));for(let c=0;c<l.length;c++){const d=l.charAt(c);"0"===d?e.minFrac=e.maxFrac=c+1:"#"===d?e.maxFrac=c+1:e.posSuf+=d}const u=a.split(",");if(e.gSize=u[1]?u[1].length:0,e.lgSize=u[2]||u[1]?(u[2]||u[1]).length:0,o){const c=s.length-e.posPre.length-e.posSuf.length,d=o.indexOf("#");e.negPre=o.substr(0,d).replace(/'/g,""),e.negSuf=o.substr(d+c).replace(/'/g,"")}else e.negPre=t+e.posPre,e.negSuf=e.posSuf;return e}(function NT(n,t){return bs(n)[ke.NumberFormats][t]}(t,Ns.Decimal),To(t,Ge.MinusSign)),t,Ge.Group,Ge.Decimal,e)}(function BT(n){if("string"==typeof n&&!isNaN(Number(n)-parseFloat(n)))return Number(n);if("number"!=typeof n)throw new Error(`${n} is not a number`);return n}(e),s,r)}catch(o){throw ai()}}}return n.\u0275fac=function(e){return new(e||n)(De(ba,16))},n.\u0275pipe=ks({name:"number",type:n,pure:!0}),n})();let zT=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({}),n})();const sP="browser";let vre=(()=>{class n{}return n.\u0275prov=lt({token:n,providedIn:"root",factory:()=>new wre(Ce(Yn),window)}),n})();class wre{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function xre(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&(n.body.createShadowRoot||n.body.attachShadow)){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(t)||o.querySelector(`[name="${t}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=oP(this.window.history)||oP(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(t){return!1}}}function oP(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class UT extends class Tre extends class Qte{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){!function Zte(n){Hy||(Hy=n)}(new UT)}onAndCancel(t,e,r){return t.addEventListener(e,r,!1),()=>{t.removeEventListener(e,r,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function Cre(){return Lp=Lp||document.querySelector("base"),Lp?Lp.getAttribute("href"):null}();return null==e?null:function Ere(n){nb=nb||document.createElement("a"),nb.setAttribute("href",n);const t=nb.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){Lp=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function Une(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(o)}return null}(document.cookie,t)}}let nb,Lp=null;const iP=new Qe("TRANSITION_ID"),kre=[{provide:cT,useFactory:function Ire(n,t,e){return()=>{e.get(dT).donePromise.then(()=>{const r=sl(),s=t.querySelectorAll(`style[ng-transition="${n}"]`);for(let o=0;o<s.length;o++)r.remove(s[o])})}},deps:[iP,Yn,Ys],multi:!0}];class WT{static init(){!function Tte(n){bT=n}(new WT)}addToWindow(t){Qt.getAngularTestability=(r,s=!0)=>{const o=t.findTestabilityInTree(r,s);if(null==o)throw new Error("Could not find testability for element.");return o},Qt.getAllAngularTestabilities=()=>t.getAllTestabilities(),Qt.getAllAngularRootElements=()=>t.getAllRootElements(),Qt.frameworkStabilizers||(Qt.frameworkStabilizers=[]),Qt.frameworkStabilizers.push(r=>{const s=Qt.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(l){i=i||l,o--,0==o&&r(i)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,r){if(null==e)return null;const s=t.getTestability(e);return null!=s?s:r?sl().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}let Nre=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();const rb=new Qe("EventManagerPlugins");let sb=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let o=0;o<s.length;o++){const i=s[o];if(i.supports(e))return this._eventNameToPlugin.set(e,i),i}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Ce(rb),Ce(Cn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();class aP{constructor(t){this._doc=t}addGlobalEventListener(t,e,r){const s=sl().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let lP=(()=>{class n{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})(),Vp=(()=>{class n extends lP{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(o=>{const i=this._doc.createElement("style");i.textContent=o,s.push(r.appendChild(i))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach(uP),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(uP))}}return n.\u0275fac=function(e){return new(e||n)(Ce(Yn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();function uP(n){sl().remove(n)}const GT={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},HT=/%COMP%/g;function ob(n,t,e){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?ob(n,s,e):(s=s.replace(HT,n),e.push(s))}return e}function hP(n){return t=>{if("__ngUnwrap__"===t)return n;!1===n(t)&&(t.preventDefault(),t.returnValue=!1)}}let ib=(()=>{class n{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new jT(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case Ko.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new Fre(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case Ko.ShadowDom:return new Mre(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=ob(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(Ce(sb),Ce(Vp),Ce($p))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();class jT{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?document.createElementNS(GT[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,r){t&&t.insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?document.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const o=GT[s];o?t.setAttributeNS(o,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=GT[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&(Ks.DashCase|Ks.Important)?t.style.setProperty(e,r,s&Ks.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&Ks.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,hP(r)):this.eventManager.addEventListener(t,e,hP(r))}}class Fre extends jT{constructor(t,e,r,s){super(t),this.component=r;const o=ob(s+"-"+r.id,r.styles,[]);e.addStyles(o),this.contentAttr=function Rre(n){return"_ngcontent-%COMP%".replace(HT,n)}(s+"-"+r.id),this.hostAttr=function $re(n){return"_nghost-%COMP%".replace(HT,n)}(s+"-"+r.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}class Mre extends jT{constructor(t,e,r,s){super(t),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=ob(s.id,s.styles,[]);for(let i=0;i<o.length;i++){const a=document.createElement("style");a.textContent=o[i],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let Pre=(()=>{class n extends aP{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(Ce(Yn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();const fP=["alt","control","meta","shift"],Vre={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},mP={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Bre={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let zre=(()=>{class n extends aP{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const o=n.parseEventName(r),i=n.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>sl().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=n._normalizeKey(r.pop());let i="";if(fP.forEach(l=>{const u=r.indexOf(l);u>-1&&(r.splice(u,1),i+=l+".")}),i+=o,0!=r.length||0===o.length)return null;const a={};return a.domEventName=s,a.fullKey=i,a}static getEventFullKey(e){let r="",s=function Ure(n){let t=n.key;if(null==t){if(t=n.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===n.location&&mP.hasOwnProperty(t)&&(t=mP[t]))}return Vre[t]||t}(e);return s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),fP.forEach(o=>{o!=s&&Bre[o](e)&&(r+=o+".")}),r+=s,r}static eventCallback(e,r,s){return o=>{n.getEventFullKey(o)===e&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Ce(Yn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();const jre=wM(Kte,"browser",[{provide:pT,useValue:sP},{provide:pM,useValue:function Wre(){UT.makeCurrent(),WT.init()},multi:!0},{provide:Yn,useFactory:function Hre(){return function o9(n){nx=n}(document),document},deps:[]}]),qre=[{provide:_S,useValue:"root"},{provide:pp,useFactory:function Gre(){return new pp},deps:[]},{provide:rb,useClass:Pre,multi:!0,deps:[Yn,Cn,pT]},{provide:rb,useClass:zre,multi:!0,deps:[Yn]},{provide:ib,useClass:ib,deps:[sb,Vp,$p]},{provide:Ep,useExisting:ib},{provide:lP,useExisting:Vp},{provide:Vp,useClass:Vp,deps:[Yn]},{provide:yT,useClass:yT,deps:[Cn]},{provide:sb,useClass:sb,deps:[rb,Cn]},{provide:class Sre{},useClass:Nre,deps:[]}];let gP=(()=>{class n{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:n,providers:[{provide:$p,useValue:e.appId},{provide:iP,useExisting:$p},kre]}}}return n.\u0275fac=function(e){return new(e||n)(Ce(n,12))},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({providers:qre,imports:[zT,Xte]}),n})();function dt(...n){return Xr(n,Uh(n))}"undefined"!=typeof window&&window;class Eo extends go{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const{isArray:sse}=Array,{getPrototypeOf:ose,prototype:ise,keys:ase}=Object;const{isArray:cse}=Array;function fse(...n){const t=Uh(n),e=function v7(n){return Fn(L0(n))?n.pop():void 0}(n),{args:r,keys:s}=function lse(n){if(1===n.length){const t=n[0];if(sse(t))return{args:t,keys:null};if(function use(n){return n&&"object"==typeof n&&ose(n)===ise}(t)){const e=ase(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}(n);if(0===r.length)return Xr([],t);const o=new sr(function mse(n,t,e=ja){return r=>{_P(t,()=>{const{length:s}=n,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)_P(t,()=>{const u=Xr(n[l],t);let c=!1;u.subscribe(Xn(r,d=>{o[l]=d,c||(c=!0,a--),a||r.next(e(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,t,s?i=>function pse(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}(s,i):ja));return e?o.pipe(function hse(n){return bn(t=>function dse(n,t){return cse(t)?n(...t):n(t)}(n,t))}(e)):o}function _P(n,t,e){n?oa(e,n,t):t()}function ab(n,t){const e=Fn(n)?n:()=>n,r=s=>s.error(e());return new sr(t?s=>t.schedule(r,0,s):r)}const lb=N0(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function KT(...n){return function gse(){return zh(1)}()(Xr(n,Uh(n)))}function vP(n){return new sr(t=>{yo(n()).subscribe(t)})}function wP(){return or((n,t)=>{let e=null;n._refCount++;const r=Xn(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const s=n._connection,o=e;e=null,s&&(!o||s===o)&&s.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class yse extends sr{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,PA(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,null==t||t.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new hs;const e=this.getSubject();t.add(this.source.subscribe(Xn(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=hs.EMPTY)}return t}refCount(){return wP()(this)}}function Cu(n,t){return or((e,r)=>{let s=null,o=0,i=!1;const a=()=>i&&!s&&r.complete();e.subscribe(Xn(r,l=>{null==s||s.unsubscribe();let u=0;const c=o++;yo(n(l,c)).subscribe(s=Xn(r,d=>r.next(t?t(l,d,c,u++):d),()=>{s=null,a()}))},()=>{i=!0,a()}))})}function XT(n){return n<=0?()=>ia:or((t,e)=>{let r=0;t.subscribe(Xn(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}function _se(n,t,e,r,s){return(o,i)=>{let a=e,l=t,u=0;o.subscribe(Xn(i,c=>{const d=u++;l=a?n(l,c,d):(a=!0,c),r&&i.next(l)},s&&(()=>{a&&i.next(l),i.complete()})))}}function xP(n,t){return or(_se(n,t,arguments.length>=2,!0))}function Eu(n,t){return or((e,r)=>{let s=0;e.subscribe(Xn(r,o=>n.call(t,o,s++)&&r.next(o)))})}function il(n){return or((t,e)=>{let o,r=null,s=!1;r=t.subscribe(Xn(e,void 0,void 0,i=>{o=yo(n(i,il(n)(t))),r?(r.unsubscribe(),r=null,o.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,o.subscribe(e))})}function Bp(n,t){return Fn(t)?Nr(n,t,1):Nr(n,1)}function YT(n){return n<=0?()=>ia:or((t,e)=>{let r=[];t.subscribe(Xn(e,s=>{r.push(s),n<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function SP(n=vse){return or((t,e)=>{let r=!1;t.subscribe(Xn(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(n())))})}function vse(){return new lb}function TP(n){return or((t,e)=>{let r=!1;t.subscribe(Xn(e,s=>{r=!0,e.next(s)},()=>{r||e.next(n),e.complete()}))})}function bd(n,t){const e=arguments.length>=2;return r=>r.pipe(n?Eu((s,o)=>n(s,o,r)):ja,XT(1),e?TP(t):SP(()=>new lb))}function Zs(n,t,e){const r=Fn(n)||t||e?{next:n,error:t,complete:e}:n;return r?or((s,o)=>{var i;null===(i=r.subscribe)||void 0===i||i.call(r);let a=!0;s.subscribe(Xn(o,l=>{var u;null===(u=r.next)||void 0===u||u.call(r,l),o.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),o.complete()},l=>{var u;a=!1,null===(u=r.error)||void 0===u||u.call(r,l),o.error(l)},()=>{var l,u;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):ja}class wa{constructor(t,e){this.id=t,this.url=e}}class ZT extends wa{constructor(t,e,r="imperative",s=null){super(t,e),this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class zp extends wa{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class CP extends wa{constructor(t,e,r){super(t,e),this.reason=r}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Sse extends wa{constructor(t,e,r){super(t,e),this.error=r}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Tse extends wa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Cse extends wa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ese extends wa{constructor(t,e,r,s,o){super(t,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Ise extends wa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class kse extends wa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class EP{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class IP{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Nse{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Dse{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Ase{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Rse{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class kP{constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const St="primary";class $se{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function _d(n){return new $se(n)}const NP="ngNavigationCancelingError";function QT(n){const t=Error("NavigationCancelingError: "+n);return t[NP]=!0,t}function Fse(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=n[o];if(i.startsWith(":"))s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:s}}function Ri(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let o=0;o<e.length;o++)if(s=e[o],!DP(n[s],t[s]))return!1;return!0}function DP(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((s,o)=>r[o]===s)}return n===t}function AP(n){return Array.prototype.concat.apply([],n)}function RP(n){return n.length>0?n[n.length-1]:null}function Br(n,t){for(const e in n)n.hasOwnProperty(e)&&t(n[e],e)}function $i(n){return lO(n)?n:Iy(n)?Xr(Promise.resolve(n)):dt(n)}const Lse={exact:function FP(n,t,e){if(!ku(n.segments,t.segments)||!ub(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!FP(n.children[r],t.children[r],e))return!1;return!0},subset:MP},$P={exact:function Vse(n,t){return Ri(n,t)},subset:function Bse(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>DP(n[e],t[e]))},ignored:()=>!0};function OP(n,t,e){return Lse[e.paths](n.root,t.root,e.matrixParams)&&$P[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function MP(n,t,e){return PP(n,t,t.segments,e)}function PP(n,t,e,r){if(n.segments.length>e.length){const s=n.segments.slice(0,e.length);return!(!ku(s,e)||t.hasChildren()||!ub(s,e,r))}if(n.segments.length===e.length){if(!ku(n.segments,e)||!ub(n.segments,e,r))return!1;for(const s in t.children)if(!n.children[s]||!MP(n.children[s],t.children[s],r))return!1;return!0}{const s=e.slice(0,n.segments.length),o=e.slice(n.segments.length);return!!(ku(n.segments,s)&&ub(n.segments,s,r)&&n.children[St])&&PP(n.children[St],t,o,r)}}function ub(n,t,e){return t.every((r,s)=>$P[e](n[s].parameters,r.parameters))}class Iu{constructor(t,e,r){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=_d(this.queryParams)),this._queryParamMap}toString(){return Wse.serialize(this)}}class Dt{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Br(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return cb(this)}}class Up{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=_d(this.parameters)),this._parameterMap}toString(){return UP(this)}}function ku(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}class LP{}class VP{parse(t){const e=new Qse(t);return new Iu(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${Wp(t.root,!0)}`,r=function jse(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(s=>`${db(e)}=${db(s)}`).join("&"):`${db(e)}=${db(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function Gse(n){return encodeURI(n)}(t.fragment)}`:""}`}}const Wse=new VP;function cb(n){return n.segments.map(t=>UP(t)).join("/")}function Wp(n,t){if(!n.hasChildren())return cb(n);if(t){const e=n.children[St]?Wp(n.children[St],!1):"",r=[];return Br(n.children,(s,o)=>{o!==St&&r.push(`${o}:${Wp(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function Use(n,t){let e=[];return Br(n.children,(r,s)=>{s===St&&(e=e.concat(t(r,s)))}),Br(n.children,(r,s)=>{s!==St&&(e=e.concat(t(r,s)))}),e}(n,(r,s)=>s===St?[Wp(n.children[St],!1)]:[`${s}:${Wp(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[St]?`${cb(n)}/${e[0]}`:`${cb(n)}/(${e.join("//")})`}}function BP(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function db(n){return BP(n).replace(/%3B/gi,";")}function JT(n){return BP(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function hb(n){return decodeURIComponent(n)}function zP(n){return hb(n.replace(/\+/g,"%20"))}function UP(n){return`${JT(n.path)}${function Hse(n){return Object.keys(n).map(t=>`;${JT(t)}=${JT(n[t])}`).join("")}(n.parameters)}`}const qse=/^[^\/()?;=#]+/;function pb(n){const t=n.match(qse);return t?t[0]:""}const Kse=/^[^=?&#]+/,Yse=/^[^&#]+/;class Qse{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Dt([],{}):new Dt([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[St]=new Dt(t,e)),r}parseSegment(){const t=pb(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new Up(hb(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=pb(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=pb(this.remaining);s&&(r=s,this.capture(r))}t[hb(e)]=hb(r)}parseQueryParam(t){const e=function Xse(n){const t=n.match(Kse);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=function Zse(n){const t=n.match(Yse);return t?t[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=zP(e),o=zP(r);if(t.hasOwnProperty(s)){let i=t[s];Array.isArray(i)||(i=[i],t[s]=i),i.push(o)}else t[s]=o}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=pb(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let o;r.indexOf(":")>-1?(o=r.substr(0,r.indexOf(":")),this.capture(o),this.capture(":")):t&&(o=St);const i=this.parseChildren();e[o]=1===Object.keys(i).length?i[St]:new Dt([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class WP{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=e1(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=e1(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=t1(t,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==t)}pathFromRoot(t){return t1(t,this._root).map(e=>e.value)}}function e1(n,t){if(n===t.value)return t;for(const e of t.children){const r=e1(n,e);if(r)return r}return null}function t1(n,t){if(n===t.value)return[t];for(const e of t.children){const r=t1(n,e);if(r.length)return r.unshift(t),r}return[]}class xa{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function vd(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class GP extends WP{constructor(t,e){super(t),this.snapshot=e,n1(this,t)}toString(){return this.snapshot.toString()}}function HP(n,t){const e=function Jse(n,t){const i=new fb([],{},{},"",{},St,t,null,n.root,-1,{});return new qP("",new xa(i,[]))}(n,t),r=new Eo([new Up("",{})]),s=new Eo({}),o=new Eo({}),i=new Eo({}),a=new Eo(""),l=new wd(r,s,i,a,o,St,t,e.root);return l.snapshot=e.root,new GP(new xa(l,[]),e)}class wd{constructor(t,e,r,s,o,i,a,l){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(bn(t=>_d(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(bn(t=>_d(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function jP(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const s=e[r],o=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(o.component)break;r--}}return function eoe(n){return n.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(e.slice(r))}class fb{constructor(t,e,r,s,o,i,a,l,u,c,d){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=l,this._urlSegment=u,this._lastPathIndex=c,this._resolve=d}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=_d(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=_d(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class qP extends WP{constructor(t,e){super(e),this.url=t,n1(this,e)}toString(){return KP(this._root)}}function n1(n,t){t.value._routerState=n,t.children.forEach(e=>n1(n,e))}function KP(n){const t=n.children.length>0?` { ${n.children.map(KP).join(", ")} } `:"";return`${n.value}${t}`}function r1(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,Ri(t.queryParams,e.queryParams)||n.queryParams.next(e.queryParams),t.fragment!==e.fragment&&n.fragment.next(e.fragment),Ri(t.params,e.params)||n.params.next(e.params),function Mse(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!Ri(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.url.next(e.url),Ri(t.data,e.data)||n.data.next(e.data)}else n.snapshot=n._futureSnapshot,n.data.next(n._futureSnapshot.data)}function s1(n,t){const e=Ri(n.params,t.params)&&function zse(n,t){return ku(n,t)&&n.every((e,r)=>Ri(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||s1(n.parent,t.parent))}function Gp(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const s=function noe(n,t,e){return t.children.map(r=>{for(const s of e.children)if(n.shouldReuseRoute(r.value,s.value.snapshot))return Gp(n,r,s);return Gp(n,r)})}(n,t,e);return new xa(r,s)}{if(n.shouldAttach(t.value)){const o=n.retrieve(t.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=t.value,i.children=t.children.map(a=>Gp(n,a)),i}}const r=function roe(n){return new wd(new Eo(n.url),new Eo(n.params),new Eo(n.queryParams),new Eo(n.fragment),new Eo(n.data),n.outlet,n.component,n)}(t.value),s=t.children.map(o=>Gp(n,o));return new xa(r,s)}}function mb(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function Hp(n){return"object"==typeof n&&null!=n&&n.outlets}function o1(n,t,e,r,s){let o={};if(r&&Br(r,(a,l)=>{o[l]=Array.isArray(a)?a.map(u=>`${u}`):`${a}`}),n===t)return new Iu(e,o,s);const i=XP(n,t,e);return new Iu(i,o,s)}function XP(n,t,e){const r={};return Br(n.children,(s,o)=>{r[o]=s===t?e:XP(s,t,e)}),new Dt(n.segments,r)}class YP{constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&mb(r[0]))throw new Error("Root segment cannot have matrix parameters");const s=r.find(Hp);if(s&&s!==RP(r))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class a1{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function ZP(n,t,e){if(n||(n=new Dt([],{})),0===n.segments.length&&n.hasChildren())return gb(n,t,e);const r=function uoe(n,t,e){let r=0,s=t;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<n.segments.length;){if(r>=e.length)return o;const i=n.segments[s],a=e[r];if(Hp(a))break;const l=`${a}`,u=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!JP(l,u,i))return o;r+=2}else{if(!JP(l,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(n,t,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const o=new Dt(n.segments.slice(0,r.pathIndex),{});return o.children[St]=new Dt(n.segments.slice(r.pathIndex),n.children),gb(o,0,s)}return r.match&&0===s.length?new Dt(n.segments,{}):r.match&&!n.hasChildren()?l1(n,t,e):r.match?gb(n,0,s):l1(n,t,e)}function gb(n,t,e){if(0===e.length)return new Dt(n.segments,{});{const r=function loe(n){return Hp(n[0])?n[0].outlets:{[St]:n}}(e),s={};return Br(r,(o,i)=>{"string"==typeof o&&(o=[o]),null!==o&&(s[i]=ZP(n.children[i],t,o))}),Br(n.children,(o,i)=>{void 0===r[i]&&(s[i]=o)}),new Dt(n.segments,s)}}function l1(n,t,e){const r=n.segments.slice(0,t);let s=0;for(;s<e.length;){const o=e[s];if(Hp(o)){const l=coe(o.outlets);return new Dt(r,l)}if(0===s&&mb(e[0])){r.push(new Up(n.segments[t].path,QP(e[0]))),s++;continue}const i=Hp(o)?o.outlets[St]:`${o}`,a=s<e.length-1?e[s+1]:null;i&&a&&mb(a)?(r.push(new Up(i,QP(a))),s+=2):(r.push(new Up(i,{})),s++)}return new Dt(r,{})}function coe(n){const t={};return Br(n,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[r]=l1(new Dt([],{}),0,e))}),t}function QP(n){const t={};return Br(n,(e,r)=>t[r]=`${e}`),t}function JP(n,t,e){return n==e.path&&Ri(t,e.parameters)}class hoe{constructor(t,e,r,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),r1(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const s=vd(e);t.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),Br(s,(o,i)=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(t,e,r){const s=t.value,o=e?e.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(t,e,i.children)}else this.deactivateChildRoutes(t,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,o=vd(t);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:i,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,o=vd(t);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(t,e,r){const s=vd(e);t.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new Rse(o.value.snapshot))}),t.children.length&&this.forwardEvent(new Dse(t.value.snapshot))}activateRoutes(t,e,r){const s=t.value,o=e?e.value:null;if(r1(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,i.children)}else this.activateChildRoutes(t,e,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),r1(a.route.value),this.activateChildRoutes(t,null,i.children)}else{const a=function poe(n){for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(s.snapshot),l=a?a.module.componentFactoryResolver:null;i.attachRef=null,i.route=s,i.resolver=l,i.outlet&&i.outlet.activateWith(s,l),this.activateChildRoutes(t,null,i.children)}}else this.activateChildRoutes(t,null,r)}}class u1{constructor(t,e){this.routes=t,this.module=e}}function al(n){return"function"==typeof n}function Nu(n){return n instanceof Iu}const jp=Symbol("INITIAL_VALUE");function qp(){return Cu(n=>fse(n.map(t=>t.pipe(XT(1),function bse(...n){const t=Uh(n);return or((e,r)=>{(t?KT(n,e,t):KT(n,e)).subscribe(r)})}(jp)))).pipe(xP((t,e)=>{let r=!1;return e.reduce((s,o,i)=>s!==jp?s:(o===jp&&(r=!0),r||!1!==o&&i!==e.length-1&&!Nu(o)?s:o),t)},jp),Eu(t=>t!==jp),bn(t=>Nu(t)?t:!0===t),XT(1)))}class _oe{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new Kp,this.attachRef=null}}class Kp{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const r=this.getOrCreateContext(t);r.outlet=e,this.contexts.set(t,r)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null,e.attachRef=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new _oe,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}let eL=(()=>{class n{constructor(e,r,s,o,i){this.parentContexts=e,this.location=r,this.resolver=s,this.changeDetector=i,this.activated=null,this._activatedRoute=null,this.activateEvents=new _s,this.deactivateEvents=new _s,this.attachEvents=new _s,this.detachEvents=new _s,this.name=o||St,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const i=(r=r||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),a=this.parentContexts.getOrCreateContext(this.name).children,l=new voe(e,a,this.location.injector);this.activated=this.location.createComponent(i,this.location.length,l),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)(De(Kp),De(oi),De(Cp),function Qh(n){return function F9(n,t){if("class"===t)return n.classes;if("style"===t)return n.styles;const e=n.attrs;if(e){const r=e.length;let s=0;for(;s<r;){const o=e[s];if(R2(o))break;if(0===o)s+=2;else if("number"==typeof o)for(s++;s<r&&"string"==typeof e[s];)s++;else{if(o===t)return e[s+1];s+=2}}}return null}(mr(),n)}("name"),De(Op))},n.\u0275dir=Lr({type:n,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"]}),n})();class voe{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===wd?this.route:t===Kp?this.childContexts:this.parent.get(t,e)}}let tL=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=cu({type:n,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,r){1&e&&ma(0,"router-outlet")},directives:[eL],encapsulation:2}),n})();function nL(n,t=""){for(let e=0;e<n.length;e++){const r=n[e];woe(r,xoe(t,r))}}function woe(n,t){n.children&&nL(n.children,t)}function xoe(n,t){return t?n||t.path?n&&!t.path?`${n}/`:!n&&t.path?t.path:`${n}/${t.path}`:"":n}function c1(n){const t=n.children&&n.children.map(c1),e=t?Object.assign(Object.assign({},n),{children:t}):Object.assign({},n);return!e.component&&(t||e.loadChildren)&&e.outlet&&e.outlet!==St&&(e.component=tL),e}function Io(n){return n.outlet||St}function rL(n,t){const e=n.filter(r=>Io(r)===t);return e.push(...n.filter(r=>Io(r)!==t)),e}const sL={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function yb(n,t,e){var r;if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?Object.assign({},sL):{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const o=(t.matcher||Fse)(e,n,t);if(!o)return Object.assign({},sL);const i={};Br(o.posParams,(l,u)=>{i[u]=l.path});const a=o.consumed.length>0?Object.assign(Object.assign({},i),o.consumed[o.consumed.length-1].parameters):i;return{matched:!0,consumedSegments:o.consumed,remainingSegments:e.slice(o.consumed.length),parameters:a,positionalParamSegments:null!==(r=o.posParams)&&void 0!==r?r:{}}}function bb(n,t,e,r,s="corrected"){if(e.length>0&&function Coe(n,t,e){return e.some(r=>_b(n,t,r)&&Io(r)!==St)}(n,e,r)){const i=new Dt(t,function Toe(n,t,e,r){const s={};s[St]=r,r._sourceSegment=n,r._segmentIndexShift=t.length;for(const o of e)if(""===o.path&&Io(o)!==St){const i=new Dt([],{});i._sourceSegment=n,i._segmentIndexShift=t.length,s[Io(o)]=i}return s}(n,t,r,new Dt(e,n.children)));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:[]}}if(0===e.length&&function Eoe(n,t,e){return e.some(r=>_b(n,t,r))}(n,e,r)){const i=new Dt(n.segments,function Soe(n,t,e,r,s,o){const i={};for(const a of r)if(_b(n,e,a)&&!s[Io(a)]){const l=new Dt([],{});l._sourceSegment=n,l._segmentIndexShift="legacy"===o?n.segments.length:t.length,i[Io(a)]=l}return Object.assign(Object.assign({},s),i)}(n,t,e,r,n.children,s));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:e}}const o=new Dt(n.segments,n.children);return o._sourceSegment=n,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:e}}function _b(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}function oL(n,t,e,r){return!!(Io(n)===r||r!==St&&_b(t,e,n))&&("**"===n.path||yb(t,n,e).matched)}function iL(n,t,e){return 0===t.length&&!n.children[e]}class vb{constructor(t){this.segmentGroup=t||null}}class aL{constructor(t){this.urlTree=t}}function Xp(n){return ab(new vb(n))}function lL(n){return ab(new aL(n))}class Doe{constructor(t,e,r,s,o){this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=o,this.allowRedirects=!0,this.ngModule=t.get(ga)}apply(){const t=bb(this.urlTree.root,[],[],this.config).segmentGroup,e=new Dt(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,St).pipe(bn(o=>this.createUrlTree(d1(o),this.urlTree.queryParams,this.urlTree.fragment))).pipe(il(o=>{if(o instanceof aL)return this.allowRedirects=!1,this.match(o.urlTree);throw o instanceof vb?this.noMatchError(o):o}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,St).pipe(bn(s=>this.createUrlTree(d1(s),t.queryParams,t.fragment))).pipe(il(s=>{throw s instanceof vb?this.noMatchError(s):s}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,r){const s=t.segments.length>0?new Dt([],{[St]:t}):t;return new Iu(s,e,r)}expandSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(t,e,r).pipe(bn(o=>new Dt([],o))):this.expandSegment(t,r,e,r.segments,s,!0)}expandChildren(t,e,r){const s=[];for(const o of Object.keys(r.children))"primary"===o?s.unshift(o):s.push(o);return Xr(s).pipe(Bp(o=>{const i=r.children[o],a=rL(e,o);return this.expandSegmentGroup(t,a,i,o).pipe(bn(l=>({segment:l,outlet:o})))}),xP((o,i)=>(o[i.outlet]=i.segment,o),{}),function wse(n,t){const e=arguments.length>=2;return r=>r.pipe(n?Eu((s,o)=>n(s,o,r)):ja,YT(1),e?TP(t):SP(()=>new lb))}())}expandSegment(t,e,r,s,o,i){return Xr(r).pipe(Bp(a=>this.expandSegmentAgainstRoute(t,e,r,a,s,o,i).pipe(il(u=>{if(u instanceof vb)return dt(null);throw u}))),bd(a=>!!a),il((a,l)=>{if(a instanceof lb||"EmptyError"===a.name)return iL(e,s,o)?dt(new Dt([],{})):Xp(e);throw a}))}expandSegmentAgainstRoute(t,e,r,s,o,i,a){return oL(s,e,o,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,o,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,r,s,o,i):Xp(e):Xp(e)}expandSegmentAgainstRouteUsingRedirect(t,e,r,s,o,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,o,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,s){const o=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?lL(o):this.lineralizeSegments(r,o).pipe(Nr(i=>{const a=new Dt(i,{});return this.expandSegment(t,a,e,i,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,o,i){const{matched:a,consumedSegments:l,remainingSegments:u,positionalParamSegments:c}=yb(e,s,o);if(!a)return Xp(e);const d=this.applyRedirectCommands(l,s.redirectTo,c);return s.redirectTo.startsWith("/")?lL(d):this.lineralizeSegments(s,d).pipe(Nr(h=>this.expandSegment(t,e,r,h.concat(u),i,!1)))}matchSegmentAgainstRoute(t,e,r,s,o){if("**"===r.path)return r.loadChildren?(r._loadedConfig?dt(r._loadedConfig):this.configLoader.load(t.injector,r)).pipe(bn(d=>(r._loadedConfig=d,new Dt(s,{})))):dt(new Dt(s,{}));const{matched:i,consumedSegments:a,remainingSegments:l}=yb(e,r,s);return i?this.getChildConfig(t,r,s).pipe(Nr(c=>{const d=c.module,h=c.routes,{segmentGroup:p,slicedSegments:f}=bb(e,a,l,h),m=new Dt(p.segments,p.children);if(0===f.length&&m.hasChildren())return this.expandChildren(d,h,m).pipe(bn(_=>new Dt(a,_)));if(0===h.length&&0===f.length)return dt(new Dt(a,{}));const g=Io(r)===o;return this.expandSegment(d,m,h,f,g?St:o,!0).pipe(bn(b=>new Dt(a.concat(b.segments),b.children)))})):Xp(e)}getChildConfig(t,e,r){return e.children?dt(new u1(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?dt(e._loadedConfig):this.runCanLoadGuards(t.injector,e,r).pipe(Nr(s=>s?this.configLoader.load(t.injector,e).pipe(bn(o=>(e._loadedConfig=o,o))):function koe(n){return ab(QT(`Cannot load children because the guard of the route "path: '${n.path}'" returned false`))}(e))):dt(new u1([],t))}runCanLoadGuards(t,e,r){const s=e.canLoad;return s&&0!==s.length?dt(s.map(i=>{const a=t.get(i);let l;if(function moe(n){return n&&al(n.canLoad)}(a))l=a.canLoad(e,r);else{if(!al(a))throw new Error("Invalid CanLoad guard");l=a(e,r)}return $i(l)})).pipe(qp(),Zs(i=>{if(!Nu(i))return;const a=QT(`Redirecting to "${this.urlSerializer.serialize(i)}"`);throw a.url=i,a}),bn(i=>!0===i)):dt(!0)}lineralizeSegments(t,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return dt(r);if(s.numberOfChildren>1||!s.children[St])return ab(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t.redirectTo}'`));s=s.children[St]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreatreUrlTree(t,e,r,s){const o=this.createSegmentGroup(t,e.root,r,s);return new Iu(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Br(t,(s,o)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(t,e,r,s){const o=this.createSegments(t,e.segments,r,s);let i={};return Br(e.children,(a,l)=>{i[l]=this.createSegmentGroup(t,a,r,s)}),new Dt(o,i)}createSegments(t,e,r,s){return e.map(o=>o.path.startsWith(":")?this.findPosParam(t,o,s):this.findOrReturn(o,r))}findPosParam(t,e,r){const s=r[e.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return s}findOrReturn(t,e){let r=0;for(const s of e){if(s.path===t.path)return e.splice(r),s;r++}return t}}function d1(n){const t={};for(const r of Object.keys(n.children)){const o=d1(n.children[r]);(o.segments.length>0||o.hasChildren())&&(t[r]=o)}return function Aoe(n){if(1===n.numberOfChildren&&n.children[St]){const t=n.children[St];return new Dt(n.segments.concat(t.segments),t.children)}return n}(new Dt(n.segments,t))}class uL{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class wb{constructor(t,e){this.component=t,this.route=e}}function $oe(n,t,e){const r=n._root;return Yp(r,t?t._root:null,e,[r.value])}function xb(n,t,e){const r=function Foe(n){if(!n)return null;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(r?r.module.injector:e).get(n)}function Yp(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=vd(t);return n.children.forEach(i=>{(function Moe(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=n.value,i=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const l=function Poe(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!ku(n.url,t.url);case"pathParamsOrQueryParamsChange":return!ku(n.url,t.url)||!Ri(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!s1(n,t)||!Ri(n.queryParams,t.queryParams);default:return!s1(n,t)}}(i,o,o.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new uL(r)):(o.data=i.data,o._resolvedData=i._resolvedData),Yp(n,t,o.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new wb(a.outlet.component,i))}else i&&Zp(t,a,s),s.canActivateChecks.push(new uL(r)),Yp(n,null,o.component?a?a.children:null:e,r,s)})(i,o[i.value.outlet],e,r.concat([i.value]),s),delete o[i.value.outlet]}),Br(o,(i,a)=>Zp(i,e.getContext(a),s)),s}function Zp(n,t,e){const r=vd(n),s=n.value;Br(r,(o,i)=>{Zp(o,s.component?t?t.children.getContext(i):null:t,e)}),e.canDeactivateChecks.push(new wb(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}class joe{}function cL(n){return new sr(t=>t.error(n))}class Koe{constructor(t,e,r,s,o,i){this.rootComponentType=t,this.config=e,this.urlTree=r,this.url=s,this.paramsInheritanceStrategy=o,this.relativeLinkResolution=i}recognize(){const t=bb(this.urlTree.root,[],[],this.config.filter(i=>void 0===i.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,St);if(null===e)return null;const r=new fb([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},St,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new xa(r,e),o=new qP(this.url,s);return this.inheritParamsAndData(o._root),o}inheritParamsAndData(t){const e=t.value,r=jP(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(t,e,r){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,r)}processChildren(t,e){const r=[];for(const o of Object.keys(e.children)){const i=e.children[o],a=rL(t,o),l=this.processSegmentGroup(a,i,o);if(null===l)return null;r.push(...l)}const s=dL(r);return function Xoe(n){n.sort((t,e)=>t.value.outlet===St?-1:e.value.outlet===St?1:t.value.outlet.localeCompare(e.value.outlet))}(s),s}processSegment(t,e,r,s){for(const o of t){const i=this.processSegmentAgainstRoute(o,e,r,s);if(null!==i)return i}return iL(e,r,s)?[]:null}processSegmentAgainstRoute(t,e,r,s){if(t.redirectTo||!oL(t,e,r,s))return null;let o,i=[],a=[];if("**"===t.path){const p=r.length>0?RP(r).parameters:{};o=new fb(r,p,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,fL(t),Io(t),t.component,t,hL(e),pL(e)+r.length,mL(t))}else{const p=yb(e,t,r);if(!p.matched)return null;i=p.consumedSegments,a=p.remainingSegments,o=new fb(i,p.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,fL(t),Io(t),t.component,t,hL(e),pL(e)+i.length,mL(t))}const l=function Yoe(n){return n.children?n.children:n.loadChildren?n._loadedConfig.routes:[]}(t),{segmentGroup:u,slicedSegments:c}=bb(e,i,a,l.filter(p=>void 0===p.redirectTo),this.relativeLinkResolution);if(0===c.length&&u.hasChildren()){const p=this.processChildren(l,u);return null===p?null:[new xa(o,p)]}if(0===l.length&&0===c.length)return[new xa(o,[])];const d=Io(t)===s,h=this.processSegment(l,u,c,d?St:s);return null===h?null:[new xa(o,h)]}}function Zoe(n){const t=n.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function dL(n){const t=[],e=new Set;for(const r of n){if(!Zoe(r)){t.push(r);continue}const s=t.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):t.push(r)}for(const r of e){const s=dL(r.children);t.push(new xa(r.value,s))}return t.filter(r=>!e.has(r))}function hL(n){let t=n;for(;t._sourceSegment;)t=t._sourceSegment;return t}function pL(n){let t=n,e=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,e+=t._segmentIndexShift?t._segmentIndexShift:0;return e-1}function fL(n){return n.data||{}}function mL(n){return n.resolve||{}}function gL(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}function h1(n){return Cu(t=>{const e=n(t);return e?Xr(e).pipe(bn(()=>t)):dt(t)})}class oie extends class sie{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const p1=new Qe("ROUTES");class yL{constructor(t,e,r,s){this.injector=t,this.compiler=e,this.onLoadStartListener=r,this.onLoadEndListener=s}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&&this.onLoadStartListener(e);const s=this.loadModuleFactory(e.loadChildren).pipe(bn(o=>{this.onLoadEndListener&&this.onLoadEndListener(e);const i=o.create(t);return new u1(AP(i.injector.get(p1,void 0,et.Self|et.Optional)).map(c1),i)}),il(o=>{throw e._loader$=void 0,o}));return e._loader$=new yse(s,()=>new go).pipe(wP()),e._loader$}loadModuleFactory(t){return $i(t()).pipe(Nr(e=>e instanceof RF?dt(e):Xr(this.compiler.compileModuleAsync(e))))}}class aie{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function lie(n){throw n}function uie(n,t,e){return t.parse("/")}function bL(n,t){return dt(null)}const cie={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},die={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Qs=(()=>{class n{constructor(e,r,s,o,i,a,l){this.rootComponentType=e,this.urlSerializer=r,this.rootContexts=s,this.location=o,this.config=l,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new go,this.errorHandler=lie,this.malformedUriErrorHandler=uie,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:bL,afterPreactivation:bL},this.urlHandlingStrategy=new aie,this.routeReuseStrategy=new oie,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=i.get(ga),this.console=i.get(dte);const d=i.get(Cn);this.isNgZoneEnabled=d instanceof Cn&&Cn.isInAngularZone(),this.resetConfig(l),this.currentUrlTree=function Pse(){return new Iu(new Dt([],{}),{},null)}(),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new yL(i,a,h=>this.triggerEvent(new EP(h)),h=>this.triggerEvent(new IP(h))),this.routerState=HP(this.currentUrlTree,this.rootComponentType),this.transitions=new Eo({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){var e;return null===(e=this.location.getState())||void 0===e?void 0:e.\u0275routerPageId}setupNavigations(e){const r=this.events;return e.pipe(Eu(s=>0!==s.id),bn(s=>Object.assign(Object.assign({},s),{extractedUrl:this.urlHandlingStrategy.extract(s.rawUrl)})),Cu(s=>{let o=!1,i=!1;return dt(s).pipe(Zs(a=>{this.currentNavigation={id:a.id,initialUrl:a.currentRawUrl,extractedUrl:a.extractedUrl,trigger:a.source,extras:a.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Cu(a=>{const l=this.browserUrlTree.toString(),u=!this.navigated||a.extractedUrl.toString()!==l||l!==this.currentUrlTree.toString();if(("reload"===this.onSameUrlNavigation||u)&&this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl))return _L(a.source)&&(this.browserUrlTree=a.extractedUrl),dt(a).pipe(Cu(d=>{const h=this.transitions.getValue();return r.next(new ZT(d.id,this.serializeUrl(d.extractedUrl),d.source,d.restoredState)),h!==this.transitions.getValue()?ia:Promise.resolve(d)}),function Roe(n,t,e,r){return Cu(s=>function Noe(n,t,e,r,s){return new Doe(n,t,e,r,s).apply()}(n,t,e,s.extractedUrl,r).pipe(bn(o=>Object.assign(Object.assign({},s),{urlAfterRedirects:o}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),Zs(d=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:d.urlAfterRedirects})}),function Qoe(n,t,e,r,s){return Nr(o=>function qoe(n,t,e,r,s="emptyOnly",o="legacy"){try{const i=new Koe(n,t,e,r,s,o).recognize();return null===i?cL(new joe):dt(i)}catch(i){return cL(i)}}(n,t,o.urlAfterRedirects,e(o.urlAfterRedirects),r,s).pipe(bn(i=>Object.assign(Object.assign({},o),{targetSnapshot:i}))))}(this.rootComponentType,this.config,d=>this.serializeUrl(d),this.paramsInheritanceStrategy,this.relativeLinkResolution),Zs(d=>{if("eager"===this.urlUpdateStrategy){if(!d.extras.skipLocationChange){const p=this.urlHandlingStrategy.merge(d.urlAfterRedirects,d.rawUrl);this.setBrowserUrl(p,d)}this.browserUrlTree=d.urlAfterRedirects}const h=new Tse(d.id,this.serializeUrl(d.extractedUrl),this.serializeUrl(d.urlAfterRedirects),d.targetSnapshot);r.next(h)}));if(u&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:h,extractedUrl:p,source:f,restoredState:m,extras:g}=a,y=new ZT(h,this.serializeUrl(p),f,m);r.next(y);const b=HP(p,this.rootComponentType).snapshot;return dt(Object.assign(Object.assign({},a),{targetSnapshot:b,urlAfterRedirects:p,extras:Object.assign(Object.assign({},g),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=a.rawUrl,a.resolve(null),ia}),h1(a=>{const{targetSnapshot:l,id:u,extractedUrl:c,rawUrl:d,extras:{skipLocationChange:h,replaceUrl:p}}=a;return this.hooks.beforePreactivation(l,{navigationId:u,appliedUrlTree:c,rawUrlTree:d,skipLocationChange:!!h,replaceUrl:!!p})}),Zs(a=>{const l=new Cse(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.triggerEvent(l)}),bn(a=>Object.assign(Object.assign({},a),{guards:$oe(a.targetSnapshot,a.currentSnapshot,this.rootContexts)})),function Loe(n,t){return Nr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=e;return 0===i.length&&0===o.length?dt(Object.assign(Object.assign({},e),{guardsResult:!0})):function Voe(n,t,e,r){return Xr(n).pipe(Nr(s=>function Hoe(n,t,e,r,s){const o=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return o&&0!==o.length?dt(o.map(a=>{const l=xb(a,t,s);let u;if(function boe(n){return n&&al(n.canDeactivate)}(l))u=$i(l.canDeactivate(n,t,e,r));else{if(!al(l))throw new Error("Invalid CanDeactivate guard");u=$i(l(n,t,e,r))}return u.pipe(bd())})).pipe(qp()):dt(!0)}(s.component,s.route,e,t,r)),bd(s=>!0!==s,!0))}(i,r,s,n).pipe(Nr(a=>a&&function foe(n){return"boolean"==typeof n}(a)?function Boe(n,t,e,r){return Xr(t).pipe(Bp(s=>KT(function Uoe(n,t){return null!==n&&t&&t(new Nse(n)),dt(!0)}(s.route.parent,r),function zoe(n,t){return null!==n&&t&&t(new Ase(n)),dt(!0)}(s.route,r),function Goe(n,t,e){const r=t[t.length-1],o=t.slice(0,t.length-1).reverse().map(i=>function Ooe(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(i)).filter(i=>null!==i).map(i=>vP(()=>dt(i.guards.map(l=>{const u=xb(l,i.node,e);let c;if(function yoe(n){return n&&al(n.canActivateChild)}(u))c=$i(u.canActivateChild(r,n));else{if(!al(u))throw new Error("Invalid CanActivateChild guard");c=$i(u(r,n))}return c.pipe(bd())})).pipe(qp())));return dt(o).pipe(qp())}(n,s.path,e),function Woe(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return dt(!0);const s=r.map(o=>vP(()=>{const i=xb(o,t,e);let a;if(function goe(n){return n&&al(n.canActivate)}(i))a=$i(i.canActivate(t,n));else{if(!al(i))throw new Error("Invalid CanActivate guard");a=$i(i(t,n))}return a.pipe(bd())}));return dt(s).pipe(qp())}(n,s.route,e))),bd(s=>!0!==s,!0))}(r,o,n,t):dt(a)),bn(a=>Object.assign(Object.assign({},e),{guardsResult:a})))})}(this.ngModule.injector,a=>this.triggerEvent(a)),Zs(a=>{if(Nu(a.guardsResult)){const u=QT(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`);throw u.url=a.guardsResult,u}const l=new Ese(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot,!!a.guardsResult);this.triggerEvent(l)}),Eu(a=>!!a.guardsResult||(this.restoreHistory(a),this.cancelNavigationTransition(a,""),!1)),h1(a=>{if(a.guards.canActivateChecks.length)return dt(a).pipe(Zs(l=>{const u=new Ise(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(u)}),Cu(l=>{let u=!1;return dt(l).pipe(function Joe(n,t){return Nr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return dt(e);let o=0;return Xr(s).pipe(Bp(i=>function eie(n,t,e,r){return function tie(n,t,e,r){const s=gL(n);if(0===s.length)return dt({});const o={};return Xr(s).pipe(Nr(i=>function nie(n,t,e,r){const s=xb(n,t,r);return $i(s.resolve?s.resolve(t,e):s(t,e))}(n[i],t,e,r).pipe(Zs(a=>{o[i]=a}))),YT(1),Nr(()=>gL(o).length===s.length?dt(o):ia))}(n._resolve,n,t,r).pipe(bn(o=>(n._resolvedData=o,n.data=Object.assign(Object.assign({},n.data),jP(n,e).resolve),null)))}(i.route,r,n,t)),Zs(()=>o++),YT(1),Nr(i=>o===s.length?dt(e):ia))})}(this.paramsInheritanceStrategy,this.ngModule.injector),Zs({next:()=>u=!0,complete:()=>{u||(this.restoreHistory(l),this.cancelNavigationTransition(l,"At least one route resolver didn't emit any value."))}}))}),Zs(l=>{const u=new kse(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(u)}))}),h1(a=>{const{targetSnapshot:l,id:u,extractedUrl:c,rawUrl:d,extras:{skipLocationChange:h,replaceUrl:p}}=a;return this.hooks.afterPreactivation(l,{navigationId:u,appliedUrlTree:c,rawUrlTree:d,skipLocationChange:!!h,replaceUrl:!!p})}),bn(a=>{const l=function toe(n,t,e){const r=Gp(n,t._root,e?e._root:void 0);return new GP(r,t)}(this.routeReuseStrategy,a.targetSnapshot,a.currentRouterState);return Object.assign(Object.assign({},a),{targetRouterState:l})}),Zs(a=>{this.currentUrlTree=a.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(a.urlAfterRedirects,a.rawUrl),this.routerState=a.targetRouterState,"deferred"===this.urlUpdateStrategy&&(a.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,a),this.browserUrlTree=a.urlAfterRedirects)}),((n,t,e)=>bn(r=>(new hoe(t,r.targetRouterState,r.currentRouterState,e).activate(n),r)))(this.rootContexts,this.routeReuseStrategy,a=>this.triggerEvent(a)),Zs({next(){o=!0},complete(){o=!0}}),function xse(n){return or((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}(()=>{var a;o||i||this.cancelNavigationTransition(s,`Navigation ID ${s.id} is not equal to the current navigation id ${this.navigationId}`),(null===(a=this.currentNavigation)||void 0===a?void 0:a.id)===s.id&&(this.currentNavigation=null)}),il(a=>{if(i=!0,function Ose(n){return n&&n[NP]}(a)){const l=Nu(a.url);l||(this.navigated=!0,this.restoreHistory(s,!0));const u=new CP(s.id,this.serializeUrl(s.extractedUrl),a.message);r.next(u),l?setTimeout(()=>{const c=this.urlHandlingStrategy.merge(a.url,this.rawUrlTree),d={skipLocationChange:s.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||_L(s.source)};this.scheduleNavigation(c,"imperative",null,d,{resolve:s.resolve,reject:s.reject,promise:s.promise})},0):s.resolve(!1)}else{this.restoreHistory(s,!0);const l=new Sse(s.id,this.serializeUrl(s.extractedUrl),a);r.next(l);try{s.resolve(this.errorHandler(a))}catch(u){s.reject(u)}}return ia}))}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.transitions.value),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{var s;const o={replaceUrl:!0},i=(null===(s=e.state)||void 0===s?void 0:s.navigationId)?e.state:null;if(i){const l=Object.assign({},i);delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(o.state=l)}const a=this.parseUrl(e.url);this.scheduleNavigation(a,r,i,o)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){nL(e),this.config=e.map(c1),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,u=s||this.routerState.root,c=l?this.currentUrlTree.fragment:i;let d=null;switch(a){case"merge":d=Object.assign(Object.assign({},this.currentUrlTree.queryParams),o);break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=o||null}return null!==d&&(d=this.removeEmptyProps(d)),function soe(n,t,e,r,s){if(0===e.length)return o1(t.root,t.root,t.root,r,s);const o=function ooe(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new YP(!0,0,n);let t=0,e=!1;const r=n.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return Br(o.outlets,(l,u)=>{a[u]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new YP(e,t,r)}(e);if(o.toRoot())return o1(t.root,t.root,new Dt([],{}),r,s);const i=function ioe(n,t,e){if(n.isAbsolute)return new a1(t.root,!0,0);if(-1===e.snapshot._lastPathIndex){const o=e.snapshot._urlSegment;return new a1(o,o===t.root,0)}const r=mb(n.commands[0])?0:1;return function aoe(n,t,e){let r=n,s=t,o=e;for(;o>s;){if(o-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new a1(r,!1,s-o)}(e.snapshot._urlSegment,e.snapshot._lastPathIndex+r,n.numberOfDoubleDots)}(o,t,n),a=i.processChildren?gb(i.segmentGroup,i.index,o.commands):ZP(i.segmentGroup,i.index,o.commands);return o1(t.root,i.segmentGroup,a,r,s)}(u,this.currentUrlTree,e,d,null!=c?c:null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=Nu(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,"imperative",null,r)}navigate(e,r={skipLocationChange:!1}){return function hie(n){for(let t=0;t<n.length;t++){const e=n[t];if(null==e)throw new Error(`The requested path contains ${e} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?Object.assign({},cie):!1===r?Object.assign({},die):r,Nu(e))return OP(this.currentUrlTree,e,s);const o=this.parseUrl(e);return OP(this.currentUrlTree,o,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const o=e[s];return null!=o&&(r[s]=o),r},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new zp(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,r,s,o,i){var a,l;if(this.disposed)return Promise.resolve(!1);let u,c,d;i?(u=i.resolve,c=i.reject,d=i.promise):d=new Promise((f,m)=>{u=f,c=m});const h=++this.navigationId;let p;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(s=this.location.getState()),p=s&&s.\u0275routerPageId?s.\u0275routerPageId:o.replaceUrl||o.skipLocationChange?null!==(a=this.browserPageId)&&void 0!==a?a:0:(null!==(l=this.browserPageId)&&void 0!==l?l:0)+1):p=0,this.setTransition({id:h,targetPageId:p,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:o,resolve:u,reject:c,promise:d,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),d.catch(f=>Promise.reject(f))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),o=Object.assign(Object.assign({},r.extras.state),this.generateNgRouterState(r.id,r.targetPageId));this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",o):this.location.go(s,"",o)}restoreHistory(e,r=!1){var s,o;if("computed"===this.canceledNavigationResolution){const i=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==(null===(s=this.currentNavigation)||void 0===s?void 0:s.finalUrl)||0===i?this.currentUrlTree===(null===(o=this.currentNavigation)||void 0===o?void 0:o.finalUrl)&&0===i&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(i)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,r){const s=new CP(e.id,this.serializeUrl(e.extractedUrl),r);this.triggerEvent(s),e.resolve(!1)}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){DS()},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();function _L(n){return"imperative"!==n}class vL{}class wL{preload(t,e){return dt(null)}}let xL=(()=>{class n{constructor(e,r,s,o){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=new yL(s,r,l=>e.triggerEvent(new EP(l)),l=>e.triggerEvent(new IP(l)))}setUpPreloading(){this.subscription=this.router.events.pipe(Eu(e=>e instanceof zp),Bp(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(ga);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const o of r)if(o.loadChildren&&!o.canLoad&&o._loadedConfig){const i=o._loadedConfig;s.push(this.processRoutes(i.module,i.routes))}else o.loadChildren&&!o.canLoad?s.push(this.preloadConfig(e,o)):o.children&&s.push(this.processRoutes(e,o.children));return Xr(s).pipe(zh(),bn(o=>{}))}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>(r._loadedConfig?dt(r._loadedConfig):this.loader.load(e.injector,r)).pipe(Nr(o=>(r._loadedConfig=o,this.processRoutes(o.module,o.routes)))))}}return n.\u0275fac=function(e){return new(e||n)(Ce(Qs),Ce(mM),Ce(Ys),Ce(vL))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})(),g1=(()=>{class n{constructor(e,r,s={}){this.router=e,this.viewportScroller=r,this.options=s,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},s.scrollPositionRestoration=s.scrollPositionRestoration||"disabled",s.anchorScrolling=s.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof ZT?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof zp&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof kP&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.router.triggerEvent(new kP(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return n.\u0275fac=function(e){DS()},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();const Du=new Qe("ROUTER_CONFIGURATION"),SL=new Qe("ROUTER_FORROOT_GUARD"),gie=[kT,{provide:LP,useClass:VP},{provide:Qs,useFactory:function wie(n,t,e,r,s,o,i={},a,l){const u=new Qs(null,n,t,e,r,s,AP(o));return a&&(u.urlHandlingStrategy=a),l&&(u.routeReuseStrategy=l),function xie(n,t){n.errorHandler&&(t.errorHandler=n.errorHandler),n.malformedUriErrorHandler&&(t.malformedUriErrorHandler=n.malformedUriErrorHandler),n.onSameUrlNavigation&&(t.onSameUrlNavigation=n.onSameUrlNavigation),n.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=n.paramsInheritanceStrategy),n.relativeLinkResolution&&(t.relativeLinkResolution=n.relativeLinkResolution),n.urlUpdateStrategy&&(t.urlUpdateStrategy=n.urlUpdateStrategy),n.canceledNavigationResolution&&(t.canceledNavigationResolution=n.canceledNavigationResolution)}(i,u),i.enableTracing&&u.events.subscribe(c=>{var d,h;null===(d=console.group)||void 0===d||d.call(console,`Router Event: ${c.constructor.name}`),console.log(c.toString()),console.log(c),null===(h=console.groupEnd)||void 0===h||h.call(console)}),u},deps:[LP,Kp,kT,Ys,mM,p1,Du,[class iie{},new Ja],[class rie{},new Ja]]},Kp,{provide:wd,useFactory:function Sie(n){return n.routerState.root},deps:[Qs]},xL,wL,class mie{preload(t,e){return e().pipe(il(()=>dt(null)))}},{provide:Du,useValue:{enableTracing:!1}}];function yie(){return new vM("Router",Qs)}let TL=(()=>{class n{constructor(e,r){}static forRoot(e,r){return{ngModule:n,providers:[gie,CL(e),{provide:SL,useFactory:vie,deps:[[Qs,new Ja,new op]]},{provide:Du,useValue:r||{}},{provide:yd,useFactory:_ie,deps:[Tu,[new ay(IT),new Ja],Du]},{provide:g1,useFactory:bie,deps:[Qs,vre,Du]},{provide:vL,useExisting:r&&r.preloadingStrategy?r.preloadingStrategy:wL},{provide:vM,multi:!0,useFactory:yie},[y1,{provide:cT,multi:!0,useFactory:Tie,deps:[y1]},{provide:EL,useFactory:Cie,deps:[y1]},{provide:fM,multi:!0,useExisting:EL}]]}}static forChild(e){return{ngModule:n,providers:[CL(e)]}}}return n.\u0275fac=function(e){return new(e||n)(Ce(SL,8),Ce(Qs,8))},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({}),n})();function bie(n,t,e){return e.scrollOffset&&t.setOffset(e.scrollOffset),new g1(n,t,e)}function _ie(n,t,e={}){return e.useHash?new rne(n,t):new VM(n,t)}function vie(n){return"guarded"}function CL(n){return[{provide:z9,multi:!0,useValue:n},{provide:p1,multi:!0,useValue:n}]}let y1=(()=>{class n{constructor(e){this.injector=e,this.initNavigation=!1,this.destroyed=!1,this.resultOfPreactivationDone=new go}appInitializer(){return this.injector.get(ene,Promise.resolve(null)).then(()=>{if(this.destroyed)return Promise.resolve(!0);let r=null;const s=new Promise(a=>r=a),o=this.injector.get(Qs),i=this.injector.get(Du);return"disabled"===i.initialNavigation?(o.setUpLocationChangeListener(),r(!0)):"enabled"===i.initialNavigation||"enabledBlocking"===i.initialNavigation?(o.hooks.afterPreactivation=()=>this.initNavigation?dt(null):(this.initNavigation=!0,r(!0),this.resultOfPreactivationDone),o.initialNavigation()):r(!0),s})}bootstrapListener(e){const r=this.injector.get(Du),s=this.injector.get(xL),o=this.injector.get(g1),i=this.injector.get(Qs),a=this.injector.get(vT);e===a.components[0]&&(("enabledNonBlocking"===r.initialNavigation||void 0===r.initialNavigation)&&i.initialNavigation(),s.setUpPreloading(),o.init(),i.resetRootComponentType(a.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}ngOnDestroy(){this.destroyed=!0}}return n.\u0275fac=function(e){return new(e||n)(Ce(Ys))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();function Tie(n){return n.appInitializer.bind(n)}function Cie(n){return n.bootstrapListener.bind(n)}const EL=new Qe("Router Initializer"),Iie=[];let kie=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({imports:[[TL.forRoot(Iie)],TL]}),n})();function IL(n,t,e,r,s,o,i){try{var a=n[o](i),l=a.value}catch(u){return void e(u)}a.done?t(l):Promise.resolve(l).then(r,s)}function $(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var o=n.apply(t,e);function i(l){IL(o,r,s,i,a,"next",l)}function a(l){IL(o,r,s,i,a,"throw",l)}i(void 0)})}}class Aie{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class kL{refCount(t){return Js("refCount")}incRef(t){return Js("incRef")}timerAvailable(){return!0}time(t){return Js("time")}read(t){return Js("read")}readSync(t){return Js("readSync")}readToGPU(t,e){return Js("readToGPU")}numDataIds(){return Js("numDataIds")}disposeData(t,e){return Js("disposeData")}write(t,e,r){return Js("write")}move(t,e,r,s,o){return Js("move")}memory(){return Js("memory")}floatPrecision(){return Js("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Js("dispose")}}function Js(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function NL(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Sb(n,t,e)}function Rie(n,t){if(n.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${t.length}`);let e=n.length,r=0;for(;e>0;)r=Math.random()*e|0,e--,Sb(n,e,r),Sb(t,e,r)}function Qp(n,t,e){return Math.max(n,Math.min(t,e))}function $ie(n){return n%2==0?n:n+1}function Sb(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function Oie(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function Fie(n,t){const e=Math.random();return t*e+(1-e)*n}function Mie(n,t){let e=0;for(let r=0;r<n.length;r++){const s=Number(n[r])-Number(t[r]);e+=s*s}return e}function D(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Jr(n,t,e=""){D(Oi(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Au(n){D(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function Ru(n,t=[],e=!1){if(null==t&&(t=[]),Array.isArray(n)||zr(n)&&!e)for(let r=0;r<n.length;++r)Ru(n[r],t,e);else t.push(n);return t}function gn(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Pie(n){return 0===n.length}function Oi(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Sd(n){return n%1==0}function Lie(n){if(null!=Math.tanh)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const t=Math.exp(2*n);return(t-1)/(t+1)}}function Vie(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Bie(n){const t=new Uint32Array(n);for(let e=0;e<n;++e)t[e]=e;return NL(t),t}function Jp(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function zie(n,t=(s=>0),e,r=setTimeout){return new Promise((s,o)=>{let i=0;const a=()=>{if(n())return void s();i++;const l=t(i);null!=e&&i>=e?o():r(a,l)};a()})}function Uie(n,t){let e=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)e*=n[o];else if(-1===n[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function ef(n,t){const e=t.length;return D((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),D(n.every(r=>Sd(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function DL(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||s?null:ef(t,n).sort();let i=0;for(let a=0;a<n.length;++a){if(null!=o){if(o[i]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),o[i]<=a&&i++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function AL(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);e=new Uint8Array(t)}return e}function RL(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function $L(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function OL(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}function Wie(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function zr(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function b1(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function FL(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function ll(n){return"string"==typeof n||n instanceof String}function ML(n){return"boolean"==typeof n}function PL(n){return"number"==typeof n}function Tb(n){return Array.isArray(n)?Tb(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":PL(n)?"float32":ll(n)?"string":ML(n)?"bool":"float32"}function ul(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Cb(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Td(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function LL(n,t,e,r=!1){const s=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=e[n+i]}else{const o=t[0],i=t.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=LL(n+l*a,i,e,r)}return s}function $u(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,o)=>s*o)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return LL(0,n,t,e)}function _1(n,t){const e=Eb(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Eb(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function Gie(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return $u(n,new Float32Array(e));if("int32"===t)return $u(n,new Int32Array(e));if("bool"===t)return $u(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function v1(n){n.forEach(t=>{D(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Hie(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function jie(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function Ou(n){return n&&n.then&&"function"==typeof n.then}const VL="tfjsflags";class BL{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=qie,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(at().getBool("IS_TEST")||at().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];at().getBool("IS_TEST")||at().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return $(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Ou(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);VL in t&&t[VL].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function Xie(n,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}(s,o)})}}function qie(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function Kie(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function at(){return w1}let x1,w1=null;function zL(){if(null==x1){let n;if("undefined"!=typeof window)n=window;else if("undefined"!=typeof global)n=global;else if("undefined"!=typeof process)n=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}x1=n}return x1}function S1(n,t){const e=function Zie(){const n=zL();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const UL="Abs",WL="Acos",GL="Acosh",T1="Add",HL="AddN",jL="All",qL="Any",KL="ArgMax",XL="ArgMin",YL="Asin",ZL="Asinh",QL="Atan",JL="Atanh",e3="Atan2",t3="AvgPool",Qie="AvgPoolGrad",n3="AvgPool3D",Jie="AvgPool3DGrad",r3="BatchMatMul",s3="BatchToSpaceND",o3="Bincount",eae="BroadcastTo",a3="BroadcastArgs",C1="Cast",l3="Ceil",u3="ClipByValue",c3="Complex",d3="ComplexAbs",h3="Concat",p3="Conv2D",f3="Conv2DBackpropFilter",m3="Conv2DBackpropInput",g3="Conv3D",tae="Conv3DBackpropFilterV2",y3="Conv3DBackpropInputV2",b3="Cos",_3="Cosh",v3="Cumprod",w3="Cumsum",x3="CropAndResize",S3="DenseBincount",T3="DepthToSpace",C3="DepthwiseConv2dNative",E3="DepthwiseConv2dNativeBackpropFilter",I3="DepthwiseConv2dNativeBackpropInput",k3="Diag",N3="Dilation2D",nae="Dilation2DBackpropInput",rae="Dilation2DBackpropFilter",D3="RealDiv",A3="Einsum",R3="Elu",sae="EluGrad",$3="Erf",O3="Equal",F3="Exp",M3="ExpandDims",P3="Expm1",L3="FFT",V3="Fill",B3="FlipLeftRight",z3="Floor",U3="FloorDiv",W3="FusedBatchNorm",G3="GatherV2",H3="GatherNd",j3="Greater",q3="GreaterEqual",E1="Identity",K3="IFFT",X3="Imag",Y3="IsFinite",Z3="IsInf",Q3="IsNan",J3="LeakyRelu",eV="Less",tV="LessEqual",nV="LinSpace",rV="Log",sV="Log1p",oV="LogicalAnd",iV="LogicalNot",aV="LogicalOr",oae="LogicalXor",iae="LogSoftmax",aae="LowerBound",lV="LRN",lae="LRNGrad",uV="Max",cV="Maximum",dV="MaxPool",uae="MaxPoolGrad",hV="MaxPool3D",cae="MaxPool3DGrad",pV="MaxPoolWithArgmax",fV="Mean",mV="Min",gV="Minimum",yV="MirrorPad",bV="Mod",_V="Multinomial",vV="Multiply",wV="Neg",xV="NotEqual",SV="NonMaxSuppressionV3",TV="NonMaxSuppressionV4",CV="NonMaxSuppressionV5",EV="OnesLike",IV="OneHot",kV="Pack",NV="PadV2",dae="Pool",DV="Pow",AV="Prelu",RV="Prod",$V="RaggedGather",OV="RaggedTensorToTensor",FV="Range",MV="Real",PV="Reciprocal",LV="Relu",VV="Reshape",BV="ResizeNearestNeighbor",hae="ResizeNearestNeighborGrad",zV="ResizeBilinear",pae="ResizeBilinearGrad",UV="Relu6",WV="Reverse",GV="Round",HV="Rsqrt",jV="ScatterNd",qV="SearchSorted",KV="Select",XV="Selu",YV="Slice",ZV="Sin",QV="Sinh",JV="Sign",eB="Sigmoid",tB="Softplus",nB="Sqrt",rB="Sum",sB="SpaceToBatchND",oB="SplitV",iB="Softmax",aB="SparseFillEmptyRows",lB="SparseReshape",uB="SparseSegmentMean",cB="SparseSegmentSum",dB="SparseToDense",hB="SquaredDifference",fae="Square",pB="StridedSlice",fB="StringNGrams",mB="StringSplit",gB="StringToHashBucketFast",yB="Sub",bB="Tan",_B="Tanh",I1="Tile",vB="TopK",wB="Transform",Ib="Transpose",xB="Unique",SB="Unpack",TB="UnsortedSegmentSum",mae="UpperBound",CB="ZerosLike",EB="Step",k1="FromPixels",IB="RotateWithOffset",N1="_FusedMatMul",D1="FusedConv2D",A1="FusedDepthwiseConv2D";function cl(...n){at().getBool("IS_TEST")||at().getBool("PROD")||console.warn(...n)}function gae(...n){at().getBool("IS_TEST")||at().getBool("PROD")||console.log(...n)}const Cd=S1("kernelRegistry",()=>new Map),tf=S1("gradRegistry",()=>new Map);function kb(n,t){const e=$1(n,t);return Cd.get(e)}function R1(n){return tf.get(n)}function Nb(n){const t=Cd.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===n&&e.push(i)}return e}function kB(n){const{kernelName:t,backendName:e}=n,r=$1(t,e);Cd.has(r)&&cl(`The kernel '${t}' for backend '${e}' is already registered`),Cd.set(r,n)}function yae(n){const{kernelName:t}=n;tf.has(t)&&at().getBool("DEBUG")&&cl(`Overriding the gradient for '${t}'`),tf.set(t,n)}function bae(n,t){const e=$1(n,t);if(!Cd.has(e))throw new Error(`The kernel '${n}' for backend '${t}' is not registered`);Cd.delete(e)}function _ae(n){if(!tf.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);tf.delete(n)}function vae(n,t){Nb(n).forEach(r=>{kB(Object.assign({},r,{backendName:t}))})}function $1(n,t){return`${t}_${n}`}var O1=K(658),NB=K.n(O1);const Fu=NB()||O1;function nf(n){return Fu.fromString(n,!0,16)}const DB=nf("c3a5c85c97cb3127"),Mu=nf("b492b66fbe98f273"),es=nf("9ae16a3b2f90404f");function F1(n){return n.xor(n.shru(47))}function AB(n,t,e){const r=n.slice(t,t+e);return Fu.fromBytes(Array.from(r),!0,!0)}function rn(n,t){return AB(n,t,8)}function RB(n,t){return AB(n,t,4)}function _r(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function dl(n,t,e=nf("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Db(n,t,e,r){return function wae(n,t,e,r,s,o){s=s.add(n),o=_r(o.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(e),o=o.add(_r(s,44)),[s.add(r),o.add(i)]}(rn(n,t),rn(n,t+8),rn(n,t+16),rn(n,t+24),e,r)}function Cae(n,t=n.length){const e=Fu.fromNumber(81,!0);if(t<=32)return t<=16?function xae(n,t=n.length){if(t>=8){const e=es.add(2*t),r=rn(n,0).add(es),s=rn(n,t-8);return dl(_r(s,37).mul(e).add(r),_r(r,25).add(s).mul(e),e)}if(t>=4){const e=es.add(2*t);return dl(RB(n,0).shl(3).add(t),RB(n,t-4),e)}if(t>0){const i=t+(n[t-1]<<2);return F1(es.mul(n[0]+(n[t>>1]<<8)).xor(DB.mul(i))).mul(es)}return es}(n,t):function Sae(n,t=n.length){const e=es.add(2*t),r=rn(n,0).mul(Mu),s=rn(n,8),o=rn(n,t-8).mul(e),i=rn(n,t-16).mul(es);return dl(_r(r.add(s),43).add(_r(o,30)).add(i),r.add(_r(s.add(es),18)).add(o),e)}(n,t);if(t<=64)return function Tae(n,t=n.length){const e=es.add(2*t),r=rn(n,0).mul(es),s=rn(n,8),o=rn(n,t-8).mul(e),i=rn(n,t-16).mul(es),a=_r(r.add(s),43).add(_r(o,30)).add(i),l=dl(a,r.add(_r(s.add(es),18)).add(o),e),u=rn(n,16).mul(e),c=rn(n,24),d=a.add(rn(n,t-32)).mul(e),h=l.add(rn(n,t-24)).mul(e);return dl(_r(u.add(c),43).add(_r(d,30)).add(h),u.add(_r(c.add(r),18)).add(d),e)}(n,t);let r=e,s=e.mul(Mu).add(113),o=F1(s.mul(es).add(113)).mul(es),i=[Fu.UZERO,Fu.UZERO],a=[Fu.UZERO,Fu.UZERO];r=r.mul(es).add(rn(n,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=_r(r.add(s).add(i[0]).add(rn(n,l+8)),37).mul(Mu),s=_r(s.add(i[1]).add(rn(n,l+48)),42).mul(Mu),r=r.xor(a[1]),s=s.add(i[0]).add(rn(n,l+40)),o=_r(o.add(a[0]),33).mul(Mu),i=Db(n,l,i[1].mul(Mu),r.add(a[0])),a=Db(n,l+32,o.add(a[1]),s.add(rn(n,l+16))),[o,r]=[r,o],l+=64}while(l!==u);const d=Mu.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=_r(r.add(s).add(i[0]).add(rn(n,l+8)),37).mul(d),s=_r(s.add(i[1]).add(rn(n,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(rn(n,l+40))),o=_r(o.add(a[0]),33).mul(d),i=Db(n,l,i[1].mul(d),r.add(a[0])),a=Db(n,l+32,o.add(a[1]),s.add(rn(n,l+16))),[o,r]=[r,o],dl(dl(i[0],a[0],d).add(F1(s).mul(DB)).add(o),dl(i[1],a[1],d).add(r),d)}function Eae(n,t){return"string"===t?sf(n):Ab([n],t)}function Ab(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ru(n)),at().getBool("DEBUG")&&$L(n,t),function Iae(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function rf(){return at().platform.now()}function kae(n,t){return at().platform.fetch(n,t)}function sf(n,t="utf-8"){return t=t||"utf-8",at().platform.encode(n,t)}function Rb(n,t="utf-8"){return t=t||"utf-8",at().platform.decode(n,t)}class Nae{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Aae)}profileKernel(t,e,r){let s;const o=()=>{s=r()};let i;const a=rf();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:rf()-a})}if(at().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{Dae(d,c.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:i}=t;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],o,l[2])})})}}function Dae(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class Aae{logKernelProfile(t,e,r,s,o,i){const a="number"==typeof s?Jp(`${s}ms`,9):s.error,l=Jp(t,25),u=e.rank,c=e.size,d=Jp(e.shape.toString(),14);let h="";for(const p in o){const f=o[p];if(null!=f){const m=f.shape||e.shape,g=m.length;h+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Oae(n,t,e,r){const s=Td(t),o=function Fae(n,t,e,r){const s=gn(t),o=r[r.length-1],i=new Array(o).fill(0),a=t.length,l="complex64"===e?uf(n):n;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],lf(l[c+d],0,e).length)}return i}(n,t,e,s),i=t.length,a=$b(n,t,e,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function lf(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:ll(n)?`'${n}'`:"bool"===e?OB(n):parseFloat(n.toFixed(7)).toString(),Jp(r,t)}function OB(n){return 0===n?"false":"true"}function $b(n,t,e,r,s,o=!0){const i="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[lf(uf(n)[0],0,e)]:"bool"===e?[OB(n[0])]:[n[0].toString()];if(1===l){if(a>20){let y=Array.from(n.slice(0,3*i)),b=Array.from(n.slice((a-3)*i,a*i));return"complex64"===e&&(y=uf(y),b=uf(b)),["["+y.map((_,v)=>lf(_,s[v],e)).join(", ")+", ..., "+b.map((_,v)=>lf(_,s[a-3+v],e)).join(", ")+"]"]}return["["+("complex64"===e?uf(n):Array.from(n)).map((g,y)=>lf(g,s[y],e)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...$b(n.slice(g,g+d),u,e,c,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...$b(n.slice(g,g+d),u,e,c,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...$b(n.slice(g,g+d),u,e,c,s,m===a-1))}const p=2===l?",":"";h[0]="["+h[0]+p;for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function uf(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Ob{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=gn(t),null!=r){const s=r.length;D(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||RL(e,this.size),this.strides=Td(t)}set(t,...e){0===e.length&&(e=[0]),D(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return li().makeTensor(this.values,this.shape,this.dtype)}}let li=null,Ed=null,FB=null;class En{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=gn(t),this.strides=Td(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return $(function*(){const e=yield t.data();return Ed.buffer(t.shape,t.dtype,e)})()}bufferSync(){return Ed.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return $(function*(){const e=yield t.data();return $u(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return $u(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return $(function*(){t.throwIfDisposed();const e=li().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>Rb(s))}catch(s){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),li().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=li().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>Rb(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return $(function*(){t.throwIfDisposed();const e=yield li().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(li().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Ed.print(this,t)}clone(){return this.throwIfDisposed(),Ed.clone(this)}toString(t=!1){return Oae(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ed.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),li().makeVariable(this,t,e,r)}}Object.defineProperty(En,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),function Vae(){S1("Tensor",()=>En)}();class cf extends En{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Oi(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);li().disposeTensor(this),this.dataId=t.dataId,li().incRef(this,null)}dispose(){li().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(cf,Symbol.hasInstance,{value:n=>n instanceof En&&null!=n.assign&&n.assign instanceof Function});var Fb=(()=>{return(n=Fb||(Fb={})).R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6",Fb;var n})(),Mb=(()=>{return(n=Mb||(Mb={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",Mb;var n})(),Pb=(()=>{return(n=Pb||(Pb={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",Pb;var n})(),Lb=(()=>{return(n=Lb||(Lb={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",Lb;var n})(),Vb=(()=>{return(n=Vb||(Vb={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",Vb;var n})();const Bae={float32:Lb,int32:Mb,bool:Pb,complex64:Vb};function Bb(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return Bae[n][t]}function zae(n){return Bb(n,"int32")}function In(n,t){if(n.dtype===t.dtype)return[n,t];const e=Bb(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function MB(n,t){D(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function Uae(n,t){return t.some(e=>e.id===n.id)}function P1(n){const t=[];return PB(n,t,new Set),t}function PB(n,t,e){if(null==n)return;if(n instanceof En)return void t.push(n);if(!function Wae(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const o=r[s];e.has(o)||(e.add(o),PB(o,t,e))}}function L1(n){return null!=n.kernelName}class LB{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let Gae=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new LB}ready(){var e=this;return $(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(cl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return $(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new Nae(r.backendInstance),!0})()}setupRegisteredKernels(){Nb(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Nb(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof kL||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,cl(`Initialization of backend ${e} failed`),cl(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return cl(`Initialization of backend ${e} failed`),cl(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=P.runKernel(E1,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>P.runKernel(C1,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==kb(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=L1(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(L1(e)){const{kernelName:m,inputs:g,attrs:y}=e,b=kb(m,this.backendName);D(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const _=this.backend.numDataIds();u=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const v=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,_,v);const w=v.map(S=>null!=S.rank?S:this.makeTensorFromTensorInfo(S));if(o){const S=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:m}=e,g=y=>{!o||(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,g));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}const{inputs:d,attrs:h}=e,p=L1(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),r=f.outputs):r=l()}),o&&this.addTapeNode(c,d,r,p,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=R1(e);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(D(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=e;"string"===(s=s||"float32")&&ll(e[0])&&(i=e.map(u=>sf(u)));const a=o.write(i,r,s),l=new En(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=FL(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,s,o){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},o)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:o,dtype:i}=e,a=new En(o,i,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const i=new cf(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*b1(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof cf||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*b1(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return $(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:i},u=R1(e);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const p=s[h],f=Eb(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=P1(e),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,r,s,o=!1){if(D(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(i instanceof En,()=>"The result y returned by f() must be a tensor.");const a=function Rae(n,t,e){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const o={};o[e.id]=!0;const i={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const p=u.inputs[h];r[p.id]&&(c[h]=p)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=null==s?function Hae(n){const t=_1(gn(n),"float32");return P.makeTensor(t,n,"float32")}(i.shape):s,function $ae(n,t,e,r){for(let s=t.length-1;s>=0;s--){const o=t[s],i=[];if(o.outputs.forEach(l=>{const u=n[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!Oi(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==n[c.id])n[c.id]=u;else{const d=n[c.id];n[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),jae);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return D(ul(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;D(r.every(l=>l instanceof En),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=e(...r,u),D(s.value instanceof En,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(ul(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];D(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(d.every(p=>p instanceof En),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((p,f)=>{h[f]=()=>p}),h},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return $(function*(){const s=rf(),o=yield r.backend.time(e);return o.wallMs=rf()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new LB;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function VB(){const n=zL();if(null==n._tfengine){const t=new BL(n);n._tfengine=new Gae(t)}return function Yie(n){w1=n}(n._tfengine.ENV),function Mae(n){li=n}(()=>n._tfengine),n._tfengine}const P=VB();function jae(n,t){return P.runKernel(T1,{a:n,b:t})}let V1;function Kae(n){V1=n}function Xae(n){if(void 0!==V1)return V1;if(n||function qae(){return"undefined"!=typeof navigator&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function BB(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Ds=at();function Fi(n,t){let e=n;if(zr(n))return"string"===t?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||zr(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&at().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&zB(n,r,[]),r}function zB(n,t,e){if(e=e||[],!Array.isArray(n)&&!zr(n))return void D(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);D(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),D(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)zB(n[s],r,e.concat(s))}function UB(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function E(n,t,e,r="numeric"){if(n instanceof En)return UB(r,n.dtype,t,e),n;let s=Tb(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),UB(r,s,t,e),null==n||!zr(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const o=Fi(n,s);!zr(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?Ab(n,s):Ru(n,[],!0);return P.makeTensor(a,o,s)}function df(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>E(o,`${t}[${i}]`,e,r))}Ds.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ds.registerFlag("IS_BROWSER",()=>BB()),Ds.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),Ds.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ds.registerFlag("PROD",()=>!1),Ds.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ds.getBool("DEBUG")),Ds.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ds.registerFlag("IS_TEST",()=>!1),Ds.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),Ds.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Ds.registerFlag("ENGINE_COMPILE_ONLY",()=>!1),Ds.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Ds.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const B1="__op";function M(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=B1;const s=(...o)=>{P.startScope(e);try{const i=r(...o);return Ou(i)&&console.error("Cannot return a Promise inside of tidy."),P.endScope(i),i}catch(i){throw P.endScope(null),i}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const Sa=M({complex_:function Yae(n,t){const e=E(n,"real","complex"),r=E(t,"imag","complex");return Jr(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),P.runKernel(c3,{real:e,imag:r})}});function hl(n,t,e,r){if(null==r&&(r=Tb(n)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!zr(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){v1(t);const s=gn(t),o=gn(e);D(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<e.length;++i){const a=e[i],l=i!==e.length-1||a!==gn(t.slice(i));D(e[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!zr(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?Ab(n,r):Ru(n,[],!0),P.makeTensor(n,t,r)}function ui(n,t,e){return hl(n,t,Fi(n,e),e)}const z1={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function Zae(n,t){return U1.apply(this,arguments)}function U1(){return U1=$(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(n)?n[i].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=$(function*(h){const p=yield l.bytes(),f=p.reduce((y,b)=>y+b.length,0)+4*p.length,m=new Uint8Array(f);let g=0;for(let y=0;y<p.length;y++){const b=p[y],_=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(_,g),g+=4,m.set(b,g),g+=b.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=t&&(u.group=t),e.push(u)}return{data:Qae(yield Promise.all(r)),specs:e}}),U1.apply(this,arguments)}function WB(n,t){const e={};let r,s=0;for(const o of t){const i=o.name,a=o.dtype,l=o.shape,u=gn(l);let c;if("quantization"in o){const d=o.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=z1[d.dtype],p=n.slice(s,s+u*h),f="uint8"===d.dtype?new Uint8Array(p):new Uint16Array(p);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){c=new Float32Array(f.length);for(let m=0;m<f.length;m++)c[m]=f[m]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=sle()),c=r(f)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let m=0;m<f.length;m++)c[m]=Math.round(f[m]*d.scale+d.min)}s+=u*h}else if("string"===a){const d=gn(o.shape);c=[];for(let h=0;h<d;h++){const p=new Uint32Array(n.slice(s,s+4))[0];s+=4;const f=new Uint8Array(n.slice(s,s+p));c.push(f),s+=p}}else{const d=z1[a],h=n.slice(s,s+u*d);if("float32"===a)c=new Float32Array(h);else if("int32"===a)c=new Int32Array(h);else if("bool"===a)c=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);{c=new Float32Array(h);const p=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let y=0;y<p.length;y++)p[y]=c[2*y],f[y]=c[2*y+1];const m=ui(p,l,"float32"),g=ui(f,l,"float32");e[i]=Sa(m,g),m.dispose(),g.dispose()}}s+=u*d}"complex64"!==a&&(e[i]=ui(c,l,a))}return e}function Qae(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(o=>{if(t+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const W1="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function GB(n){return W1?Buffer.byteLength(n):new Blob([n]).size}function G1(n){if(1===n.length)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function HB(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function jB(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function qB(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),r}function H1(n,t){return j1.apply(this,arguments)}function j1(){return(j1=$(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),qB(n,e,r)})).apply(this,arguments)}function hf(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:GB(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:GB(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function KB(n){const t=[];for(const e of n)t.push(...e.weights);return t}function sle(){const n=function tle(){const n=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function nle(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function rle(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i];o[i]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(s)}}class kn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==kn.instance&&(kn.instance=new kn),kn.instance}static registerSaveRouter(t){kn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){kn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return kn.getHandlers(t,"save")}static getLoadHandlers(t,e){return kn.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?kn.getInstance().loadRouters:kn.getInstance().saveRouters).forEach(i=>{const a=i(t,r);null!==a&&s.push(a)}),s}}const ole=n=>kn.registerSaveRouter(n),ile=n=>kn.registerLoadRouter(n),ale=n=>kn.getSaveHandlers(n),lle=(n,t)=>kn.getLoadHandlers(n,t),Ub="tensorflowjs",Pu="models_store",pl="model_info_store";function X1(){if(!at().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n="undefined"==typeof window?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Y1(n){const t=n.result;t.createObjectStore(Pu,{keyPath:"modelPath"}),t.createObjectStore(pl,{keyPath:"modelPath"})}let Id=(()=>{class n{constructor(e){if(this.indexedDB=X1(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return $(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return $(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const i=this.indexedDB.open(Ub,1);i.onupgradeneeded=()=>Y1(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(Pu,"readonly"),c=l.objectStore(Pu).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{const l=hf(r),u=a.transaction(pl,"readwrite");let c=u.objectStore(pl);const d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(Pu,"readwrite");const f=h.objectStore(Pu).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});f.onsuccess=()=>s({modelArtifactsInfo:l}),f.onerror=m=>{c=u.objectStore(pl);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),o(f.error)),g.onerror=y=>(a.close(),o(f.error))}},d.onerror=p=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return n.URL_SCHEME="indexeddb://",n})();const XB=n=>at().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Id.URL_SCHEME)?function ule(n){return new Id(n)}(n.slice(Id.URL_SCHEME.length)):null;kn.registerSaveRouter(XB),kn.registerLoadRouter(XB);class dle{constructor(){this.indexedDB=X1()}listModels(){var t=this;return $(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(Ub,1);s.onupgradeneeded=()=>Y1(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(pl,"readonly"),l=i.objectStore(pl).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(t){var e=this;return $(function*(){return t=function cle(n){return n.startsWith(Id.URL_SCHEME)?n.slice(Id.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const o=e.indexedDB.open(Ub,1);o.onupgradeneeded=()=>Y1(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(pl,"readwrite"),l=a.objectStore(pl),u=l.get(t);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{c=i.transaction(Pu,"readwrite");const f=c.objectStore(Pu).delete(t);f.onsuccess=()=>r(u.result.modelArtifactsInfo),f.onerror=m=>s(u.error)};d.onsuccess=h,d.onerror=p=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const Mi="/",Lu="tensorflowjs_models",YB="info",hle="model_topology",ple="weight_specs",fle="weight_data",mle="model_metadata";function ZB(n){return{info:[Lu,n,YB].join(Mi),topology:[Lu,n,hle].join(Mi),weightSpecs:[Lu,n,ple].join(Mi),weightData:[Lu,n,fle].join(Mi),modelMetadata:[Lu,n,mle].join(Mi)}}function QB(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function JB(n){const t=n.split(Mi);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Mi)}let kd=(()=>{class n{constructor(e){if(!at().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ZB(this.modelPath)}save(e){var r=this;return $(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),i=hf(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function Jae(n){if(W1)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:i}}catch(a){throw QB(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return $(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=i;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer),null!=u.trainingConfig&&(s.trainingConfig=u.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function ele(n){if(W1){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),s})()}}return n.URL_SCHEME="localstorage://",n})();const ez=n=>at().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(kd.URL_SCHEME)?function yle(n){return new kd(n)}(n.slice(kd.URL_SCHEME.length)):null;kn.registerSaveRouter(ez),kn.registerLoadRouter(ez);class ble{constructor(){D(at().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return $(function*(){const e={},r=Lu+Mi,s=Mi+YB;for(let o=0;o<t.LS.length;++o){const i=t.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(e[JB(i)]=JSON.parse(t.LS.getItem(i)))}return e})()}removeModel(t){var e=this;return $(function*(){const r=ZB(t=function gle(n){return n.startsWith(kd.URL_SCHEME)?n.slice(kd.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return QB(r),s})()}}const Nd="://";class ts{constructor(){this.managers={}}static getInstance(){return null==ts.instance&&(ts.instance=new ts),ts.instance}static registerManager(t,e){D(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(Nd)&&(t=t.slice(0,t.indexOf(Nd))),D(t.length>0,()=>"scheme must not be an empty string.");const r=ts.getInstance();D(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=ts.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(ts.getInstance().managers)}}function Wb(n){if(-1===n.indexOf(Nd))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ts.getSchemes().join(",")}`);return{scheme:n.split(Nd)[0],path:n.split(Nd)[1]}}function tz(n,t){return Z1.apply(this,arguments)}function Z1(){return(Z1=$(function*(n,t,e=!1){D(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=kn.getLoadHandlers(n);D(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),D(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],o=kn.getSaveHandlers(t);D(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),D(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const i=o[0],a=Wb(n).scheme,l=Wb(n).path,u=a===Wb(n).scheme,c=yield s.load();e&&u&&(yield ts.getManager(a).removeModel(l));const d=yield i.save(c);return e&&!u&&(yield ts.getManager(a).removeModel(l)),d.modelArtifactsInfo})).apply(this,arguments)}function _le(){return Q1.apply(this,arguments)}function Q1(){return(Q1=$(function*(){const n=ts.getSchemes(),t={};for(const e of n){const r=yield ts.getManager(e).listModels();for(const s in r)t[e+Nd+s]=r[s]}return t})).apply(this,arguments)}function vle(n){return J1.apply(this,arguments)}function J1(){return(J1=$(function*(n){const t=Wb(n);return ts.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function wle(n,t){return eC.apply(this,arguments)}function eC(){return(eC=$(function*(n,t){return tz(n,t,!1)})).apply(this,arguments)}function xle(n,t){return tC.apply(this,arguments)}function tC(){return(tC=$(function*(n,t){return tz(n,t,!0)})).apply(this,arguments)}class Sle{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){window&&at().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),this.functionRefs[r.data.index](),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(t,e)}}if(at().get("IS_BROWSER")){at().setPlatform("browser",new Sle);try{ts.registerManager(kd.URL_SCHEME,new ble)}catch(n){}try{ts.registerManager(Id.URL_SCHEME,new dle)}catch(n){}}let Dd;function Pi(n,t="float32",e){return t=t||"float32",v1(n),new Ob(n,t,e)}at().get("IS_NODE")&&!at().get("IS_BROWSER")&&at().setPlatform("node",new class Cle{constructor(){this.util=K(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=at().global.fetch?at().global.fetch(t,e):(null==Dd&&(Dd=K(410)),Dd(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const _n=M({cast_:function Ele(n,t){const e=E(n,"x","cast");if(!OL(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return P.runKernel(C1,{x:e},{dtype:t})}}),Ta=M({clone_:function Ile(n){const e={x:E(n,"x","clone","string_or_numeric")};return P.runKernel(E1,e)}});function nC(n,t=!1){console.log(n.toString(t))}function nz(n){return new Promise(t=>setTimeout(t)).then(n)}VB(),function Pae(n){Ed=n}({buffer:Pi,cast:_n,clone:Ta,print:nC});let rC=(()=>{class n{constructor(e){if(!at().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return $(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=jB(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(l.download=r.modelJsonFileName,l.href=a,yield nz(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;u.download=r.weightDataFileName,u.href=s,yield nz(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:hf(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class Ale{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return $(function*(){return new Promise((e,r)=>{const s=new FileReader;s.onload=o=>{const i=JSON.parse(o.target.result),a=i.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==i.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const u=H1(i,c=>t.loadWeights(c));e(u)},s.onerror=o=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const i of t)e.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(t),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[e,G1(i)])}loadWeightsFile(t,e){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{r(i.target.result)},o.onerror=i=>s(`Failed to weights data from file of path '${t}'.`),o.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(o=>HB(o.name)),s={};for(const o of t)o.paths.forEach(i=>{const a=HB(i);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function Ole(n){return new Ale(n)}function rz(n,t,e,r){(function i(l){D(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,u){D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),D(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=null==e?0:e,r=null==r?1:r);let s=0;return Promise.all(n.map(l=>(l.then(u=>{const c=e+ ++s/n.length*(r-e);return t(c),u}),l)))}function sz(n,t){return sC.apply(this,arguments)}function sC(){return(sC=$(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?at().platform.fetch:t.fetchFunc,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield rz(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield rz(a,t.onProgress,.5,1)})).apply(this,arguments)}function Fle(n){return oC.apply(this,arguments)}function oC(){return(oC=$(function*(n,t="",e,r){return oz(i=>sz(i,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function oz(n){return function(){var t=$(function*(e,r="",s){const o=e.map(()=>!1),i={},a=null!=s?s.map(()=>!1):[],l=[];if(e.forEach((f,m)=>{let g=0;f.weights.forEach(y=>{const _=z1["quantization"in y?y.quantization.dtype:y.dtype]*gn(y.shape),v=()=>{o[m]=!0,null==i[m]&&(i[m]=[]),i[m].push({manifestEntry:y,groupOffset:g,sizeBytes:_})};null!=s?s.forEach((w,S)=>{w===y.name&&(v(),a[S]=!0)}):v(),l.push(y.name),g+=_})}),!a.every(f=>f)){const f=s.filter((m,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const u=o.reduce((f,m,g)=>(m&&f.push(g),f),[]),c=[];u.forEach(f=>{e[f].paths.forEach(m=>{const g=r+(r.endsWith("/")?"":"/")+m;c.push(g)})});const d=yield n(c),h={};let p=0;return u.forEach(f=>{const m=e[f].paths.length;let g=0;for(let w=0;w<m;w++)g+=d[p+w].byteLength;const y=new ArrayBuffer(g),b=new Uint8Array(y);let _=0;for(let w=0;w<m;w++){const S=new Uint8Array(d[p+w]);b.set(S,_),_+=S.byteLength}i[f].forEach(w=>{const T=WB(y.slice(w.groupOffset,w.groupOffset+w.sizeBytes),[w.manifestEntry]);for(const I in T)h[I]=T[I]}),p+=m}),h});return function(e){return t.apply(this,arguments)}}()}kn.registerSaveRouter(n=>at().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(rC.URL_SCHEME)?function $le(n="model"){return new rC(n)}(n.slice(rC.URL_SCHEME.length)):null);let iz=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(D("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=at().platform.fetch,D(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return $(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i=jB(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:hf(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return $(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch(a){let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return H1(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return $(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function Lle(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||o,l=KB(e),u=[],c=[];for(const h of e)for(const p of h.paths)null!=r.weightUrlConverter?c.push(r.weightUrlConverter(p)):u.push(a+p+i);return r.weightUrlConverter&&u.push(...yield Promise.all(c)),[l,G1(yield sz(u,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function iC(n){return null!=n.match(iz.URL_SCHEME_REGEX)}const az=(n,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>iC(r)):iC(n),e)return aC(n,t)}return null};function aC(n,t){return new iz(n,t)}function Vle(n,t){return aC(n,t)}kn.registerSaveRouter(az),kn.registerLoadRouter(az);class lC{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class lz{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Ble{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function zle(n,t,e,r){const s=arguments;return new Ble(uz(...s))}function uz(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new lC(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new lC({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new lC({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function Ule(n){return new lz(n)}function Wle(n){return new lz(n)}const Wt=M({matMul_:function Gle(n,t,e=!1,r=!1){let s=E(n,"a","matMul"),o=E(t,"b","matMul");return[s,o]=In(s,o),P.runKernel(r3,{a:s,b:o},{transposeA:e,transposeB:r})}}),Gb=M({oneHot_:function Hle(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:E(n,"indices","oneHot","int32")};return P.runKernel(IV,i,{dtype:s,depth:t,onValue:e,offValue:r})}});function jle(){at().set("PROD",!0)}function qle(){at().set("DEBUG",!0)}function Kle(){at().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function cz(n){at().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Xle(){P.disposeVariables()}function Yle(){return P}function Zle(){return P.memory()}function Qle(n){return P.profile(n)}function Lt(n,t){return P.tidy(n,t)}function ws(n){P1(n).forEach(e=>e.dispose())}function Li(n){return P.keep(n)}function Jle(n){return P.time(n)}function eue(n){return P.setBackend(n)}function tue(){return P.ready()}function nue(){return P.backendName}function rue(n){P.removeBackend(n)}function sue(n){return P.findBackend(n)}function oue(n){return P.findBackendFactory(n)}function iue(n,t,e=1){return P.registerBackend(n,t,e)}function aue(){return P.backend}function lue(n,t){at().setPlatform(n,t)}!function Lae(n){FB=n}(cz);const pf=M({imag_:function uue(n){const e={input:E(n,"input","imag")};return P.runKernel(X3,e)}}),Vi=M({neg_:function cue(n){const e={x:E(n,"x","neg")};return P.runKernel(wV,e)}}),Ad=M({real_:function due(n){const e={input:E(n,"input","real")};return P.runKernel(MV,e)}}),ff=M({transpose_:function hue(n,t,e){const r=E(n,"x","transpose");if(null==t&&(t=r.shape.map((i,a)=>a).reverse()),D(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{D(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:t};return"complex64"===r.dtype?Lt(()=>{let i=Ad(r),a=pf(r);return i=P.runKernel(Ib,{x:i},o),a=P.runKernel(Ib,{x:a},o),e&&(a=Vi(a)),Sa(i,a)}):P.runKernel(Ib,s,o)}}),fue=M({confusionMatrix_:function pue(n,t,e){const r=E(n,"labels","confusionMatrix"),s=E(t,"predictions","confusionMatrix");D(null==e||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),D(1===r.rank,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),D(1===s.rank,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),D(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),D(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);const o=Gb(_n(r,"int32"),e),i=Gb(_n(s,"int32"),e),a=ff(o),l=Wt(a,i);return _n(l,"int32")}});function dz(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const o=e-1-s,i=n[o]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function uC(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],o=t.length-r-1,i=t[o];(null==s||1===s&&i>1)&&e.unshift(o)}return e}function Qn(n,t){const e=[],r=Math.max(n.length,t.length);for(let s=0;s<r;s++){let o=n[n.length-s-1];null==o&&(o=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===o)e.unshift(i);else if(1===i)e.unshift(o);else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);e.unshift(o)}}return e}function cC(n,t,e){if(Au(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Fi(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return hl(n,t,r,e)}let Vu;function hz(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if("undefined"!=typeof ImageData&&n instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&n instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement)o=!0;else if(null!=n.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(null!=kb(k1,P.backendName))return P.runKernel(k1,{pixels:n},{numChannels:t});const[u,c]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d,h;if(i)d=n.getContext("2d").getImageData(0,0,u,c).data;else if(r||e)d=n.data;else if(o||s||a){if(null==Vu)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Vu=new OffscreenCanvas(1,1).getContext("2d")}else Vu=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Vu.canvas.width=u,Vu.canvas.height=c,Vu.drawImage(n,0,0,u,c),d=Vu.getImageData(0,0,u,c).data}if(4===t)h=new Int32Array(d);else{const f=u*c;h=new Int32Array(f*t);for(let m=0;m<f;m++)for(let g=0;g<t;++g)h[m*t+g]=d[4*m+g]}return cC(h,[c,u,t],"int32")}function bue(n){return function gue(){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}()&&!(n instanceof ImageBitmap)&&function yue(n){return null!=n&&0!==n.width&&0!==n.height}(n)&&!function mue(n){return null!=n&&n.data instanceof Uint8Array}(n)}function _ue(n){return dC.apply(this,arguments)}function dC(){return(dC=$(function*(n,t=3){let e=null;if(at().getBool("WRAP_TO_IMAGEBITMAP")&&bue(n)){let r;try{r=yield createImageBitmap(n,{premultiplyAlpha:"none"})}catch(s){r=null}e=null!=r&&r.width===n.width&&r.height===n.height?r:n}else e=n;return hz(e,t)})).apply(this,arguments)}function vue(n,t){return hC.apply(this,arguments)}function hC(){return(hC=$(function*(n,t){let e=E(n,"img","toPixels");if(!(n instanceof En)){const u=e;e=_n(u,"int32"),u.dispose()}if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const[r,s]=e.shape.slice(0,2),o=2===e.rank?1:e.shape[2];if(o>4||2===o)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);const i=yield e.data(),a="float32"===e.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){const c=[0,0,0,255];for(let h=0;h<o;h++){const p=i[u*o+h];if("float32"===e.dtype){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if("int32"===e.dtype&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);1===o?(c[0]=p*a,c[1]=p*a,c[2]=p*a):c[h]=p*a}const d=4*u;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(null!=t){t.width=s,t.height=r;const u=t.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return e!==n&&e.dispose(),l})).apply(this,arguments)}const pz=M({fromPixels_:hz});function fz(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===gn(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=n.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<e;++d)u*=a[d],l.push(a[d]);const c=[...Td(n.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}function pC(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(o+" update.rank != "+(s+n.length-r));for(let i=0;i<s;++i)if(e.shape[i]!==t.shape[i])throw new Error(o+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-s;++i)if(e.shape[i+s]!==n[i+r])throw new Error(o+` updates.shape[${i+s}] (${e.shape[i+s]}) != shape[${i+s}] (${n[i+s]})`)}function fC(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}pC(e,t,n)}function mz(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,o=e.length;let i=1;for(let d=s;d<o;++d)i*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:gn(t.shape)/a,sliceSize:i,strides:[...Td(e.slice(0,s)),1],outputSize:gn(e)}}function xue(n,t,e){const r=n.shape.length;D(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),D(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)D(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Sue(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function Tue(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function gz(n,t,e,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[t]=1:(s.splice(t,0,1),s.pop());return s}function yz(n,t,e){return e<=n?e:e-(t-1)}function bz(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function Cue(n,t,e,r,s,o,i,a,l){const u=n.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&e>0){const p=t[0],f=e+1;c=_z(i,p,f,r,n),d=vz(a,p,f,s,n),h=gz(o,p,f,n)}else for(let p=0;p<u;p++)c[p]=xz(i,r,o,n,p,l),d[p]=Sz(a,s,o,n,p,l),h[p]=wz(o,p,l);return{begin:c,end:d,strides:h}}function _z(n,t,e,r,s){const o=[...s],i=bz(e,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=yz(t,e,a);let u=r[l];n&1<<l&&(u=0),o[a]=u}return o}function vz(n,t,e,r,s){const o=[...s],i=bz(e,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=yz(t,e,a);let u=r[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=Qp(0,o[a],s[a])}return o}function wz(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function xz(n,t,e,r,s,o){let i=t[s];(n&1<<s||o&1<<s||null==i)&&(i=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Qp(0,i,l-1),i}function Sz(n,t,e,r,s,o){let i=t[s];const a=e[s]||1;(n&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?Qp(0,i,l):Qp(-1,i,l-1),i}function Eue(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function Iue(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function kue(n,t,e){let r;const s=n.shape.length;let o;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(i=>{D(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((i,a)=>i>=0?i:(D(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function Nue(n,t,e,r,s,o,i,a,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!=(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<d.dims;_++)c&&0!=(1<<_&a)&&d.numAddAxisAfterEllipsis++,1<<_&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function Due(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let _=0;_<n.length;++_){if(0===h.strides[_])throw Error(`strides[${_}] must be non-zero`);const v=!!(h.shrinkAxisMask&1<<_),w=n[_];if(-1===w){g.push(v?1:-1);continue}const S=[h.beginMask&1<<_,h.endMask&1<<_],T=[h.strides[_]>0?0:-1,h.strides[_]>0?w:w-1];if(v&&h.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[_];const I=!!(h.beginMask&1<<_&&h.endMask&1<<_);if(h.beginValid&&h.endValid){if(v){const j=h.begin[_]<0?w+h.begin[_]:h.begin[_];if(h.begin[_]=j,h.end[_]=h.begin[_]+1,j<0||j>=w)throw Error(`slice index ${h.begin[_]} of dimension ${_} out of bounds.`)}else h.begin[_]=Tz(h.begin[_],0,h.strides[_],w,S,T),h.end[_]=Tz(h.end[_],1,h.strides[_],w,S,T);const F=1===h.strides[_]&&0===h.begin[_]&&h.end[_]===w;p=p&&F,f=f&&(0===_&&1===h.strides[_]||F)}else p=p&&1===h.strides[_]&&I,f=f&&(0===_&&1===h.strides[_]||I);let N,R=!1;if(h.beginValid&&h.endValid?(N=h.end[_]-h.begin[_],R=!0):v?(N=1,R=!0):I&&w>=0&&(N=h.strides[_]<0?-w:w,R=!0),R){let F;F=0===N||N<0!=h.strides[_]<0?0:Math.trunc(N/h.strides[_])+(N%h.strides[_]!=0?1:0),g.push(F)}else g.push(-1)}for(let _=0;_<h.finalShapeGatherIndices.length;++_){const v=h.finalShapeGatherIndices[_];v>=0?y.push(g[v]):-2===v&&y.push(1)}return{finalShapeSparse:y.filter((_,v)=>-2!==h.finalShapeGatherIndices[v]),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Tz(n,t,e,r,s,o){if(s[t])return e>0?o[t]:o[t+1&1];{const i=n<0?r+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}class Cz{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class fl{constructor(){this.classNameMap={}}static getMap(){return null==fl.instance&&(fl.instance=new fl),fl.instance}static register(t){fl.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ml(n){D(null!=n.className,()=>"Class being registered does not have the static className property defined."),D("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),D(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),fl.register(n)}const Ez=.1;function Rue(n,t,e){return null==e&&(e=gC()),yC(n,t,(r,s)=>bC(r,s,e))}function gC(){return 32===P.backend.floatPrecision()?.001:Ez}function yC(n,t,e){let r=!0;if((zr(n)||zr(t))&&(r=!1),zr(n)&&zr(t)&&(r=!0),r){const i=n.constructor.name,a=t.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(t)){const i=Fi(n),a=Fi(t);if(!Oi(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}const s=zr(n)?n:Ru(n),o=zr(t)?t:Ru(t);if(s.length!==o.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${o.length}.\nActual:   ${s}.\nExpected: ${o}.`);for(let i=0;i<o.length;++i){const a=s[i],l=o[i];if(!e(a,l))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${l}.\nActual:   ${s}.\nExpected: ${o}.`)}"undefined"!=typeof expect&&expect().nothing()}function $ue(n,t){n().then(()=>t.fail(),()=>t()),"undefined"!=typeof expect&&expect().nothing()}function Oue(n,t){const e="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return ll(n)||ll(n[0])||ll(t)||ll(t[0])?yC(n,e,(r,s)=>r==s):yC(n,t,(r,s)=>bC(r,s,0))}function Fue(n,t,e){if(null==e&&(e=gC()),!bC(n,t,e))throw new Error(`Numbers differ: actual === ${n}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function bC(n,t,e){return!isFinite(n)&&!isFinite(t)||!(isNaN(n)||isNaN(t)||Math.abs(n-t)>e)}function Mue(n,t,e){for(let r=0;r<n.length;r++)if(n[r]<t||n[r]>e)throw new Error(`Value out of range:${n[r]} low: ${t}, high: ${e}`)}function Pue(n,t){const e=new Float32Array(n),r=new Float32Array(t);if(e.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${e.length}`);for(let s=0;s<r.length;s++)if(e[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${e[s]} instead`)}function Iz(n){for(let t=0;t<n.length;t++){const e=n[t];Array.isArray(e)?Iz(e):n[t]=sf(e)}return n}function Lue(n){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(n),new Promise(e=>{t.addEventListener("loadeddata",r=>e(t)),t.load()})}function Vue(n){return _C.apply(this,arguments)}function _C(){return(_C=$(function*(n){yield n.play(),"requestVideoFrameCallback"in n&&(yield new Promise(t=>{n.requestVideoFrameCallback(t)}))})).apply(this,arguments)}const Bue="3.21.0",qe=M({add_:function zue(n,t){let e=E(n,"a","add"),r=E(t,"b","add");return[e,r]=In(e,r),P.runKernel(T1,{a:e,b:r})}}),vC=M({floorDiv_:function Uue(n,t){let e=E(n,"a","floorDiv"),r=E(t,"b","floorDiv");return[e,r]=In(e,r),P.runKernel(U3,{a:e,b:r})}}),sn=M({div_:function Wue(n,t){let e=E(n,"a","div"),r=E(t,"b","div");return[e,r]=In(e,r),"int32"===e.dtype&&"int32"===r.dtype?vC(e,r):P.runKernel(D3,{a:e,b:r},{})}}),xe=M({mul_:function Gue(n,t){let e=E(n,"a","mul"),r=E(t,"b","mul");return[e,r]=In(e,r),P.runKernel(vV,{a:e,b:r})}}),Bi=M({sqrt_:function Hue(n){const e={x:E(n,"x","sqrt","float32")};return P.runKernel(nB,e)}}),ko=M({square_:function jue(n){const t=E(n,"x","square");return P.runKernel("Square",{x:t},{})}}),As=M({zerosLike_:function que(n){const e={x:E(n,"x","zerosLike")};return P.runKernel(CB,e)}});function Kue(n){return D(ul(n),()=>"The f passed in grad(f) must be a function"),(t,e)=>{const r=E(t,"x","tf.grad","string_or_numeric"),s=null!=e?E(e,"dy","tf.grad"):null;return P.tidy(()=>{const{value:o,grads:i}=P.gradients(()=>n(r),[r],s);return null!=s&&Jr(o.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Hb(i),i[0]})}}function Xue(n){return D(ul(n),()=>"The f passed in grads(f) must be a function"),(t,e)=>{D(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=df(t,"args","tf.grads","string_or_numeric"),s=null!=e?E(e,"dy","tf.grads"):null;return P.tidy(()=>{const{value:o,grads:i}=P.gradients(()=>n(...r),r,s);return null!=s&&Jr(o.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Hb(i),i})}}function Yue(n){return D(ul(n),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{D(t instanceof En,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(null==e||e instanceof En,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=P.gradients(()=>n(t),[t],e);return Hb(r),{grad:r[0],value:s}}}function Zue(n){return D(ul(n),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{D(Array.isArray(t)&&t.every(s=>s instanceof En),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(null==e||e instanceof En,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=P.gradients(()=>n(...t),t,e);return null!=e&&Jr(r.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Hb(r.grads),r}}function kz(n,t){D(ul(n),()=>"The f passed in variableGrads(f) must be a function"),D(null==t||Array.isArray(t)&&t.every(u=>u instanceof cf),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const u in P.registeredVariables)t.push(P.registeredVariables[u])}const r=e?t.filter(u=>!u.trainable):null,s=t.length;D((t=t.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=P.gradients(n,t,null,!0);D(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return t.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),null!=r&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function zi(n){return P.customGrad(n)}function Hb(n){if(n.filter(e=>null==e).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function Tt(n,t){if((zr(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&zr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return hl(n,[],[],t)}class gl extends Cz{minimize(t,e=!1,r){const{value:s,grads:o}=this.computeGradients(t,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return ws(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return kz(t,e)}dispose(){null!=this.iterations_&&ws(this.iterations_)}saveIterations(){var t=this;return $(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Tt(t.iterations_,"int32")}})()}getWeights(){return $(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return $(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return $(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(gl,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});let jb=(()=>{class n extends gl{constructor(e,r,s=null){super(),this.learningRate=e,this.rho=r,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=P.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=P.registeredVariables[s];null==this.accumulatedGrads[o]&&(this.accumulatedGrads[o]={originalName:`${s}/accum_grad`,variable:Lt(()=>As(i).variable(!1))}),null==this.accumulatedUpdates[o]&&(this.accumulatedUpdates[o]={originalName:`${s}/accum_var`,variable:Lt(()=>As(i).variable(!1))});const l=Array.isArray(e)?e[o].tensor:e[s];if(null==l)return;const u=this.accumulatedGrads[o].variable,c=this.accumulatedUpdates[o].variable;Lt(()=>{const d=qe(xe(u,this.rho),xe(ko(l),1-this.rho)),h=xe(sn(Bi(qe(c,this.epsilon)),Bi(qe(u,this.epsilon))),l),p=qe(xe(c,this.rho),xe(ko(h),1-this.rho));u.assign(d),c.assign(p);const f=qe(xe(h,-this.learningRate),i);i.assign(f)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ws(this.accumulatedGrads.map(e=>e.variable)),ws(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return $(function*(){const r=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return $(function*(){const s=(e=yield r.extractIterations(e)).length/2;r.accumulatedGrads=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),r.accumulatedUpdates=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.rho,r.epsilon)}}return n.className="Adadelta",n})();function Rd(n,t,e){return P.runKernel(V3,{},{shape:n,value:t,dtype:e})}ml(jb);let qb=(()=>{class n extends gl{constructor(e,r=.1){super(),this.learningRate=e,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=P.registeredVariables[s];null==this.accumulatedGrads[o]&&(this.accumulatedGrads[o]={originalName:`${s}/accumulator`,variable:Lt(()=>Rd(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[o].tensor:e[s];if(null==a)return;const l=this.accumulatedGrads[o].variable;Lt(()=>{const u=qe(l,ko(a));l.assign(u);const c=qe(xe(sn(a,Bi(qe(u,P.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ws(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return $(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return $(function*(){e=yield r.extractIterations(e),r.accumulatedGrads=e.map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,r){return new e(r.learningRate,r.initialAccumulatorValue)}}return n.className="Adagrad",n})();ml(qb);const $d=M({pow_:function Que(n,t){let e=E(n,"base","pow"),r=E(t,"exp","pow");return[e,r]=In(e,r),P.runKernel(DV,{a:e,b:r})}}),yt=M({sub_:function Jue(n,t){let e=E(n,"a","sub"),r=E(t,"b","sub");return[e,r]=In(e,r),P.runKernel(yB,{a:e,b:r})}});let Kb=(()=>{class n extends gl{constructor(e,r,s,o=null){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Lt(()=>{this.accBeta1=Tt(r).variable(),this.accBeta2=Tt(s).variable()}),null==o&&(this.epsilon=P.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Lt(()=>{const s=yt(1,this.accBeta1),o=yt(1,this.accBeta2);r.forEach((i,a)=>{const l=P.registeredVariables[i];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:Lt(()=>As(l).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:Lt(()=>As(l).variable(!1))});const c=Array.isArray(e)?e[a].tensor:e[i];if(null==c)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,p=qe(xe(d,this.beta1),xe(c,1-this.beta1)),f=qe(xe(h,this.beta2),xe(ko(c),1-this.beta2)),m=sn(p,s),g=sn(f,o);d.assign(p),h.assign(f);const y=qe(xe(sn(m,qe(Bi(g),this.epsilon)),-this.learningRate),l);l.assign(y)}),this.accBeta1.assign(xe(this.accBeta1,this.beta1)),this.accBeta2.assign(xe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ws(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&ws(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return $(function*(){const r=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return $(function*(){e=yield r.extractIterations(e),Lt(()=>{r.accBeta1.assign($d(r.beta1,r.iterations_+1)),r.accBeta2.assign($d(r.beta2,r.iterations_+1))});const s=e.length/2;r.accumulatedFirstMoment=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),r.accumulatedSecondMoment=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)}}return n.className="Adam",n})();ml(Kb);const Rs=M({abs_:function ece(n){const t=E(n,"x","abs");return P.runKernel("complex64"===t.dtype?d3:UL,{x:t})}}),wC=M({maximum_:function tce(n,t){let e=E(n,"a","maximum"),r=E(t,"b","maximum");return[e,r]=In(e,r),"bool"===e.dtype&&(e=_n(e,"int32"),r=_n(r,"int32")),Qn(e.shape,r.shape),P.runKernel(cV,{a:e,b:r})}});let Xb=(()=>{class n extends gl{constructor(e,r,s,o=null,i=0){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=o,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Lt(()=>{this.iteration=Tt(0).variable(),this.accBeta1=Tt(r).variable()}),null==o&&(this.epsilon=P.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Lt(()=>{const s=yt(1,this.accBeta1),o=sn(-this.learningRate,qe(xe(this.iteration,this.decay),1));r.forEach((i,a)=>{const l=P.registeredVariables[i];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:As(l).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:As(l).variable(!1)});const c=Array.isArray(e)?e[a].tensor:e[i];if(null==c)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,p=qe(xe(d,this.beta1),xe(c,1-this.beta1)),f=xe(h,this.beta2),m=Rs(c),g=wC(f,m);d.assign(p),h.assign(g);const y=qe(xe(sn(o,s),sn(p,qe(g,this.epsilon))),l);l.assign(y)}),this.iteration.assign(qe(this.iteration,1)),this.accBeta1.assign(xe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ws(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&ws(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return $(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return $(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}return n.className="Adamax",n})();ml(Xb);let mf=(()=>{class n extends gl{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=Array.isArray(e)?e[o].tensor:e[s];if(null==i)return;const a=P.registeredVariables[s];Lt(()=>{const l=qe(xe(this.c,i),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Li(Tt(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return $(function*(){return[yield e.saveIterations()]})()}setWeights(e){var r=this;return $(function*(){if(0!==(e=yield r.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,r){return new e(r.learningRate)}}return n.className="SGD",n})();ml(mf);let Yb=(()=>{class n extends mf{constructor(e,r,s=!1){super(e),this.learningRate=e,this.momentum=r,this.useNesterov=s,this.accumulations=[],this.m=Tt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=P.registeredVariables[s];null==this.accumulations[o]&&(this.accumulations[o]={originalName:`${s}/momentum`,variable:Lt(()=>As(i).variable(!1))});const a=this.accumulations[o].variable,l=Array.isArray(e)?e[o].tensor:e[s];null!=l&&Lt(()=>{let u;const c=qe(xe(this.m,a),l);u=qe(xe(this.c,this.useNesterov?qe(l,xe(c,this.m)):c),i),a.assign(c),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ws(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return $(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return $(function*(){e=yield r.extractIterations(e),r.accumulations=e.map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)}}return n.className="Momentum",n})();ml(Yb);let Zb=(()=>{class n extends gl{constructor(e,r=.9,s=0,o=null,i=!1){if(super(),this.learningRate=e,this.decay=r,this.momentum=s,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==o&&(this.epsilon=P.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=P.registeredVariables[s],a=!1;null==this.accumulatedMeanSquares[o]&&(this.accumulatedMeanSquares[o]={originalName:`${s}/rms`,variable:Lt(()=>As(i).variable(a))}),null==this.accumulatedMoments[o]&&(this.accumulatedMoments[o]={originalName:`${s}/momentum`,variable:Lt(()=>As(i).variable(a))}),null==this.accumulatedMeanGrads[o]&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${s}/mg`,variable:Lt(()=>As(i).variable(a))});const l=Array.isArray(e)?e[o].tensor:e[s];if(null==l)return;const u=this.accumulatedMeanSquares[o].variable,c=this.accumulatedMoments[o].variable;Lt(()=>{const d=qe(xe(u,this.decay),xe(ko(l),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[o].variable,p=qe(xe(h,this.decay),xe(l,1-this.decay)),f=sn(xe(l,this.learningRate),Bi(yt(d,qe(ko(p),this.epsilon)))),m=qe(xe(c,this.momentum),f);u.assign(d),h.assign(p),c.assign(m);const g=yt(i,m);i.assign(g)}else{const h=qe(xe(u,this.decay),xe(ko(l),1-this.decay)),p=qe(xe(c,this.momentum),sn(xe(l,this.learningRate),Bi(qe(h,this.epsilon))));u.assign(h),c.assign(p);const f=yt(i,p);i.assign(f)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ws(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&ws(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&ws(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return $(function*(){const r=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&r.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return $(function*(){e=yield r.extractIterations(e);const s=r.centered?e.length/3:e.length/2,o=!1;r.accumulatedMeanSquares=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})),r.accumulatedMoments=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})),r.centered&&(r.accumulatedMeanGrads=e.slice(2*s,3*s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}return n.className="RMSProp",n})();ml(Zb);class yl{static sgd(t){return new mf(t)}static momentum(t,e,r=!1){return new Yb(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,o=!1){return new Zb(t,e,r,s,o)}static adam(t=.001,e=.9,r=.999,s=null){return new Kb(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new jb(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,o=0){return new Xb(t,e,r,s,o)}static adagrad(t,e=.1){return new qb(t,e)}}const Nz=M({acos_:function nce(n){const e={x:E(n,"x","acos")};return P.runKernel(WL,e)}}),Dz=M({acosh_:function rce(n){const e={x:E(n,"x","acosh")};return P.runKernel(GL,e)}}),Az=M({addN_:function sce(n){D(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),D(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((s,o)=>E(s,`tensors${o}`,"addN")),e=t[0];return t.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Oi(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),P.runKernel(HL,t)}}),Rz=M({all_:function oce(n,t=null,e=!1){const s={x:E(n,"x","all","bool")};return P.runKernel(jL,s,{axis:t,keepDims:e})}}),$z=M({any_:function ice(n,t=null,e=!1){const s={x:E(n,"x","any","bool")};return P.runKernel(qL,s,{axis:t,keepDims:e})}}),Oz=M({argMax_:function ace(n,t=0){const r={x:E(n,"x","argMax")};return P.runKernel(KL,r,{axis:t})}}),Fz=M({argMin_:function lce(n,t=0){const r={x:E(n,"x","argMin")};return P.runKernel(XL,r,{axis:t})}}),Mz=M({asin_:function uce(n){const e={x:E(n,"x","asin")};return P.runKernel(YL,e)}}),Pz=M({asinh_:function cce(n){const e={x:E(n,"x","asinh")};return P.runKernel(ZL,e)}}),Lz=M({atan_:function dce(n){const e={x:E(n,"x","atan")};return P.runKernel(QL,e)}}),Vz=M({atan2_:function hce(n,t){let e=E(n,"a","atan2"),r=E(t,"b","atan2");return[e,r]=In(e,r),P.runKernel(e3,{a:e,b:r})}}),Bz=M({atanh_:function pce(n){const e={x:E(n,"x","atanh")};return P.runKernel(JL,e)}});function fce(n,t,e,r,s="NHWC",o){return gf(n,[...t,n[3]],e,o,r,null,null,Wz(s))}function zz(n,t,e,r,s,o,i="channelsLast"){const[a,l]=Qb(t);let u;if("channelsLast"===i)u=[a,l,n[3],n[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,n[1],n[1]]}return gf(n,u,e,r,s,o,!1,i)}function mce(n,t,e,r,s,o,i="NDHWC"){const[a,l,u]=SC(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,n[4],n[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,n[1],n[1]]}return Uz(n,c,e,r,s,!1,d,o)}function gf(n,t,e,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=n}const[h,p,,f]=t,[m,g]=Qb(e),[y,b]=Qb(r),_=Od(h,y),v=Od(p,b),{padInfo:w,outHeight:S,outWidth:T}=function bce(n,t,e,r,s,o,i,a,l){let u,c,d;if("number"==typeof n){u={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const p=function gce(n,t,e,r,s){null==r&&(r=xC(n,t,e));const i=n[1];return[Bu((n[0]-t+2*r)/e+1,s),Bu((i-t+2*r)/e+1,s)]}([t,e],o,r,n,a);c=p[0],d=p[1]}else if("same"===n){c=Math.ceil(t/r),d=Math.ceil(e/s);const h=Math.max(0,(c-1)*r+o-t),p=Math.max(0,(d-1)*s+i-e),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2);u={top:f,bottom:m,left:g,right:p-g,type:"SAME"}}else if("valid"===n)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-o+1)/r),d=Math.ceil((e-i+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],p="channelsLast"===l?n[1][1]:n[2][1],f="channelsLast"===l?n[2][0]:n[3][0],m="channelsLast"===l?n[2][1]:n[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Bu((t-o+h+p)/r+1,a),d=Bu((e-i+f+m)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,_,v,o,a),I=i?f*d:f;let N;return"channelsFirst"===a?N=[l,I,S,T]:"channelsLast"===a&&(N=[l,S,T,I]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:S,outWidth:T,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:_,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:n,outShape:N,filterShape:t}}function Uz(n,t,e,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=n;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=n}const[p,f,m,,g]=t,[y,b,_]=SC(e),[v,w,S]=SC(r),T=Od(p,v),I=Od(f,w),N=Od(m,S),{padInfo:R,outDepth:F,outHeight:j,outWidth:q}=function _ce(n,t,e,r,s,o,i,a,l,u,c){let d,h,p,f;if("number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const g=function yce(n,t,e,r,s,o){null==s&&(s=xC(n,t,r));const a=n[1],l=n[2];return[Bu((n[0]-t+2*s)/r+1,o),Bu((a-t+2*s)/r+1,o),Bu((l-t+2*s)/r+1,o),e]}([t,e,r,1],a,1,s,n,c);h=g[0],p=g[1],f=g[2]}else if("same"===n){h=Math.ceil(t/s),p=Math.ceil(e/o),f=Math.ceil(r/i);const m=(h-1)*s+a-t,g=(p-1)*o+l-e,y=(f-1)*i+u-r,b=Math.floor(m/2),_=m-b,v=Math.floor(g/2),w=g-v,S=Math.floor(y/2);d={top:v,bottom:w,left:S,right:y-S,front:b,back:_,type:"SAME"}}else{if("valid"!==n)throw Error(`Unknown padding parameter: ${n}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-a+1)/s),p=Math.ceil((e-l+1)/o),f=Math.ceil((r-u+1)/i)}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(s,u,c,d,y,b,_,T,I,N,a),X=o?g*h:g;let Q;return"channelsFirst"===i?Q=[l,X,F,j,q]:"channelsLast"===i&&(Q=[l,F,j,q,X]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:F,outHeight:j,outWidth:q,outChannels:X,padInfo:R,strideDepth:y,strideHeight:b,strideWidth:_,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:T,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:w,dilationWidth:S,inShape:n,outShape:Q,filterShape:t}}function xC(n,t,e,r=1){const s=Od(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function Qb(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function SC(n){return"number"==typeof n?[n,n,n]:n}function Od(n,t){return t<=1?n:n+(n-1)*(t-1)}function Bu(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function yf(n){const[t,e,r]=Qb(n);return 1===t&&1===e&&1===r}function Ca(n,t){return yf(n)||yf(t)}function Wz(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function No(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)D(Sd(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{D(Sd(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const ie=M({reshape_:function vce(n,t){const r={x:E(n,"x","reshape","string_or_numeric")};return P.runKernel(VV,r,{shape:t})}}),TC=M({avgPool_:function wce(n,t,e,r,s){const o=E(n,"x","avgPool","float32");D(Ca(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),No("avgPool",r,s);let d=P.runKernel(t3,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d=_n(d,o.dtype),l?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Gz=M({avgPool3d_:function xce(n,t,e,r,s,o="NDHWC"){const i=E(n,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=ie(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),D("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),No("avgPool3d",r,s);let d=P.runKernel(n3,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d=_n(d,a.dtype),l?ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Ur=M({concat_:function Sce(n,t=0){D(n.length>=1,()=>"Pass at least one tensor to concat");const e=df(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?Ta(e[0]):P.runKernel(h3,e,{axis:t})}}),zu=M({sigmoid_:function Tce(n){const e={x:E(n,"x","sigmoid","float32")};return P.runKernel(eB,e)}}),Xt=M({slice_:function Cce(n,t,e){const r=E(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return P.runKernel(YV,{x:r},{begin:t,size:e})}}),Jb=M({tanh_:function Ece(n){const e={x:E(n,"x","tanh","float32")};return P.runKernel(_B,e)}}),Hz=M({basicLSTMCell_:function Ice(n,t,e,r,s,o){const i=E(n,"forgetBias","basicLSTMCell"),a=E(t,"lstmKernel","basicLSTMCell"),l=E(e,"lstmBias","basicLSTMCell"),u=E(r,"data","basicLSTMCell"),c=E(s,"c","basicLSTMCell"),d=E(o,"h","basicLSTMCell"),h=Ur([u,d],1),p=Wt(h,a),f=qe(p,l),g=f.shape[1]/4,y=[f.shape[0],g],b=Xt(f,[0,0],y),_=Xt(f,[0,g],y),v=Xt(f,[0,2*g],y),w=Xt(f,[0,3*g],y),S=qe(xe(zu(b),Jb(_)),xe(c,zu(qe(i,v))));return[S,xe(Jb(S),zu(w))]}}),CC=M({batchToSpaceND_:function kce(n,t,e){const r=E(n,"x","batchToSpaceND"),s=t.reduce((a,l)=>a*l);return D(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),D(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),D(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),P.runKernel(s3,{x:r},{blockShape:t,crops:e})}});function Nce(n){let t;return t=0===n.rank||1===n.rank?ie(n,[1,1,1,n.size]):2===n.rank?ie(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const bf=M({batchNorm_:function Dce(n,t,e,r,s,o){null==o&&(o=.001);const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),D(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:Nce(i),scale:u,offset:c,mean:a,variance:l},f=P.runKernel(W3,h,{varianceEpsilon:o});return ie(f,i.shape)}}),jz=M({batchNorm2d_:function Ace(n,t,e,r,s,o){const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),D(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),D(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),D(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&D(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&D(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),bf(i,a,l,c,u,o)}}),qz=M({batchNorm3d_:function Rce(n,t,e,r,s,o){const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),D(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),D(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),D(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&D(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&D(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),bf(i,a,l,c,u,o)}}),Kz=M({batchNorm4d_:function $ce(n,t,e,r,s,o){const i=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),D(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),D(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),D(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&D(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&D(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),bf(i,a,l,c,u,o)}}),EC=M({bincount_:function Oce(n,t,e){const r=E(n,"x","bincount"),s=E(t,"weights","bincount");return D("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),D(e>=0,()=>`size must be non-negative, but got ${e}.`),D(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),P.runKernel(o3,{x:r,weights:s},{size:e})}}),Xz=M({broadcastArgs_:function Fce(n,t){const e=E(n,"s0","broadcastArgs","int32"),r=E(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return P.runKernel(a3,{s0:e,s1:r})}}),_f=M({broadcastTo_:function Mce(n,t){let e=E(n,"broadcastTo","x");const r=e.shape;if(t.some(u=>!(u>0)||u%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=ie(e,u)}const s=e.shape,o=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?Ta(e):P.runKernel(I1,{x:e},{reps:o})}}),Yz=M({ceil_:function Pce(n){const e={x:E(n,"x","ceil","float32")};return P.runKernel(l3,e)}}),Zz=M({clipByValue_:function Lce(n,t,e){const r=E(n,"x","clipByValue");return D(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?Rd(r.shape,t,r.dtype):P.runKernel(u3,{x:r},{clipValueMin:t,clipValueMax:e})}}),Qz=M({concat1d_:function Vce(n){return Ur(n,0)}}),Jz=M({concat2d_:function Bce(n,t){return Ur(n,t)}}),e4=M({concat3d_:function zce(n,t){return Ur(n,t)}}),t4=M({concat4d_:function Uce(n,t){return Ur(n,t)}}),vf=M({conv2d_:function Wce(n,t,e,r,s="NHWC",o=[1,1],i){const a=E(n,"x","conv2d","float32"),l=E(t,"filter","conv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),D(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),No("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];D(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),D(Ca(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const f=P.runKernel(p3,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),n4=M({conv1d_:function Gce(n,t,e,r,s="NWC",o=1,i){const a=E(n,"x","conv1d"),l=E(t,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=ie(a,[1,a.shape[0],a.shape[1]])),D(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),D(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),No("conv1d",r,i),D(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),D(Ca(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),D("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=ie(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=vf(h,d,[1,e],r,"NHWC",[1,o],i);return ie(g,c?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),r4=M({conv2DBackpropInput_:function Hce(n,t,e,r,s,o="NHWC",i){D(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,u=!1;3===t.rank&&(u=!0,l=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),D(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),D(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),D(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];D(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),D(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),No("conv2dDerInput",s,i);const f=P.runKernel(m3,{dy:l,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),s4=M({conv2dTranspose_:function jce(n,t,e,r,s,o){const i=E(n,"x","conv2dTranspose"),a=E(t,"filter","conv2dTranspose");return r4(e,i,a,r,s,"NHWC",o)}}),o4=M({conv3d_:function qce(n,t,e,r,s="NDHWC",o=[1,1,1]){const i=E(n,"x","conv3d"),a=E(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=ie(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),D(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),D(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),D(Ca(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),D("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h=P.runKernel(g3,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:o});return u?ie(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),Xce=M({conv3DBackpropInput_:function Kce(n,t,e,r,s){D(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,i=t,a=!1;4===t.rank&&(a=!0,i=ie(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const l=o[4],u=i.shape[4];D(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),D(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),D(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),D(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),D(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=P.runKernel(y3,{dy:i,filter:e},{pad:s,strides:r,inputShape:o});return a?ie(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),i4=M({conv3dTranspose_:function Yce(n,t,e,r,s){const o=E(n,"x","conv3dTranspose"),i=E(t,"filter","conv3dTranspose");return Xce(e,o,i,r,s)}}),a4=M({cos_:function Zce(n){const e={x:E(n,"x","cos","float32")};return P.runKernel(b3,e)}}),l4=M({cosh_:function Qce(n){const e={x:E(n,"x","cosh","float32")};return P.runKernel(_3,e)}}),u4=M({cumprod_:function Jce(n,t=0,e=!1,r=!1){const o={x:E(n,"x","cumprod")};return P.runKernel(v3,o,{axis:t,exclusive:e,reverse:r})}}),c4=M({cumsum_:function ede(n,t=0,e=!1,r=!1){const o={x:E(n,"x","cumsum")};return P.runKernel(w3,o,{axis:t,exclusive:e,reverse:r})}}),d4=M({denseBincount_:function tde(n,t,e,r=!1){const s=E(n,"x","denseBincount"),o=E(t,"weights","denseBincount");return D("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),D(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),D(e>=0,()=>`size must be non-negative, but got ${e}.`),D(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),P.runKernel(S3,{x:s,weights:o},{size:e,binaryOutput:r})}}),h4=M({depthToSpace_:function nde(n,t,e="NHWC"){const r=E(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],i="NHWC"===e?r.shape[3]:r.shape[1];return D(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),D(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),D(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${r.shape}`),D(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`),P.runKernel(T3,{x:r},{blockSize:t,dataFormat:e})}}),e_=M({depthwiseConv2d_:function rde(n,t,e,r,s="NHWC",o=[1,1],i){const a=E(n,"x","depthwiseConv2d","float32"),l=E(t,"filter","depthwiseConv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),D(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];D(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),No("depthwiseConv2d",r,i);const f=P.runKernel(C3,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),p4=M({diag_:function sde(n){const e={x:E(n,"x","diag")};return P.runKernel(k3,e)}}),f4=M({dilation2d_:function ode(n,t,e,r,s=[1,1],o="NHWC"){const i=E(n,"x","dilation2d"),a=E(t,"filter","dilation2d");D(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),D(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),D("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);const h=P.runKernel(N3,{x:l,filter:a},{strides:e,pad:r,dilations:s});return u?ie(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),IC=M({equal_:function ide(n,t){let e=E(n,"a","equal","string_or_numeric"),r=E(t,"b","equal","string_or_numeric");return[e,r]=In(e,r),Qn(e.shape,r.shape),P.runKernel(O3,{a:e,b:r})}}),Uu=M({where_:function ade(n,t,e){const r=E(t,"a","where"),s=E(e,"b","where"),o=E(n,"condition","where","bool"),i=Qn(Qn(o.shape,r.shape),s.shape),a=_f(o,i),l=_f(r,i),u=_f(s,i);return P.runKernel(KV,{condition:a,t:l,e:u})}}),m4=M({divNoNan_:function lde(n,t){let e=E(n,"a","div"),r=E(t,"b","div");[e,r]=In(e,r);const s=sn(e,r),o=As(s),i=IC(r,o);return Uu(i,o,s)}}),g4=M({dot_:function ude(n,t){const e=E(n,"t1","dot"),r=E(t,"t2","dot");D(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(D(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const i=ie(e,[1,-1]),a=ie(r,[-1,1]),l=Wt(i,a);return ie(l,[])}if(1===e.rank&&2===r.rank){const i=ie(e,[1,-1]),a=ie(r,[r.shape[0],r.shape[1]]),l=Wt(i,a);return ie(l,[l.size])}if(2===e.rank&&1===r.rank){const i=ie(r,[-1,1]),a=Wt(e,i);return ie(a,[a.size])}{const i=ie(r,[r.shape[0],r.shape[1]]);return Wt(e,i)}}}),y4=M({einsum_:function cde(n,...t){const e=t.map((s,o)=>E(s,`tensors${o}`,"einsum"));return P.runKernel(A3,e,{equation:n})}}),kC=M({elu_:function dde(n){const e={x:E(n,"x","elu","float32")};return P.runKernel(R3,e)}}),b4=M({erf_:function hde(n){let t=E(n,"x","erf");return D("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=_n(t,"float32")),P.runKernel($3,{x:t})}});function NC(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function _4(n,t,e){const r=n.length+t.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[o++]):s.push(t[i++]);return s}function pde(n,t){const e=[],r=n.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&e.push(n[o]);return[e,t.map(o=>n[o])]}function wf(n,t){return _4(n,t.map(r=>1),t)}function fde(n,t,e){D(NC(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function mde(n,t){if(NC(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function gde(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function yde(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Wu=M({max_:function bde(n,t=null,e=!1){const s={x:E(n,"x","max")};return P.runKernel(uV,s,{reductionIndices:t,keepDims:e})}}),t_=M({min_:function _de(n,t=null,e=!1){const s={x:E(n,"x","min")};return P.runKernel(mV,s,{axis:t,keepDims:e})}}),on=M({sum_:function vde(n,t=null,e=!1){let r=E(n,"x","sum");return"bool"===r.dtype&&(r=_n(r,"int32")),P.runKernel(rB,{x:r},{axis:t,keepDims:e})}});function v4(n,t,e=null){if(0===n.rank)return Rs(n);if(1!==n.rank&&null===e)return v4(ie(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return on(Rs(n),e);if(t===1/0)return Wu(Rs(n),e);if(t===-1/0)return t_(Rs(n),e);if("euclidean"===t||2===t)return Bi(on($d(Rs(n),Tt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Wu(on(Rs(n),e[0]),e[1]-1);if(t===1/0)return Wu(on(Rs(n),e[1]),e[0]);if(t===-1/0)return t_(on(Rs(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return Bi(on(ko(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const xf=M({norm_:function wde(n,t="euclidean",e=null,r=!1){const s=v4(n=E(n,"x","norm"),t,e);let o=s.shape;if(r){const i=ef(e,n.shape);o=wf(s.shape,i)}return ie(s,o)}}),w4=M({euclideanNorm_:function xde(n,t=null,e=!1){return xf(n,"euclidean",t,e)}}),bl=M({exp_:function Sde(n){const e={x:E(n,"x","exp")};return P.runKernel(F3,e)}}),_l=M({expandDims_:function Tde(n,t=0){const e=E(n,"x","expandDims","string_or_numeric");return D(t<=e.rank,()=>"Axis must be <= rank of the tensor"),P.runKernel(M3,{input:e},{dim:t})}}),x4=M({expm1_:function Cde(n){const e={x:E(n,"x","expm1")};return P.runKernel(P3,e)}}),Fd=M({tile_:function Ede(n,t){const e=E(n,"x","tile","string_or_numeric");return D(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),P.runKernel(I1,{x:e},{reps:t})}}),DC=M({eye_:function Ide(n,t,e,r="float32"){null==t&&(t=n);const s=Pi([n,t],r),o=n<=t?n:t;for(let a=0;a<o;++a)s.set(1,a,a);const i=ie(s.toTensor(),[n,t]);if(null==e)return i;if(1===e.length)return Fd(_l(i,0),[e[0],1,1]);if(2===e.length)return Fd(_l(_l(i,0),0),[e[0],e[1],1,1]);if(3===e.length)return Fd(_l(_l(_l(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),AC=M({floor_:function kde(n){const e={x:E(n,"x","floor","float32")};return P.runKernel(z3,e)}}),RC=M({gather_:function Nde(n,t,e=0,r=0){const s=E(n,"x","gather"),o=E(t,"indices","gather","int32");return P.runKernel(G3,{x:s,indices:o},{axis:e,batchDims:r})}}),Sf=M({greater_:function Dde(n,t){let e=E(n,"a","greater","string_or_numeric"),r=E(t,"b","greater","string_or_numeric");return[e,r]=In(e,r),Qn(e.shape,r.shape),P.runKernel(j3,{a:e,b:r})}}),$C=M({greaterEqual_:function Ade(n,t){let e=E(n,"a","greaterEqual","string_or_numeric"),r=E(t,"b","greaterEqual","string_or_numeric");return[e,r]=In(e,r),Qn(e.shape,r.shape),P.runKernel(q3,{a:e,b:r})}}),S4=M({isFinite_:function Rde(n){const e={x:E(n,"x","isFinite")};return P.runKernel(Y3,e)}}),T4=M({isInf_:function $de(n){const e={x:E(n,"x","isInf")};return P.runKernel(Z3,e)}}),C4=M({isNaN_:function Ode(n){const e={x:E(n,"x","isNaN")};return P.runKernel(Q3,e)}}),OC=M({leakyRelu_:function Fde(n,t=.2){const r={x:E(n,"x","leakyRelu")};return P.runKernel(J3,r,{alpha:t})}}),E4=M({less_:function Mde(n,t){let e=E(n,"a","less","string_or_numeric"),r=E(t,"b","less","string_or_numeric");return[e,r]=In(e,r),Qn(e.shape,r.shape),P.runKernel(eV,{a:e,b:r})}}),n_=M({lessEqual_:function Pde(n,t){let e=E(n,"a","lessEqual","string_or_numeric"),r=E(t,"b","lessEqual","string_or_numeric");return[e,r]=In(e,r),Qn(e.shape,r.shape),P.runKernel(tV,{a:e,b:r})}});function I4(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return P.runKernel(nV,{},{start:n,stop:t,num:e})}const k4=M({localResponseNormalization_:function Lde(n,t=5,e=1,r=1,s=.5){const o=E(n,"x","localResponseNormalization");D(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),D(Sd(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=P.runKernel(lV,{x:i},{depthRadius:t,bias:e,alpha:r,beta:s});return a?ie(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Md=M({log_:function Vde(n){const e={x:E(n,"x","log","float32")};return P.runKernel(rV,e)}}),FC=M({log1p_:function Bde(n){const e={x:E(n,"x","log1p")};return P.runKernel(sV,e)}}),MC=M({softplus_:function zde(n){const e={x:E(n,"x","softplus")};return P.runKernel(tB,e)}}),N4=M({logSigmoid_:function Ude(n){const t=E(n,"x","logSigmoid");return zi(r=>({value:Vi(MC(Vi(r))),gradFunc:i=>xe(i,zu(Vi(r)))}))(t)}}),D4=M({logSoftmax_:function Wde(n,t=-1){const e=E(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return zi((s,o)=>{const a=Wu(s,t,!0),l=yt(s,a),u=yt(_n(l,"float32"),Md(on(bl(l),t,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[p]=h,m=bl(p);return yt(d,xe(on(d,t,!0),m))}}})(e)}}),PC=M({logSumExp_:function Gde(n,t=null,e=!1){const r=E(n,"x","logSumExp"),s=ef(t,r.shape),o=Wu(r,s,!0),i=yt(r,o),a=bl(i),l=on(a,s),u=Md(l),c=qe(ie(o,u.shape),u);if(e){const d=wf(c.shape,s);return ie(c,d)}return c}}),Tf=M({logicalAnd_:function Hde(n,t){const e=E(n,"a","logicalAnd","bool"),r=E(t,"b","logicalAnd","bool");return Qn(e.shape,r.shape),P.runKernel(oV,{a:e,b:r})}}),LC=M({logicalNot_:function jde(n){const e={x:E(n,"x","logicalNot","bool")};return P.runKernel(iV,e)}}),VC=M({logicalOr_:function qde(n,t){const e=E(n,"a","logicalOr","bool"),r=E(t,"b","logicalOr","bool");return Qn(e.shape,r.shape),P.runKernel(aV,{a:e,b:r})}}),A4=M({logicalXor_:function Kde(n,t){const e=E(n,"a","logicalXor","bool"),r=E(t,"b","logicalXor","bool");return Qn(e.shape,r.shape),Tf(VC(n,t),LC(Tf(n,t)))}}),r_=2147483648,s_=M({searchSorted_:function Xde(n,t,e="left"){const r=E(n,"sortedSequence","searchSorted"),s=E(t,"values","searchSorted"),i=s.shape[s.shape.length-1],a=ie(r,[-1,r.shape[r.shape.length-1]]),l=ie(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(gn(l.shape)>=r_)throw new Error(`values tensor size must less than ${r_}`);if(a.shape[1]>=r_)throw new Error(`trailing dim_size must less than ${r_} for int32 output type, was ${a.shape[1]}`);return P.runKernel(qV,{sortedSequence:a,values:l},{side:e})}});function R4(n,t){return s_(n,t,"left")}const BC=M({maxPool_:function Yde(n,t,e,r,s){const o=E(n,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),D(Ca(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),No("maxPool",r,s);const d=P.runKernel(dV,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return l?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),$4=M({maxPool3d_:function Zde(n,t=[1,1,1],e,r,s,o="NDHWC"){const i=E(n,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=ie(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),D("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),No("maxPool3d",r,s);const d=P.runKernel(hV,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return l?ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),O4=M({maxPoolWithArgmax_:function Qde(n,t,e,r,s=!1){const i={x:E(n,"x","maxPoolWithArgmax")},l=P.runKernel(pV,i,{filterSize:t,strides:e,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}}),Cf=M({mean_:function Jde(n,t=null,e=!1){const s={x:E(n,"x","mean")};return P.runKernel(fV,s,{axis:t,keepDims:e})}});function vl(n,t="float32"){if("complex64"===t){const r=vl(n,"float32"),s=vl(n,"float32");return Sa(r,s)}const e=Eb(gn(n),t);return P.makeTensor(e,n,t)}function wl(n,t="float32"){if("complex64"===t){const r=wl(n,"float32"),s=vl(n,"float32");return Sa(r,s)}const e=_1(gn(n),t);return P.makeTensor(e,n,t)}function F4(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=E(n,"x","meshgrid",n instanceof En?n.dtype:"float32");if(void 0===t)return[r];let s=E(t,"y","meshgrid",t instanceof En?t.dtype:"float32");const o=gn(r.shape),i=gn(s.shape);return"xy"===e?(r=ie(r,[1,-1]),s=ie(s,[-1,1]),[Wt(wl([i,1],r.dtype),r),Wt(s,wl([1,o],s.dtype))]):(r=ie(r,[-1,1]),s=ie(s,[1,-1]),[Wt(r,wl([1,i],r.dtype)),Wt(wl([o,1],s.dtype),s)])}const zC=M({minimum_:function ehe(n,t){let e=E(n,"a","minimum"),r=E(t,"b","minimum");return[e,r]=In(e,r),"bool"===e.dtype&&(e=_n(e,"int32"),r=_n(r,"int32")),Qn(e.shape,r.shape),P.runKernel(gV,{a:e,b:r})}}),M4=M({mirrorPad_:function the(n,t,e){D("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=E(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)D(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),D(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return P.runKernel(yV,{x:r},{paddings:t,mode:e})}}),P4=M({mod_:function nhe(n,t){let e=E(n,"a","mod"),r=E(t,"b","mod");return[e,r]=In(e,r),P.runKernel(bV,{a:e,b:r})}}),L4=M({moments_:function rhe(n,t=null,e=!1){const r=ef(t,(n=E(n,"x","moments")).shape),s=Cf(n,r,e);let o=s.shape;e||(o=wf(s.shape,r));const i=ko(yt(_n(n,"float32"),ie(s,o)));return{mean:s,variance:Cf(i,r,e)}}}),V4=M({multiRNNCell_:function she(n,t,e,r){const s=E(t,"data","multiRNNCell"),o=df(e,"c","multiRNNCell"),i=df(r,"h","multiRNNCell");let a=s;const l=[];for(let d=0;d<n.length;d++){const h=n[d](a,o[d],i[d]);l.push(h[0]),l.push(h[1]),a=h[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}}),B4=M({multinomial_:function ohe(n,t,e,r=!1){const s=E(n,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();const l={logits:1===i?ie(s,[1,-1]):s},c=P.runKernel(_V,l,{numSamples:t,seed:e,normalized:r});return 1===i?ie(c,[c.size]):c}}),UC=M({notEqual_:function ihe(n,t){let e=E(n,"a","notEqual","string_or_numeric"),r=E(t,"b","notEqual","string_or_numeric");return[e,r]=In(e,r),Qn(e.shape,r.shape),P.runKernel(xV,{a:e,b:r})}}),z4=M({onesLike_:function ahe(n){const e={x:E(n,"x","onesLike")};return P.runKernel(EV,e)}}),U4=M({outerProduct_:function lhe(n,t){const e=E(n,"v1","outerProduct"),r=E(t,"v2","outerProduct");D(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const s=ie(e,[-1,1]),o=ie(r,[1,-1]);return Wt(s,o)}}),Pd=M({pad_:function uhe(n,t,e=0){const r=E(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return P.runKernel(NV,{x:r},{paddings:t,constantValue:e})}}),W4=M({pad1d_:function che(n,t,e=0){return D(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),Pd(n,[t],e)}}),G4=M({pad2d_:function dhe(n,t,e=0){return D(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Pd(n,t,e)}}),H4=M({pad3d_:function hhe(n,t,e=0){return D(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Pd(n,t,e)}}),j4=M({pad4d_:function phe(n,t,e=0){return D(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Pd(n,t,e)}}),WC=M({spaceToBatchND_:function fhe(n,t,e){const r=E(n,"x","spaceToBatchND");return D(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),D(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),D(r.shape.reduce((i,a,l)=>l>0&&l<=t.length?i&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),P.runKernel(sB,{x:r},{blockShape:t,paddings:e})}}),q4=M({pool_:function mhe(n,t,e,r,s,o,i){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const a=E(n,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(Ca(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const c=zz(l.shape,t,o,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function yhe(n,t){const r=n.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function ghe(n,t,e){const r=e.map(c=>c[0]),s=e.map(c=>c[1]),o=n.concat(r,s),i=t.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],a[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:WC(l,d,f),_=("avg"===e?()=>TC(y,t,o,g,i):()=>BC(y,t,o,g,i))(),v=p?_:CC(_,d,m);return u?ie(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),GC=M({prelu_:function bhe(n,t){const e=E(n,"x","prelu"),r=E(t,"alpha","prelu");return P.runKernel(AV,{x:e,alpha:r})}}),K4=M({prod_:function _he(n,t=null,e=!1){let r=E(n,"x","prod");return"bool"===r.dtype&&(r=_n(r,"int32")),P.runKernel(RV,{x:r},{axis:t,keepDims:e})}}),X4=M({raggedGather_:function vhe(n,t,e,r){const s=n.map((c,d)=>E(c,`tensors${d}`,"raggedGather","int32")),o=E(t,"paramsDenseValues","raggedGather"),i=E(e,"indices","raggedGather","int32"),u=P.runKernel($V,{paramsNestedSplits:s,paramsDenseValues:o,indices:i},{outputRaggedRank:r});return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}}),Y4=M({raggedTensorToTensor_:function whe(n,t,e,r,s){const o=E(n,"shape","raggedTensorToTensor","int32"),i=E(t,"values","raggedTensorToTensor"),a=E(e,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,h)=>E(d,`tensors${h}`,"raggedTensorToTensor","int32"));return P.runKernel(OV,{shape:o,values:i,defaultValue:a,rowPartitionTensors:l},{rowPartitionTypes:s})}}),Z4=M({rand_:function xhe(n,t,e){const r=gn(n);let s=null;if(null==e||"float32"===e)s=new Float32Array(r);else if("int32"===e)s=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);s=new Uint8Array(r)}for(let o=0;o<r;o++)s[o]=t();return P.makeTensor(s,n,e)}});var xl=K(340);class HC{constructor(t,e,r,s,o){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=xl.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class She{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;const o=s||Math.random();this.randu=xl.alea(o.toString()),this.randn=new HC(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,o,i;for(;;){do{s=this.randn.nextValue(),i=1+this.c*s}while(i<=0);if(i*=i*i,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-i+Math.log(i)),o=this.randu(),o<e||Math.log(o)<r)break}return i*=1/this.beta*this.d,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class The{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=xl.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Q4=M({randomGamma_:function khe(n,t,e=1,r="float32",s){if(null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const o=new She(t,e,r,s),i=Pi(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),qC=M({randomNormal_:function Nhe(n,t=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new HC(t,e,r,!1,s),i=Pi(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),J4=M({randomStandardNormal_:function Dhe(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return qC(n,0,1,t,e)}}),KC=M({randomUniform_:function Ahe(n,t=0,e=1,r="float32",s){const o=Pi(n,r),i=new The(t,e,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}});function Ld(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return P.runKernel(FV,{},{start:n,stop:t,step:e,dtype:r})}const eU=M({reciprocal_:function Rhe(n){const e={x:E(n,"x","reciprocal")};return P.runKernel(PV,e)}}),Ef=M({relu_:function $he(n){const e={x:E(n,"x","relu")};return P.runKernel(LV,e)}}),XC=M({relu6_:function Ohe(n){const e={x:E(n,"x","relu6")};return P.runKernel(UV,e)}}),Sl=M({reverse_:function Fhe(n,t){const r={x:E(n,"x","reverse")};return P.runKernel(WV,r,{dims:t})}}),tU=M({reverse1d_:function Mhe(n){const t=E(n,"x","reverse");return D(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Sl(t,0)}}),nU=M({reverse2d_:function Phe(n,t){const e=E(n,"x","reverse");return D(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Sl(e,t)}}),rU=M({reverse3d_:function Lhe(n,t){const e=E(n,"x","reverse");return D(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Sl(e,t)}}),sU=M({reverse4d_:function Vhe(n,t){const e=E(n,"x","reverse");return D(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Sl(e,t)}}),YC=M({round_:function Bhe(n){const e={x:E(n,"x","round")};return P.runKernel(GV,e)}}),oU=M({rsqrt_:function zhe(n){const e={x:E(n,"x","rsqrt","float32")};return P.runKernel(HV,e)}}),iU=M({selu_:function Uhe(n){const e={x:E(n,"x","selu")};return P.runKernel(XV,e)}}),aU=M({separableConv2d_:function Whe(n,t,e,r,s,o=[1,1],i="NHWC"){const a=E(n,"x","separableConv2d"),l=E(t,"depthwiseFilter","separableConv2d"),u=E(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),D(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),D(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),D(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),D(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];D(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=e_(c,l,r,s,i,o),g=vf(f,u,1,"valid",i);return d?ie(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});function ZC(){return(ZC=$(function*(n,t){const e=E(n,"x","setdiff1d"),r=E(t,"y","setdiff1d");D(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),D(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),D(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),o=yield r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const l=new Ob([a],e.dtype),u=new Ob([a],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}const lU=function Ghe(n,t){return ZC.apply(this,arguments)},uU=M({sign_:function Hhe(n){const e={x:E(n,"x","sign")};return P.runKernel(JV,e)}}),cU=M({sin_:function jhe(n){const e={x:E(n,"x","sin","float32")};return P.runKernel(ZV,e)}}),dU=M({sinh_:function qhe(n){const e={x:E(n,"x","sinh")};return P.runKernel(QV,e)}}),hU=M({slice1d_:function Khe(n,t,e){const r=E(n,"x","slice1d");return D(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Xt(r,[t],[e])}}),pU=M({slice2d_:function Xhe(n,t,e){const r=E(n,"x","slice2d");return D(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Xt(r,t,e)}}),fU=M({slice3d_:function Yhe(n,t,e){const r=E(n,"x","slice3d");return D(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Xt(r,t,e)}}),mU=M({slice4d_:function Zhe(n,t,e){const r=E(n,"x","slice4d");return D(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Xt(r,t,e)}}),QC=M({softmax_:function Qhe(n,t=-1){const e=E(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return P.runKernel(iB,{logits:e},{dim:t})}}),o_=M({fft_:function Jhe(n){return D("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),P.runKernel(L3,{input:n})}}),If=M({ifft_:function epe(n){return D("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),P.runKernel(K3,{input:n})}}),JC=M({irfft_:function tpe(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=ie(n,[e,t]);r=If(s)}else{const s=[e,2*(t-1)],o=ie(Ad(n),[e,t]),i=ie(pf(n),[e,t]),a=Sl(Xt(o,[0,1],[e,t-2]),1),l=xe(Sl(Xt(i,[0,1],[e,t-2]),1),Tt(-1)),u=Ur([o,a],1),c=Ur([i,l],1),d=ie(Sa(u,c),[s[0],s[1]]);r=If(d)}if(r=Ad(r),3===n.rank&&0!==n.shape[0]){const s=r,o=n.shape[0];r=ie(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),Vd=M({split_:function npe(n,t,e=0){const s={x:E(n,"x","split")};return P.runKernel(oB,s,{numOrSizeSplits:t,axis:e})}}),i_=M({rfft_:function rpe(n,t){D("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,s=Xt(n,f,m),e=t}else if(null!=t&&t>e){const f=n.shape.map(m=>m);f[n.shape.length-1]=t-e,s=Ur([n,vl(f)],n.shape.length-1),e=t}else s=n;const o=As(s),i=ie(Sa(s,o),[r,e]),a=o_(i),l=Math.floor(e/2)+1,u=Ad(a),c=pf(a),d=Vd(u,[l,e-l],u.shape.length-1),h=Vd(c,[l,e-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,ie(Sa(d[0],h[0]),p)}}),eE=M({squaredDifference_:function spe(n,t){let e=E(n,"a","squaredDifference"),r=E(t,"b","squaredDifference");return[e,r]=In(e,r),Qn(e.shape,r.shape),P.runKernel(hB,{a:e,b:r},{})}}),kf=M({squeeze_:function ope(n,t){const e=E(n,"x","squeeze","string_or_numeric");return ie(e,DL(e.shape,t).newShape)}}),Ui=M({stack_:function ipe(n,t=0){const e=df(n,"tensors","stack","string_or_numeric");return D(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&D(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),P.runKernel(kV,e,{axis:t})}}),tE=M({step_:function ape(n,t=0){const r={x:E(n,"x","step")};return P.runKernel(EB,r,{alpha:t})}}),gU=M({stridedSlice_:function lpe(n,t,e,r,s=0,o=0,i=0,a=0,l=0){const c={x:E(n,"x","stridedSlice","string_or_numeric")};return P.runKernel(pB,c,{begin:t,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}}),yU=M({tan_:function upe(n){const e={x:E(n,"x","tan","float32")};return P.runKernel(bB,e)}});function Do(n,t){Au(n);const e=Fi(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return hl(n,null,e,t)}function Bd(n,t,e){if(Au(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Fi(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return hl(n,t,r,e)}function bU(n,t,e){if(Au(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Fi(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return hl(n,t,r,e)}function _U(n,t,e){if(Au(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Fi(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return hl(n,t,r,e)}function vU(n,t,e){if(Au(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Fi(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return hl(n,t=t||r,r,e)}const wU=M({topk_:function cpe(n,t=1,e=!0){const r=E(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const o={x:r},i={k:t,sorted:e},[a,l]=P.runKernel(vB,o,i);return{values:a,indices:l}}}),xU=M({truncatedNormal_:function dpe(n,t=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new HC(t,e,r,!0,s),i=Pi(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),SU=M({unique_:function hpe(n,t=0){const e=E(n,"x","unique","string_or_numeric");D(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[o,i]=P.runKernel(xB,r,s);return{values:o,indices:i}}}),TU=M({unsortedSegmentSum_:function ppe(n,t,e){const r=E(n,"x","unsortedSegmentSum"),s=E(t,"segmentIds","unsortedSegmentSum","int32");return D(Sd(e),()=>"numSegments must be of dtype int"),P.runKernel(TB,{x:r,segmentIds:s},{numSegments:e})}}),Tl=M({unstack_:function fpe(n,t=0){const e=E(n,"x","unstack","string_or_numeric");return D(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),P.runKernel(SB,{value:e},{axis:t})}});function CU(n,t){return s_(n,t,"right")}function EU(n,t=!0,e,r){return P.makeVariable(n,t,e,r)}function IU(n,t){const e=[];for(let o=0;o<t.length;o++)t[o]&&e.push(o);const r=Pi(n,"int32"),s=Pi([e.length,n.length],"int32");for(let o=0;o<e.length;o++){const i=r.indexToLoc(e[o]);s.values.set(i,o*n.length)}return s.toTensor()}function nE(){return(nE=$(function*(n){const t=E(n,"condition","whereAsync","bool"),e=yield t.data(),r=IU(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const rE=function mpe(n){return nE.apply(this,arguments)};function sE(){return(sE=$(function*(n,t,e){const r=E(n,"tensor","boolMask"),s=E(t,"mask","boolMask","bool"),o=null==e?0:e,i=s.rank,a=r.shape;D(i>0,()=>"mask cannot be scalar"),Jr(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+i;m++)l*=a[m];const u=a.slice(0,o).concat([l],a.slice(o+i)),c=ie(r,u),d=ie(s,[-1]),h=yield rE(d),p=kf(h,[1]),f=RC(c,p,o);return n!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f})).apply(this,arguments)}const kU=function gpe(n,t,e){return sE.apply(this,arguments)},NU=M({movingAverage_:function ype(n,t,e,r,s=!0){const o=E(n,"v","movingAverage"),i=E(t,"x","movingAverage"),a=E(e,"decay","movingAverage");MB(o,i),D(Oi(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=Tt(1),u=yt(l,a);let c=xe(yt(i,o),u);if(s){D(null!=r,()=>"When using zeroDebias: true, step is required.");const d=E(r,"step","movingAverage");c=sn(c,yt(l,$d(a,d)))}return qe(o,c)}}),DU=M({scatterND_:function bpe(n,t,e){const r=E(n,"indices","scatterND","int32"),s=E(t,"updates","scatterND");return fC(s,r,e),P.runKernel(jV,{indices:r,updates:s},{shape:e})}}),AU=M({sparseToDense_:function vpe(n,t,e,r=0){const s=E(n,"sparseIndices","sparseToDense","int32"),o=E(t,"sparseValues","sparseToDense","string_or_numeric"),i=E(r,"defaultValue","sparseToDense",o.dtype);return function _pe(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,e,i),P.runKernel(dB,{sparseIndices:s,sparseValues:o,defaultValue:i},{outputShape:e})}}),RU=M({gatherND_:function wpe(n,t){const e=E(t,"indices","gatherND","int32"),s={params:E(n,"x","gatherND","string_or_numeric"),indices:e};return P.runKernel(H3,s)}}),$U=M({dropout_:function Spe(n,t,e,r){const s=E(n,"x","dropout");if(D("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),D(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof En?s.clone():s;const o=function xpe(n,t){if(null==t)return n.shape.slice();if(Oi(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),i=1-t,a=sn(AC(qe(KC(o,0,1,"float32",r),i)),i);return xe(s,a)}});function oE(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function a_(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+r-1);s[o]=t-e*Math.cos(i)}return Do(s,"float32")}function iE(){return(iE=$(function*(n,t,e=1){const r=E(n,"predictions","inTopK"),s=E(t,"targets","inTopK");D(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),D(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Jr(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];D(e>0&&e<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${e}`);const i=yield r.data(),a=yield s.data(),[l,u]=[i.length/o,o],c=AL("bool",l);for(let d=0;d<l;d++){const h=d*u,p=i.subarray(h,h+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<e;m++)if(f[m].index===a[d]){c[d]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),ui(c,s.shape,"bool")})).apply(this,arguments)}const OU=function Tpe(n,t){return iE.apply(this,arguments)},Epe=M({conv2DBackpropFilter_:function Cpe(n,t,e,r,s,o="NHWC",i){let a=n;3===n.rank&&(a=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]])),D(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),D(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),D(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return D(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),D(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),No("conv2dDerFilter",s,i),P.runKernel(f3,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:e})}});function l_(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return xe(n,tE(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function u_(n,t){let e=t;const r=uC(n.shape,t.shape);return r.length>0&&(e=on(e,r)),ie(e,n.shape)}function c_(n,t,e,r){if("linear"===t)return n;if("relu"===t)return Ef(n);if("elu"===t)return kC(n);if("relu6"===t)return XC(n);if("prelu"===t)return GC(n,e);if("leakyrelu"===t)return OC(n,r);if("sigmoid"===t)return zu(n);throw new Error(`Unknown fused activation ${t}.`)}const d_=(n,t)=>!(n>0)||"linear"===t,kpe=M({fusedConv2d_:function Ipe({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===d_(P.state.gradientDepth,l=l||"linear")){D("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=vf(n,t,e,r,s,o,i);return null!=a&&(S=qe(S,a)),c_(S,l,u,c)}const d=E(n,"x","conv2d","float32"),h=E(t,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=ie(d,[1,d.shape[0],d.shape[1],d.shape[2]])),D(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),D(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),No("fused conv2d",r,i);const m="NHWC"===s?p.shape[3]:p.shape[1];D(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),D(Ca(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const g=gf(p.shape,h.shape,e,o,r,i);let y,b;if(null!=a&&(y=E(a,"bias","fused conv2d"),[y]=In(y,d),"NHWC"===s?Qn(g.outShape,y.shape):(D(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),D(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=u){const S=u.shape;if(D(S.length<=1||3===S.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`),1===S.length)D(1===S[0]||S[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===S.length)try{Qn(S,g.outShape)}catch(T){throw Error(`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}b=E(u,"prelu weights","fused conv2d")}const _=(S,T)=>{D("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[I,N,R,F]=T,j=l_(S,R,l);D(yf(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const Q=[r4(N.shape,j,I,e,r),Epe(N,j,I.shape,e,r)];if(null!=F){const V=u_(F,j);Q.push(V)}return Q},v={x:p,filter:h,bias:y,preluActivationWeights:b},w={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?zi((T,I,N)=>{let R=P.runKernel(D1,v,w);return N([I,T,R]),f&&(R=ie(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:_}})(p,h):zi((T,I,N,R)=>{let F=P.runKernel(D1,v,w);return R([I,T,F,N]),f&&(F=ie(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:_}})(p,h,y)}}),Dpe=M({depthwiseConv2dNativeBackpropFilter_:function Npe(n,t,e,r,s,o=[1,1],i){let a=n;3===n.rank&&(a=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]])),P.runKernel(E3,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:e})}}),Rpe=M({depthwiseConv2dNativeBackpropInput_:function Ape(n,t,e,r,s,o=[1,1],i){let a=t,l=!1;3===t.rank&&(l=!0,a=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=P.runKernel(I3,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:n});return l?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Ope=M({fusedDepthwiseConv2d_:function $pe({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===d_(P.state.gradientDepth,l)){let w=e_(n,t,e,r,s,o,i);return null!=a&&(w=qe(w,a)),c_(w,l,u,c)}const d=E(n,"x","depthwiseConv2d","float32"),h=E(t,"filter","depthwiseConv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=ie(d,[1,d.shape[0],d.shape[1],d.shape[2]])),D(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),D(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),D(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==o&&(o=[1,1]),D(Ca(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),No("fused depthwiseConv2d",r,i);const m=gf(p.shape,h.shape,e,o,r,i,!0);let g,y;null!=a&&(g=E(a,"bias","fused conv2d"),[g]=In(g,d),Qn(m.outShape,g.shape)),null!=u&&(y=E(u,"prelu weights","fused depthwiseConv2d"));const b=(w,S)=>{D(yf(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[T,I,N,R]=S,F=l_(w,N,l),j=Rpe(I.shape,F,T,e,r,o,i),q=Dpe(I,F,T.shape,e,r,o,i);return null!=R?[j,q,u_(g,F)]:[j,q]},_={x:p,filter:h,bias:g,preluActivationWeights:y},v={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?zi((S,T,I)=>{let N=P.runKernel(A1,_,v);return I([T,S,N]),f&&(N=ie(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(p,h):zi((S,T,I,N)=>{let R=P.runKernel(A1,_,v);return N([T,S,R,I]),f&&(R=ie(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(p,h,g)}}),Mpe=M({fusedMatMul_:function Fpe({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(!1===d_(P.state.gradientDepth,o)){let F=Wt(n,t,e,r);return null!=s&&(F=qe(F,s)),c_(F,o,i,a)}let l=E(n,"a","fused matMul"),u=E(t,"b","fused matMul");[l,u]=In(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=gn(f),y=gn(m);D(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const _=Qn(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),v=ie(l,e?[g,c,h]:[g,h,c]),w=ie(u,r?[y,p,d]:[y,d,p]);let S,T;null!=s&&(S=E(s,"bias","fused matMul"),[S]=In(S,l),Qn(_,S.shape)),null!=i&&(T=E(i,"prelu weights","fused matMul"));const I=(F,j)=>{const[q,X,Q,V]=j,G=l_(ie(F,Q.shape),Q,o);let W,Y;return e||r?!e&&r?(W=Wt(G,X,!1,!1),Y=Wt(G,q,!0,!1)):e&&!r?(W=Wt(X,G,!1,!0),Y=Wt(q,G,!1,!1)):(W=Wt(X,G,!0,!0),Y=Wt(G,q,!0,!0)):(W=Wt(G,X,!1,!0),Y=Wt(q,G,!0,!1)),null!=s?[W,Y,u_(V,G)]:[W,Y]},N={a:v,b:w,bias:S,preluActivationWeights:T},R={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?zi((j,q,X)=>{const Q=P.runKernel(N1,N,R);return X([j,q,Q]),{value:ie(Q,_),gradFunc:I}})(v,w):zi((j,q,X,Q)=>{const V=P.runKernel(N1,N,R);return Q([j,q,V,X]),{value:ie(V,_),gradFunc:I}})(v,w,S)}}),Lpe=M({hammingWindow_:function Ppe(n){return a_(n,.54,.46)}}),FU=M({hannWindow_:function Vpe(n){return a_(n,.5,.5)}}),MU=M({frame_:function Bpe(n,t,e,r=!1,s=0){let o=0;const i=[];for(;o+t<=n.size;)i.push(Xt(n,o,t)),o+=e;if(r)for(;o<n.size;){const a=o+t-n.size,l=Ur([Xt(n,o,t-a),Rd([a],s)]);i.push(l),o+=e}return 0===i.length?Bd([],[0,t]):ie(Ur(i),[i.length,t])}}),Upe=M({stft_:function zpe(n,t,e,r,s=FU){null==r&&(r=oE(t));const o=MU(n,t,e),i=xe(o,s(t));return i_(i,r)}}),Gpe=M({cropAndResize_:function Wpe(n,t,e,r,s="bilinear",o=0){const i=E(n,"image","cropAndResize"),a=E(t,"boxes","cropAndResize","float32"),l=E(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return D(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),D(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),D(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),D(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),D(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),D("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),P.runKernel(x3,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),jpe=M({flipLeftRight_:function Hpe(n){const t=E(n,"image","flipLeftRight","float32");return D(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),P.runKernel(B3,{image:t},{})}}),Kpe=M({grayscaleToRGB_:function qpe(n){const t=E(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];D(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),D(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,Fd(t,s)}}),Ype=M({rotateWithOffset_:function Xpe(n,t,e=0,r=.5){const s=E(n,"image","rotateWithOffset","float32");return D(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),P.runKernel(IB,{image:s},{radians:t,fillValue:e,center:r})}});function zd(n,t,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=n.shape[0];return e=Math.min(e,i),D(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),D(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),D(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),D(1===t.rank,()=>"scores must be a 1D tensor"),D(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),D(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const Qpe=M({nonMaxSuppression_:function Zpe(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=E(n,"boxes","nonMaxSuppression","float32"),i=E(t,"scores","nonMaxSuppression","float32"),a=zd(o,i,e,r,s);return P.runKernel(SV,{boxes:o,scores:i},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function Jpe(n,t,e){const r=function efe(n,t,e){return function nfe(n,t,e){let r=0,s=n.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=e(t,n[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(n,t,e||tfe)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function tfe(n,t){return n>t?1:n<t?-1:0}function PU(n,t,e,r,s){return aE(n,t,e,r,s,0)}function LU(n,t,e,r,s,o){return aE(n,t,e,r,s,0,!1,o,!0)}function VU(n,t,e,r,s,o){return aE(n,t,e,r,s,o,!0)}function aE(n,t,e,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(BU);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<e&&u.length>0;){const g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:_}=g;if(y<s)break;let v=!1;for(let w=d.length-1;w>=_;--w){const S=rfe(n,b,d[w]);if(S>=r){v=!0;break}if(g.score=g.score*sfe(r,c,S),g.score<=s)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&Jpe(u,g,BU))}const p=d.length,f=e-p;a&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function rfe(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(a-o)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(o,u),g=Math.max(i,c),y=Math.min(a,d),b=Math.min(l,h),_=Math.max(y-m,0)*Math.max(b-g,0);return _/(p+f-_)}function sfe(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function BU(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function lE(){return(lE=$(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=E(n,"boxes","nonMaxSuppressionAsync"),i=E(t,"scores","nonMaxSuppressionAsync"),a=zd(o,i,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=PU(u,c,e,r,s);return o!==n&&o.dispose(),i!==t&&i.dispose(),Do(d,"int32")})).apply(this,arguments)}const lfe=M({nonMaxSuppressionWithScore_:function afe(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=zd(i,a,e,r,s,o),d=P.runKernel(CV,{boxes:i,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function uE(){return(uE=$(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=zd(i,a,e,r,s,o);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=VU(c,d,e,r,s,o);return i!==n&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Do(h,"int32"),selectedScores:Do(p)}})).apply(this,arguments)}const hfe=M({nonMaxSuppressionPadded_:function dfe(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=zd(i,a,e,r,s,null),f=P.runKernel(TV,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:f[0],validOutputs:f[1]}}});function cE(){return(cE=$(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=zd(i,a,e,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=yield Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:m}=LU(h,p,u,c,d,o);return i!==n&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Do(f,"int32"),validOutputs:Tt(m,"int32")}})).apply(this,arguments)}const gfe=M({resizeBilinear_:function mfe(n,t,e=!1,r=!1){const s=E(n,"images","resizeBilinear");D(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),D(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),D(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=ie(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,u=P.runKernel(zV,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return i?ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),bfe=M({resizeNearestNeighbor_:function yfe(n,t,e=!1,r=!1){const s=E(n,"images","resizeNearestNeighbor");D(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),D(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),D("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),D(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=ie(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,u=P.runKernel(BV,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return i?ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),wfe=M({threshold_:function _fe(n,t="binary",e=!1,r=.5){const s=E(n,"image","threshold"),l=s.shape[0]*s.shape[1];let c,d,h,p,u=xe(Do([r]),255);if(D(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),D(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),D("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),D("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[c,d,h]=Vd(s,[1,1,1],-1);const g=xe(c,.2989),y=xe(d,.587),b=xe(h,.114);p=qe(qe(g,y),b)}else p=n;"otsu"===t&&(u=function vfe(n,t){let o,i,a,l,u,c,e=Do([-1]),r=Do([0]),s=Do([0]);for(let d=0;d<n.size-1;d++){o=Xt(n,0,d+1),i=Xt(n,d+1),u=sn(on(o),t),c=sn(on(i),t);const h=on(xe(o,Ld(0,o.size)));a=sn(h,on(o));const p=Rd(i.shape,o.size),f=qe(Ld(0,i.size),p),m=xe(i,f);l=sn(on(m),on(i));const g=yt(a,l),y=yt(a,l),b=xe(u,c);s=xe(xe(b,g),y);const _=Sf(s,r);r=Uu(_,s,r),e=Uu(_,Do([d]),e)}return e}(EC(_n(YC(p),"int32"),ui([]),256),l));const f=e?n_(p,u):Sf(p,u);return _n(xe(f,255),"int32")}}),Sfe=M({transform_:function xfe(n,t,e="nearest",r="constant",s=0,o){const i=E(n,"image","transform","float32"),a=E(t,"transforms","transform","float32");return D(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),D(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),P.runKernel(wB,{image:i,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),Cfe=M({bandPart_:function Tfe(n,t,e){D(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),D(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=E(n,"a","bandPart");D(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);t<0&&(t=o),e<0&&(e=i);const a=ie(Ld(0,o,1,"int32"),[-1,1]),l=Ld(0,i,1,"int32"),u=yt(a,l),c=Tf(n_(u,Tt(+t,"int32")),$C(u,Tt(-e,"int32"))),d=vl([o,i],r.dtype);return ie(Ui(Tl(ie(r,[-1,o,i])).map(h=>Uu(c,h,d))),s)}}),Ife=M({gramSchmidt_:function Efe(n){let t;if(Array.isArray(n)){t=!1,D(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)D(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else t=!0,n=Vd(n,n.shape[0],0).map(s=>kf(s,[0]));D(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push(P.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=xe(on(xe(e[i],o)),e[i]);o=yt(o,a)}return sn(o,xf(o,"euclidean"))}));return t?Ui(e,0):e}});function zU(n,t=!1){return P.tidy(()=>{D(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=DC(e),o=Ta(n);const i=Bd([[1]],[1,1]);let a=Ta(i);const l=e>=r?r:e;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=P.tidy(()=>{const p=Xt(o,[u,u],[e-u,1]),f=xf(p),m=Xt(o,[u,u],[1,1]),g=Uu(Sf(m,0),Bd([[-1]]),Bd([[1]])),y=yt(m,xe(g,f)),b=sn(p,y);a=1===b.shape[0]?Ta(i):Ur([i,Xt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const _=Vi(sn(Wt(g,y),f)),v=Xt(o,[u,0],[e-u,r]),w=xe(_,a),S=ff(a);if(0===u)o=yt(v,Wt(w,Wt(S,v)));else{const N=yt(v,Wt(w,Wt(S,v)));o=Ur([Xt(o,[0,0],[u,r]),N],0)}const T=ff(w),I=Xt(s,[0,u],[e,s.shape[1]-u]);if(0===u)s=yt(I,Wt(Wt(I,a),T));else{const N=yt(I,Wt(Wt(I,a),T));s=Ur([Xt(s,[0,0],[e,u]),N],1)}return[a,o,s]}),ws([c,d,h])}return!t&&e>r&&(s=Xt(s,[0,0],[e,r]),o=Xt(o,[0,0],[r,r])),[s,o]})}const Nfe=M({qr_:function kfe(n,t=!1){if(D(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return zU(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),r=Tl(ie(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=zU(l,t);s.push(u),o.push(c)}),[ie(Ui(s,0),n.shape),ie(Ui(o,0),n.shape)]}}});var Wr=(()=>{return(n=Wr||(Wr={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Wr;var n})();const Ea=M({computeWeightedLoss_:function Dfe(n,t,e=Wr.SUM_BY_NONZERO_WEIGHTS){const r=E(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=E(t,"weights","computeWeightedLoss"));const o=null==s?r:xe(r,s);if(e===Wr.NONE)return o;if(e===Wr.SUM)return on(o);if(e===Wr.MEAN){if(null==s)return Cf(o);{const i=r.size/s.size,a=sn(on(o),on(s));return i>1?sn(a,Tt(i)):a}}if(e===Wr.SUM_BY_NONZERO_WEIGHTS){if(null==s)return sn(on(o),Tt(r.size));{const i=xe(s,wl(r.shape)),a=_n(on(UC(i,Tt(0))),"float32");return sn(on(o),a)}}throw Error(`Unknown reduction: ${e}`)}}),Rfe=M({absoluteDifference_:function Afe(n,t,e,r=Wr.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","absoluteDifference"),o=E(t,"predictions","absoluteDifference");let i=null;null!=e&&(i=E(e,"weights","absoluteDifference")),Jr(s.shape,o.shape,"Error in absoluteDifference: ");const a=Rs(yt(s,o));return Ea(a,i,r)}}),Ofe=M({cosineDistance_:function $fe(n,t,e,r,s=Wr.SUM_BY_NONZERO_WEIGHTS){const o=E(n,"labels","cosineDistance"),i=E(t,"predictions","cosineDistance");let a=null;null!=r&&(a=E(r,"weights","cosineDistance")),Jr(o.shape,i.shape,"Error in cosineDistance: ");const l=Tt(1),u=yt(l,on(xe(o,i),e,!0));return Ea(u,a,s)}}),Mfe=M({hingeLoss_:function Ffe(n,t,e,r=Wr.SUM_BY_NONZERO_WEIGHTS){let s=E(n,"labels","hingeLoss");const o=E(t,"predictions","hingeLoss");let i=null;null!=e&&(i=E(e,"weights","hingeLoss")),Jr(s.shape,o.shape,"Error in hingeLoss: ");const a=Tt(1);s=yt(xe(Tt(2),s),a);const l=Ef(yt(a,xe(s,o)));return Ea(l,i,r)}}),Lfe=M({huberLoss_:function Pfe(n,t,e,r=1,s=Wr.SUM_BY_NONZERO_WEIGHTS){const o=E(n,"labels","huberLoss"),i=E(t,"predictions","huberLoss");let a=null;null!=e&&(a=E(e,"weights","huberLoss")),Jr(o.shape,i.shape,"Error in huberLoss: ");const l=Tt(r),u=Rs(yt(i,o)),c=zC(u,l),d=yt(u,c),h=qe(xe(Tt(.5),ko(c)),xe(l,d));return Ea(h,a,s)}}),Bfe=M({logLoss_:function Vfe(n,t,e,r=1e-7,s=Wr.SUM_BY_NONZERO_WEIGHTS){const o=E(n,"labels","logLoss"),i=E(t,"predictions","logLoss");let a=null;null!=e&&(a=E(e,"weights","logLoss")),Jr(o.shape,i.shape,"Error in logLoss: ");const l=Tt(1),u=Tt(r),c=Vi(xe(o,Md(qe(i,u)))),d=xe(yt(l,o),Md(qe(yt(l,i),u))),h=yt(c,d);return Ea(h,a,s)}}),Ufe=M({meanSquaredError_:function zfe(n,t,e,r=Wr.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","meanSquaredError"),o=E(t,"predictions","meanSquaredError");let i=null;null!=e&&(i=E(e,"weights","meanSquaredError")),Jr(s.shape,o.shape,"Error in meanSquaredError: ");const a=eE(s,o);return Ea(a,i,r)}}),Hfe=M({sigmoidCrossEntropy_:function Gfe(n,t,e,r=0,s=Wr.SUM_BY_NONZERO_WEIGHTS){let o=E(n,"multiClassLabels","sigmoidCrossEntropy");const i=E(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","sigmoidCrossEntropy")),Jr(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Tt(r),c=Tt(1),d=Tt(.5);o=qe(xe(o,yt(c,u)),xe(d,u))}const l=function Wfe(n,t){const e=E(n,"labels","sigmoidCrossEntropyWithLogits"),r=E(t,"logits","sigmoidCrossEntropyWithLogits");Jr(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Ef(r),o=xe(r,e),i=FC(bl(Vi(Rs(r))));return qe(yt(s,o),i)}(o,i);return Ea(l,a,s)}}),Kfe=M({softmaxCrossEntropy_:function qfe(n,t,e,r=0,s=Wr.SUM_BY_NONZERO_WEIGHTS){let o=E(n,"onehotLabels","softmaxCrossEntropy");const i=E(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","softmaxCrossEntropy")),Jr(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Tt(r),c=Tt(1),d=Tt(o.shape[1]);o=qe(xe(o,yt(c,u)),sn(u,d))}const l=function jfe(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return zi((s,o,i)=>{const l=PC(o,[e],!0),u=yt(_n(o,"float32"),l);i([s,u]);const c=Vi(xe(u,s));return{value:on(c,[e]),gradFunc:(p,f)=>{const[m,g]=f,y=wf(p.shape,[e]);return[xe(ie(p,y),yt(_n(m,"float32"),bl(g))),xe(ie(p,y),yt(bl(g),_n(m,"float32")))]}}})(n,t)}(o,i);return Ea(l,a,s)}}),Yfe=M({sparseFillEmptyRows_:function Xfe(n,t,e,r){const s=E(n,"indices","sparseFillEmptyRows","int32"),o=E(t,"values","sparseFillEmptyRows"),i=E(e,"denseShape","sparseFillEmptyRows","int32"),a=E(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u=P.runKernel(aB,{indices:s,values:o,denseShape:i,defaultValue:a});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),Qfe=M({sparseReshape_:function Zfe(n,t,e){const r=E(n,"inputIndices","sparseReshape","int32"),s=E(t,"inputShape","sparseReshape","int32"),o=E(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a=P.runKernel(lB,{inputIndices:r,inputShape:s,newShape:o});return{outputIndices:a[0],outputShape:a[1]}}}),eme=M({sparseSegmentMean_:function Jfe(n,t,e){const r=E(n,"data","sparseSegmentMean"),s=E(t,"indices","sparseSegmentMean","int32"),o=E(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return P.runKernel(uB,{data:r,indices:s,segmentIds:o})}}),nme=M({sparseSegmentSum_:function tme(n,t,e){const r=E(n,"data","sparseSegmentSum"),s=E(t,"indices","sparseSegmentSum","int32"),o=E(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return P.runKernel(cB,{data:r,indices:s,segmentIds:o})}}),sme=M({stringNGrams_:function rme(n,t,e,r,s,o,i,a){const l=E(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=E(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const h=P.runKernel(fB,{data:l,dataSplits:u},{separator:e,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),ime=M({stringSplit_:function ome(n,t,e=!0){const r=E(n,"input","stringSplit","string"),s=E(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=P.runKernel(mB,{input:r,delimiter:s},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),lme=M({stringToHashBucketFast_:function ame(n,t){const e=E(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return P.runKernel(gB,{input:e},r)}}),UU={fft:o_,ifft:If,rfft:i_,irfft:JC},WU={hammingWindow:Lpe,hannWindow:FU,frame:MU,stft:Upe},dE={flipLeftRight:jpe,grayscaleToRGB:Kpe,resizeNearestNeighbor:bfe,resizeBilinear:gfe,rotateWithOffset:Ype,cropAndResize:Gpe,nonMaxSuppression:Qpe,nonMaxSuppressionAsync:function ofe(n,t,e){return lE.apply(this,arguments)},nonMaxSuppressionWithScore:lfe,nonMaxSuppressionWithScoreAsync:function ufe(n,t,e){return uE.apply(this,arguments)},nonMaxSuppressionPadded:hfe,nonMaxSuppressionPaddedAsync:function pfe(n,t,e){return cE.apply(this,arguments)},threshold:wfe,transform:Sfe},GU={bandPart:Cfe,gramSchmidt:Ife,qr:Nfe},HU={absoluteDifference:Rfe,computeWeightedLoss:Ea,cosineDistance:Ofe,hingeLoss:Mfe,huberLoss:Lfe,logLoss:Bfe,meanSquaredError:Ufe,sigmoidCrossEntropy:Hfe,softmaxCrossEntropy:Kfe},jU={sparseFillEmptyRows:Yfe,sparseReshape:Qfe,sparseSegmentMean:eme,sparseSegmentSum:nme},qU={stringNGrams:sme,stringSplit:ime,stringToHashBucketFast:lme},ume={sgd:yl.sgd,momentum:yl.momentum,adadelta:yl.adadelta,adagrad:yl.adagrad,rmsprop:yl.rmsprop,adamax:yl.adamax,adam:yl.adam},cme="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:n=>n();function dme(){return new Promise(n=>cme(()=>n()))}function hme(n,t){const e=n[0].length;n.forEach((s,o)=>{D(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),D(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,o)=>{for(let i=0;i<e;i++)D(i===t||s[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function pme(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var ci=(()=>{return(n=ci||(ci={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",ci;var n})();function fme(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const o=e[s],i=r[r.length-e.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${o} but shape[${s+n}] = ${a}`)}else r[i]=o}return r}function mme(n){const t={FIRST_DIM_SIZE:ci.FIRST_DIM_SIZE,VALUE_ROWIDS:ci.VALUE_ROWIDS,ROW_LENGTHS:ci.ROW_LENGTHS,ROW_SPLITS:ci.ROW_SPLITS,ROW_LIMITS:ci.ROW_LIMITS,ROW_STARTS:ci.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function gme(n){return 0===n.length?0:n[0]===ci.FIRST_DIM_SIZE?n.length-1:n.length}function yme(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const o=n[s],i=t[s+1];if(o>=0&&i>=0&&1!==o&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${o} but ragged tensor input.flatValues.shape[${s-n.length}] = ${i}`)}}const hE=30;function bme(n){return n<=hE?n:Cb(n,Math.floor(Math.sqrt(n)))}function _me(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function vme(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=t.length;for(let i=0;i<o;++i)s=s.concat([n[i+1]/t[i],t[i]]);s=s.concat(n.slice(o+1))}return s}function wme(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<n;++i)i>=2*t+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function xme(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let o=1;o<n.length;++o)s.push(o<=t.length?r?t[o-1]*n[o]:n[o]/t[o-1]:n[o]);return s}function Sme(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function Tme(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}const Cme=1.7580993408473768,Eme=1.0507009873554805,Ime=.3275911,kme=.254829592,Nme=-.284496736,Dme=1.421413741,Ame=-1.453152027,Rme=1.061405429;function $me(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function Ome(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function Fme(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function Mme(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function Pme(n,t){return{real:n[2*t],imag:n[2*t+1]}}function Lme(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function Vme(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function Bme(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const zme=/->/g;function Ume(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(zme,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");D(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const o=r.split(","),i=o.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const p=s[h];if(!o.some(f=>-1!==f.indexOf(p)))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);-1===a.indexOf(p)&&a.push(p)}for(let h=0;h<r.length;++h){const p=r[h];-1===a.indexOf(p)&&","!==p&&a.push(p)}const l=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<o[h].length;++p)l[h].push(a.indexOf(o[h][p]))}const u=a.length,d=[];for(let h=s.length;h<u;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function Wme(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function Gme(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const o=e[s].shape;for(let i=0;i<t[s].length;++i)void 0===r[t[s][i]]?r[t[s][i]]=o[i]:D(r[t[s][i]]===o[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function Hme(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<e.length;++i){const l=qme(t,e[i]);for(const u of l)-1===o.indexOf(u)&&(r[i].push(u),o.push(u))}return{path:e,steps:r}}function jme(n){return n.every((t,e)=>t===e)}function qme(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function Kme(n,t,e=0){let r=[];if("number"==typeof t)D(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{D(t.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(-1!==o){const i=t.reduce((a,l)=>l>0?a+l:a);t[o]=n.shape[e]-i}D(n.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function Xme(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function Yme(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function Zme(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function Qme(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function Jme(n,t){return`size ${n} must be non-negative, not ${t}`}function ege(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function tge(n,t){return`Input to reshape is a SparseTensor with ${gn(n)}\n  dense values, but the requested shape requires a multiple of ${gn(t)}. inputShape=${n} outputShape= ${t}`}function nge(n,t){return`Input to reshape is a tensor with ${gn(n)} dense values, but the requested shape has ${gn(t)}. inputShape=${n} outputShape=${t}`}function rge(){return"segment ids must be >= 0"}function sge(){return"segment ids are not increasing"}function oge(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function ige(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function age(n,t){let r,e=!1;for(n<=hE?(r=n,e=!0):r=Cb(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=Cb(n,r+1);return r}function lge(n,t,e){const r=[],s=n.length;for(let o=0;o<s;o++)r.push(o!==t?n[o]:e);return r}function uge(n,t,e,r){const s=t.shape.length,o=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=n.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<e;d++)a.push(n.shape[d]),u*=n.shape[d];for(let d=r;d<s;d++)a.push(t.shape[d]);for(let d=e+1;d<o;d++)a.push(n.shape[d]),c*=n.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function cge(n){try{return n.map(t=>Rb(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function dge(n){return n.map(t=>sf(t))}at().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var YU,eo=(()=>{return(n=eo||(eo={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",eo;var n})();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(YU||(YU={}));const fE={};function ZU(n){return fE[n]}function x(n,t,e,r,s){const o=t.inputParams[n];if(o&&void 0!==o.inputIndexStart){const a=o.inputIndexStart,l=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?a+1:o.inputIndexEnd;if("tensor"===o.type)return ns(t.inputNames[o.inputIndexStart],e,r,s);if("tensors"===o.type)return t.inputNames.slice(a,l).map(h=>ns(h,e,r,s));const u=ns(t.inputNames.slice(a)[0],e,r,s),c=u.dataSync();return"number"===o.type?c[0]:$u(u.shape,c)}const i=t.attrParams[n];return i&&i.value}function ns(n,t,e,r){const[s,o]=$s(n);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const i=e.currentContextIds.find(a=>!!t[h_(s,a)]);return void 0!==i?t[h_(s,i)][o]:void 0}function Wi(n,t){const[e,r,s]=$s(n);return[h_(e,t&&t.currentContextId),r,s]}function h_(n,t){return t?`${n}-${t}`:n}function $s(n){const t=n.split(":");if(1===t.length)return[n,0,void 0];const r=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),r]}function p_(n,t,e){let r=x("pad",n,t,e);if("explicit"===r){r=x("explicitPaddings",n,t,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function Ia(n){return n.kept?n:Ta(n)}const pge=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],fge=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mge=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],gge=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],yge=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],bge=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_ge=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],vge=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],wge=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],xge=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Sge=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Tge=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Cge=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Ege=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ige=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],kge=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Nge=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Dge=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Age=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class QU{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[Kn,mo,zs,kt,Mt,Pt,ce,oe,O,we,je,Nt,gt,Bt,On,Bn,rr,Sn,Kr].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(t,e={}){const s=[],o=[],i=[],a=t.node.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):"Const"===g.op?o.push(m[g.name]):(null==g.input||0===g.input.length)&&i.push(m[g.name]),m),{});let l=[];const u=[];let c={},d={};null!=e&&(c=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[_,,v]=Wi(y),w=a[_];if(null!=w.outputs){const S=w.outputs.indexOf(v);-1!==S&&(g.inputNames[b]=`${_}:${S}`)}g.inputs.push(w),w.children.push(g)})}),0===Object.keys(d).length?h.forEach(m=>{const g=a[m];0===g.children.length&&u.push(g)}):Object.keys(d).forEach(m=>{const[g]=Wi(m),y=a[g];null!=y&&(y.signatureKey=d[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=Wi(m),y=a[g];y&&(y.signatureKey=c[m],l.push(y))}):l=s;let p={};null!=t.library&&null!=t.library.function&&(p=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:a,inputs:l,outputs:u,weights:o,placeholders:s,signature:e,functions:p};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=ZU(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=mE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=mE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=SE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=SE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=yE(t.attr,o.tfName,o.defaultValue||0),void 0===a&&o.tfDeprecatedName&&(a=yE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=xE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=xE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=gE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=gE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=CE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=CE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=wE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=wE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=TE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=TE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=_E(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=_E(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=vE(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=vE(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=eW(t.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=eW(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(t){const e=t.nodeDef,s=[];let o={};null!=e&&(o=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const i=[],a=[];t.signature.inputArg.forEach(d=>{const[h]=Wi(d.name),p={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:bE(d.type),type:"dtype"}},children:[]};p.signatureKey=d.name,i.push(p),o[h]=p}),Object.keys(o).forEach(d=>{const h=o[d];h.inputNames.forEach((p,f)=>{const[m,,g]=Wi(p),y=o[m];if(null!=y.outputs){const b=y.outputs.indexOf(g);-1!==b&&(h.inputNames[f]=`${m}:${b}`)}h.inputs.push(y),y.children.push(h)})});const u=t.ret;t.signature.outputArg.forEach(d=>{const[h,p]=Wi(u[d.name]),f=o[h];null!=f&&(f.defaultOutput=p,a.push(f))});const c=this.mapArgsToSignature(t);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:[],signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function JU(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function Rge(n){const t=at().global;if(void 0!==t.atob)return t.atob(n);if("undefined"!=typeof Buffer)return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function mE(n,t,e,r=!1){const s=n[t];return null!=s?JU(s.s,r):e}function gE(n,t,e){const r=n[t];return r?r.b:e}function yE(n,t,e){const r=n[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function bE(n){switch("string"==typeof n&&(n=eo[n]),n){case eo.DT_FLOAT:case eo.DT_HALF:return"float32";case eo.DT_INT32:case eo.DT_INT64:case eo.DT_INT8:case eo.DT_UINT8:return"int32";case eo.DT_BOOL:return"bool";case eo.DT_DOUBLE:return"float32";case eo.DT_STRING:return"string";default:return null}}function eW(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function _E(n,t,e){const r=n[t];return r&&r.type?bE(r.type):e}function vE(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>bE(s)):e}function tW(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function wE(n,t,e){const r=n[t];return r&&r.shape?tW(r.shape):e}function xE(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function SE(n,t,e,r=!1){const s=n[t];return s&&s.list&&s.list.s?s.list.s.map(o=>JU(o,r)):e}function TE(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>tW(s)):e}function CE(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class $ge{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(t){return ns(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return ns(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return yE(this.node.rawAttrs,t,e);if(null!=r.s)return mE(this.node.rawAttrs,t,e);if(null!=r.b)return gE(this.node.rawAttrs,t,e);if(null!=r.shape)return wE(this.node.rawAttrs,t,e);if(null!=r.type)return _E(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return xE(this.node.rawAttrs,t,e);if(null!=r.list.s)return SE(this.node.rawAttrs,t,e);if(null!=r.list.shape)return TE(this.node.rawAttrs,t,e);if(null!=r.list.b)return CE(this.node.rawAttrs,t,e);if(null!=r.list.type)return vE(this.node.rawAttrs,t,e)}return e}}function Ao(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){D(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=t[r];D(s<0||o<0||s===o,()=>e+` Shapes ${n} and ${t} must match`)}}}function nW(n){return!("number"==typeof n||n.some(t=>t<0))}function Nf(n,t,e){let r=EE(n,e);const s=!nW(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(o=>{r=EE(o.shape,r)}),!nW(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function EE(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const s=n[r],o=t[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=s>=0?s:o}return e}class Mge{constructor(t,e,r,s,o,i,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Tt(0),Li(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),Ao(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,Li(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(0===t.length)return ui([],[0].concat(this.elementShape));const r=this.readMany(t);return Ao(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Ui(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return ui([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return Ao(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Ur(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,Tl(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===r?0:e.size/r,i=[];Lt(()=>{e=ie(e,[1,r,o]);for(let l=0;l<t.length;++l)i[l]=ie(Xt(e,[0,0===l?0:s[l-1],0],[1,t[l],o]),this.elementShape);return i});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,i)}}class Gu{constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,null!=t&&t.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Ao(e,o.shape,"TensorList shape mismatch: "),Li(o)}),this.idTensor=Tt(0),this.maxNumElements=s,Li(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Gu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Ao(t,this.elementShape,"TensorList shape mismatch: ");const s=Nf(this.elementShape,this.tensors,t);return Lt(()=>{const o=this.tensors.map(i=>ie(i,s));return Ui(o,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=Nf(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,Ao(s.shape,t,"TensorList shape mismatch: "),ie(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Ao(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Li(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Gu([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);Ao(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=Nf(this.elementShape,this.tensors,e);return ie(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Ao(this.elementShape,e.shape,"TensorList shape mismatch: "),Li(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Ao(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=Nf(this.elementShape,this.tensors,r);return 0===t.length?ui([],[0].concat(s)):Lt(()=>{const o=t.map(i=>ie(this.tensors[i],s));return Ui(o,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Ao(this.elementShape,e,"TensorList shape mismatch: ");const r=Nf(this.elementShape,this.tensors,e);return 0===this.size()?ui([],[0].concat(r)):Lt(()=>{const s=this.tensors.map(o=>ie(o,r));return Ur(s,0)})}}const zge=function(){var n=$(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const s=x("thenBranch",t,e,r),o=x("elseBranch",t,e,r),i=x("cond",t,e,r),a=x("args",t,e,r);return(yield i.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[o].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=x("body",t,e,r),o=x("cond",t,e,r),i=x("args",t,e,r),a=yield r.functionMap[o].executeFunctionAsync(i,r.tensorArrayMap,r.tensorListMap),l=i.map(d=>d.id);let u=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let c=i;for(;u[0];){const d=c;c=yield r.functionMap[s].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);const h=c.map(f=>f.id);d.forEach(f=>{!f.kept&&-1===l.indexOf(f.id)&&-1===h.indexOf(f.id)&&f.dispose()});const p=yield r.functionMap[o].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);u=yield p[0].data(),p.forEach(f=>{!f.kept&&-1===l.indexOf(f.id)&&-1===h.indexOf(f.id)&&f.dispose()})}return c}case"LoopCond":return[Ia(x("pred",t,e,r))];case"Switch":{const s=x("pred",t,e,r);let o=x("data",t,e,r);return o.kept||(o=Ia(o)),(yield s.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const s=t.inputNames.find(o=>void 0!==ns(o,e,r));return s?[Ia(ns(s,e,r))]:void 0}case"Enter":{const s=x("frameName",t,e,r),o=x("tensor",t,e,r);return r.enterFrame(s),[Ia(o)]}case"Exit":{const s=x("tensor",t,e,r);return r.exitFrame(),[Ia(s)]}case"NextIteration":{const s=x("tensor",t,e,r);return r.nextIteration(),[Ia(s)]}case"TensorArrayV3":{const s=x("size",t,e,r),o=x("dtype",t,e,r),i=x("elementShape",t,e,r),a=x("dynamicSize",t,e,r),l=x("clearAfterRead",t,e,r),u=x("identicalElementShapes",t,e,r),c=x("name",t,e,r),d=new Mge(c,o,s,i,u,a,l);return r.addTensorArray(d),[d.idTensor,Tt(1)]}case"TensorArrayWriteV3":{const s=x("tensorArrayId",t,e,r),o=x("index",t,e,r),i=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.write(o,i),[a.idTensor]}case"TensorArrayReadV3":{const s=x("tensorArrayId",t,e,r),o=x("index",t,e,r);return[r.getTensorArray(s.id).read(o)]}case"TensorArrayGatherV3":{const s=x("tensorArrayId",t,e,r),o=x("indices",t,e,r),i=x("dtype",t,e,r);return[r.getTensorArray(s.id).gather(o,i)]}case"TensorArrayScatterV3":{const s=x("tensorArrayId",t,e,r),o=x("indices",t,e,r),i=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.scatter(o,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=x("tensorArrayId",t,e,r),o=r.getTensorArray(s.id),i=x("dtype",t,e,r);return[o.concat(i)]}case"TensorArraySplitV3":{const s=x("tensorArrayId",t,e,r),o=x("tensor",t,e,r),i=x("lengths",t,e,r),a=r.getTensorArray(s.id);return a.split(i,o),[a.idTensor]}case"TensorArraySizeV3":{const s=x("tensorArrayId",t,e,r);return[Tt(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=x("tensorArrayId",t,e,r),o=r.getTensorArray(s.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const s=x("tensorListId",t,e,r),o=x("index",t,e,r),i=x("tensor",t,e,r),a=r.getTensorList(s.id);return a.setItem(o,i),[a.idTensor]}case"TensorListGetItem":{const s=x("tensorListId",t,e,r),o=x("index",t,e,r),i=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).getItem(o,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=x("indices",t,e,r),l=function Vge(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Gu([],e,n.dtype,r),i=Tl(n,0);return t.forEach((a,l)=>{o.setItem(a,i[l])}),o}(x("tensor",t,e,r),s,x("elementShape",t,e,r),x("numElements",t,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=x("elementShape",t,e,r),o=x("elementDType",t,e,r);let i;i="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=x(i,t,e,r),u=function Lge(n,t,e,r){return new Gu([],n,t,r)}(s,o,0,"TensorListReserve"===t.op?-1:a);return r.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=x("tensorListId",t,e,r),o=x("indices",t,e,r),i=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).gather(o,a,i)]}case"TensorListStack":{const s=x("tensorListId",t,e,r),o=x("elementShape",t,e,r),i=x("elementDType",t,e,r),a=x("numElements",t,e,r);return[r.getTensorList(s.id).stack(o,i,a)]}case"TensorListFromTensor":{const a=function Pge(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);Ao(n.shape.slice(1),t,"TensorList shape mismatch: ");const o=Tl(n);return new Gu(o,t,r)}(x("tensor",t,e,r),x("elementShape",t,e,r),x("elementDType",t,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=x("tensorListId",t,e,r),o=r.getTensorList(s.id),i=x("dtype",t,e,r),a=x("elementShape",t,e,r);return[o.concat(i,a)]}case"TensorListPushBack":{const s=x("tensorListId",t,e,r),o=x("tensor",t,e,r),i=r.getTensorList(s.id);return i.pushBack(o),[i.idTensor]}case"TensorListPopBack":{const s=x("tensorListId",t,e,r),o=x("elementShape",t,e,r),i=x("elementDType",t,e,r);return[r.getTensorList(s.id).popBack(o,i)]}case"TensorListSplit":{const s=x("tensor",t,e,r),o=x("elementShape",t,e,r),a=function Bge(n,t,e){let r=0;const s=t.map(c=>(r+=c,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const i=EE(n.shape.slice(1),e),a=0===r?0:n.size/r,l=Lt(()=>{const c=[];n=ie(n,[1,r,a]);for(let d=0;d<t.length;++d)c[d]=ie(Xt(n,[0,0===d?0:s[d-1],0],[1,t[d],a]),i);return n.dispose(),c}),u=new Gu([],e,n.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}(s,x("lengths",t,e,r),o);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=x("tensorListId",t,e,r);return[Tt(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=x("tensorListId",t,e,r),o=x("size",t,e,r),a=r.getTensorList(s.id).resize(o);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s){return n.apply(this,arguments)}}();function rW(n,t,e){const[r,s]=x("fusedOps",n,t,e),o="biasadd"===r,i=!o,a="prelu"===s,l="fusedbatchnorm"===r,u=x("numArgs",n,t,e);if(o){if(a&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=x("strides",n,t,e),d=p_(n,t,e),h=x("dataFormat",n,t,e).toUpperCase(),p=x("dilations",n,t,e);let[f,m]=x("args",n,t,e);return i&&(m=f,f=void 0),{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:x("leakyreluAlpha",n,t,e)}}function IE(n,t,e){return{boxes:x("boxes",n,t,e),scores:x("scores",n,t,e),maxOutputSize:x("maxOutputSize",n,t,e),iouThreshold:x("iouThreshold",n,t,e),scoreThreshold:x("scoreThreshold",n,t,e),softNmsSigma:x("softNmsSigma",n,t,e)}}const Gge=function(){var n=$(function*(t,e,r,s,o=wt){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c,softNmsSigma:d}=IE(t,e,r),h=yield o.image.nonMaxSuppressionWithScoreAsync(i,a,l,u,c,d);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=IE(t,e,r),d=x("padToMaxOutputSize",t,e,r),h=yield o.image.nonMaxSuppressionPaddedAsync(i,a,l,u,c,d);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=IE(t,e,r);return[yield o.image.nonMaxSuppressionAsync(i,a,l,u,c)]}case"Where":{const i=o.cast(x("condition",t,e,r),"bool"),a=[yield o.whereAsync(i)];return i.dispose(),a}case"ListDiff":return o.setdiff1dAsync(x("x",t,e,r),x("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,o){return n.apply(this,arguments)}}();class qge{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Tt(0),this.tensorMap=new Map,Li(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Tt(this.size(),"int32")}import(t,e){var r=this;return $(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return r.tensorMap.forEach(o=>o.dispose()),r.tensorMap.clear(),Lt(()=>{const o=Tl(e),i=s.length,a=o.length;D(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let l=0;l<i;l++){const u=s[l],c=o[l];Li(c),r.tensorMap.set(u,c)}return r.handle})})()}find(t,e){var r=this;return $(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return Lt(()=>{const o=[];for(let i=0;i<s.length;i++){const l=r.findWithDefault(s[i],e);o.push(l)}return Ui(o)})})()}findWithDefault(t,e){const r=this.tensorMap.get(t);return null!=r?r:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const Kge=function(){var n=$(function*(t,e,r,s){switch(t.op){case"HashTable":case"HashTableV2":{const o=x("keyDType",t,e,r),i=x("valueDType",t,e,r),a=new qge(o,i);return s.addHashTable(t.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const o=x("tableHandle",t,e,r,s),i=x("keys",t,e,r),a=x("values",t,e,r);return[yield s.getHashTableById(o.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const o=x("tableHandle",t,e,r,s),i=x("keys",t,e,r),a=x("defaultValue",t,e,r);return[yield s.getHashTableById(o.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=x("tableHandle",t,e,r,s);return[s.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,o){return n.apply(this,arguments)}}();function sW(n,t,e,r,s=Lt){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(x("a",n,t,e),x("b",n,t,e))];case"AddN":return[r.addN(x("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(x("a",n,t,e),x("b",n,t,e))];case"Mul":return[r.mul(x("a",n,t,e),x("b",n,t,e))];case"RealDiv":case"Div":return[r.div(x("a",n,t,e),x("b",n,t,e))];case"DivNoNan":return[r.divNoNan(x("a",n,t,e),x("b",n,t,e))];case"FloorDiv":return[r.floorDiv(x("a",n,t,e),x("b",n,t,e))];case"Sub":return[r.sub(x("a",n,t,e),x("b",n,t,e))];case"Minimum":return[r.minimum(x("a",n,t,e),x("b",n,t,e))];case"Maximum":return[r.maximum(x("a",n,t,e),x("b",n,t,e))];case"Pow":return[r.pow(x("a",n,t,e),x("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"basic_math":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(x("x",n,t,e))];case"Acos":return[r.acos(x("x",n,t,e))];case"Acosh":return[r.acosh(x("x",n,t,e))];case"Asin":return[r.asin(x("x",n,t,e))];case"Asinh":return[r.asinh(x("x",n,t,e))];case"Atan":return[r.atan(x("x",n,t,e))];case"Atan2":return[r.atan2(x("x",n,t,e),x("y",n,t,e))];case"Atanh":return[r.atanh(x("x",n,t,e))];case"Ceil":return[r.ceil(x("x",n,t,e))];case"Complex":return[r.complex(x("real",n,t,e),x("imag",n,t,e))];case"Cos":return[r.cos(x("x",n,t,e))];case"Cosh":return[r.cosh(x("x",n,t,e))];case"Elu":return[r.elu(x("x",n,t,e))];case"Erf":return[r.erf(x("x",n,t,e))];case"Exp":return[r.exp(x("x",n,t,e))];case"Expm1":return[r.expm1(x("x",n,t,e))];case"Floor":return[r.floor(x("x",n,t,e))];case"Log":return[r.log(x("x",n,t,e))];case"Log1p":return[r.log1p(x("x",n,t,e))];case"Imag":return[r.imag(x("x",n,t,e))];case"Neg":return[r.neg(x("x",n,t,e))];case"Reciprocal":return[r.reciprocal(x("x",n,t,e))];case"Real":return[r.real(x("x",n,t,e))];case"Relu":return[r.relu(x("x",n,t,e))];case"Round":return[r.round(x("x",n,t,e))];case"Selu":return[r.selu(x("x",n,t,e))];case"Sigmoid":return[r.sigmoid(x("x",n,t,e))];case"Sin":return[r.sin(x("x",n,t,e))];case"Sign":return[r.sign(x("x",n,t,e))];case"Sinh":return[r.sinh(x("x",n,t,e))];case"Softplus":return[r.softplus(x("x",n,t,e))];case"Sqrt":return[r.sqrt(x("x",n,t,e))];case"Square":return[r.square(x("x",n,t,e))];case"Tanh":return[r.tanh(x("x",n,t,e))];case"Tan":return[r.tan(x("x",n,t,e))];case"ClipByValue":return[r.clipByValue(x("x",n,t,e),x("clipValueMin",n,t,e),x("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(x("x",n,t,e))];case"Rsqrt":return[r.rsqrt(ns(n.inputNames[0],t,e))];case"Prod":return[r.prod(x("x",n,t,e),x("axes",n,t,e))];case"LeakyRelu":return[r.leakyRelu(x("x",n,t,e),x("alpha",n,t,e))];case"Prelu":return[r.prelu(x("x",n,t,e),x("alpha",n,t,e))];case"IsNan":return[r.isNaN(ns(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"control":return zge(i,a,l);case"convolution":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"Conv1D":{const s=x("stride",n,t,e),o=x("pad",n,t,e),i=x("dataFormat",n,t,e).toUpperCase(),a=x("dilation",n,t,e);return[r.conv1d(x("x",n,t,e),x("filter",n,t,e),s,o,i,a)]}case"Conv2D":{const s=x("strides",n,t,e),o=p_(n,t,e),i=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv2d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=rW(n,t,e);return[r.fused.conv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=rW(n,t,e);return[r.fused.depthwiseConv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=x("outputShape",n,t,e),o=x("strides",n,t,e),i=p_(n,t,e);return[r.conv2dTranspose(x("x",n,t,e),x("filter",n,t,e),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=x("strides",n,t,e),o=p_(n,t,e),i=x("dilations",n,t,e),a=x("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(x("input",n,t,e),x("filter",n,t,e),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=x("strides",n,t,e),o=x("pad",n,t,e),i=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv3d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=x("strides",n,t,e),o=x("pad",n,t,e),i=x("kernelSize",n,t,e);return[r.avgPool(x("x",n,t,e),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=x("strides",n,t,e),o=x("pad",n,t,e),i=x("kernelSize",n,t,e);return[r.maxPool(x("x",n,t,e),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=x("strides",n,t,e),o=x("pad",n,t,e),i=x("kernelSize",n,t,e),a=x("includeBatchInIndex",n,t,e),{result:l,indexes:u}=r.maxPoolWithArgmax(x("x",n,t,e),[i[1],i[2]],[s[1],s[2]],o,a);return[l,u]}case"AvgPool3D":{const s=x("strides",n,t,e),o=x("pad",n,t,e),i=x("kernelSize",n,t,e);return[r.avgPool3d(x("x",n,t,e),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=x("strides",n,t,e),o=x("pad",n,t,e),i=x("kernelSize",n,t,e);return[r.maxPool3d(x("x",n,t,e),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=x("strides",n,t,e),o=x("pad",n,t,e),i=x("dilations",n,t,e),a=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(x("x",n,t,e),x("filter",n,t,e),[a,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"creation":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"Fill":{const s=x("shape",n,t,e),o=x("dtype",n,t,e),i=x("value",n,t,e);return[r.fill(s,i,o)]}case"LinSpace":{const s=x("start",n,t,e),o=x("stop",n,t,e),i=x("num",n,t,e);return[r.linspace(s,o,i)]}case"Multinomial":{const s=x("logits",n,t,e),o=x("numSamples",n,t,e),i=x("seed",n,t,e);return[r.multinomial(s,o,i)]}case"OneHot":{const s=x("indices",n,t,e),o=x("depth",n,t,e),i=x("onValue",n,t,e),a=x("offValue",n,t,e),l=x("dtype",n,t,e);return[r.oneHot(s,o,i,a,l)]}case"Ones":return[r.ones(x("shape",n,t,e),x("dtype",n,t,e))];case"OnesLike":return[r.onesLike(x("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(x("shape",n,t,e),x("dtype",n,t,e),x("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(x("shape",n,t,e),x("minval",n,t,e),x("maxval",n,t,e),x("dtype",n,t,e))];case"Range":{const s=x("start",n,t,e),o=x("stop",n,t,e),i=x("step",n,t,e);return[r.range(s,o,i,x("dtype",n,t,e))]}case"TruncatedNormal":{const s=x("shape",n,t,e),o=x("mean",n,t,e),i=x("stdDev",n,t,e),a=x("seed",n,t,e);return[r.truncatedNormal(s,o,i,x("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(x("shape",n,t,e),x("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"dynamic":return Gge(i,a,l);case"evaluation":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"LowerBound":{const s=x("sortedSequence",n,t,e),o=x("values",n,t,e);return[r.lowerBound(s,o)]}case"TopKV2":{const s=x("x",n,t,e),o=x("k",n,t,e),i=x("sorted",n,t,e),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=x("sortedSequence",n,t,e),o=x("values",n,t,e);return[r.upperBound(s,o)]}case"Unique":{const s=x("x",n,t,e),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=x("x",n,t,e),o=x("axis",n,t,e),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"image":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"ResizeBilinear":{const s=x("images",n,t,e),o=x("size",n,t,e),i=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=x("images",n,t,e),o=x("size",n,t,e),i=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=x("image",n,t,e),o=x("boxes",n,t,e),i=x("boxInd",n,t,e),a=x("cropSize",n,t,e),l=x("method",n,t,e),u=x("extrapolationValue",n,t,e);return[r.image.cropAndResize(s,o,i,a,l,u)]}case"ImageProjectiveTransformV3":{const s=x("images",n,t,e),o=x("transforms",n,t,e),i=x("outputShape",n,t,e),a=x("fillValue",n,t,e),l=x("interpolation",n,t,e),u=x("fillMode",n,t,e);return[r.image.transform(s,o,l.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"graph":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const s=x("default",n,t,e);return[ns(n.name,t,e)||s];case"Placeholder":return[ns(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ia(x("x",n,t,e))];case"IdentityN":return x("x",n,t,e).map(c=>Ia(c));case"Shape":return[r.tensor1d(x("x",n,t,e).shape,"int32")];case"ShapeN":return x("x",n,t,e).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(x("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(x("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=x("x",n,t,e),a=x("data",n,t,e),l=x("message",n,t,e),u=x("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"logical":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"Equal":return[r.equal(x("a",n,t,e),x("b",n,t,e))];case"NotEqual":return[r.notEqual(x("a",n,t,e),x("b",n,t,e))];case"Greater":return[r.greater(x("a",n,t,e),x("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(x("a",n,t,e),x("b",n,t,e))];case"Less":return[r.less(x("a",n,t,e),x("b",n,t,e))];case"LessEqual":return[r.lessEqual(x("a",n,t,e),x("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(x("a",n,t,e),x("b",n,t,e))];case"LogicalNot":return[r.logicalNot(x("a",n,t,e))];case"LogicalOr":return[r.logicalOr(x("a",n,t,e),x("b",n,t,e))];case"Select":case"SelectV2":return[r.where(x("condition",n,t,e),x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"matrices":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(x("a",n,t,e),x("b",n,t,e),x("transposeA",n,t,e),x("transposeB",n,t,e))];case"Einsum":return[r.einsum(x("equation",n,t,e),...x("tensors",n,t,e))];case"Transpose":return[r.transpose(x("x",n,t,e),x("perm",n,t,e))];case"_FusedMatMul":const[s,o]=x("fusedOps",n,t,e),i="biasadd"===s,a="prelu"===o,l=x("numArgs",n,t,e),u=x("leakyreluAlpha",n,t,e);if(i){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=x("args",n,t,e);return[r.fused.matMul({a:x("a",n,t,e),b:x("b",n,t,e),transposeA:x("transposeA",n,t,e),transposeB:x("transposeB",n,t,e),bias:c,activation:o,preluActivationWeights:d,leakyreluAlpha:u})];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"normalization":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(x("x",n,t,e),x("axis",n,t,e),x("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(x("x",n,t,e),x("mean",n,t,e),x("variance",n,t,e),x("offset",n,t,e),x("scale",n,t,e),x("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(x("x",n,t,e),x("radius",n,t,e),x("bias",n,t,e),x("alpha",n,t,e),x("beta",n,t,e))];case"Softmax":return[r.softmax(x("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(x("x",n,t,e))];case"SparseToDense":return[r.sparseToDense(x("sparseIndices",n,t,e),x("outputShape",n,t,e),x("sparseValues",n,t,e),x("defaultValue",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"reduction":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"Max":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.max(x("x",n,t,e),a,l)]}case"Mean":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.mean(x("x",n,t,e),a,l)]}case"Min":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.min(x("x",n,t,e),a,l)]}case"Sum":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.sum(x("x",n,t,e),a,l)]}case"All":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.all(x("x",n,t,e),a,l)]}case"Any":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.any(x("x",n,t,e),a,l)]}case"ArgMax":{const a=x("axis",n,t,e);return[r.argMax(x("x",n,t,e),a)]}case"ArgMin":{const a=x("axis",n,t,e);return[r.argMin(x("x",n,t,e),a)]}case"Prod":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.prod(x("x",n,t,e),a,l)]}case"Cumprod":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),u=x("reverse",n,t,e);return[r.cumprod(x("x",n,t,e),a,l,u)]}case"Cumsum":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),u=x("reverse",n,t,e);return[r.cumsum(x("x",n,t,e),a,l,u)]}case"Bincount":const s=x("x",n,t,e),o=x("weights",n,t,e),i=x("size",n,t,e);return[r.bincount(s,o,i)];case"DenseBincount":{const a=x("x",n,t,e),l=x("weights",n,t,e),u=x("size",n,t,e),c=x("binaryOutput",n,t,e);return[r.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"slice_join":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=x("n",n,t,e),o=x("axis",n,t,e);let i=x("tensors",n,t,e);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=x("x",n,t,e),o=x("indices",n,t,e);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=x("axis",n,t,e),o=x("batchDims",n,t,e),i=x("x",n,t,e),a=x("indices",n,t,e);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=x("dims",n,t,e),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=x("x",n,t,e);return[r.reverse(i,o)]}case"ReverseV2":{const s=x("axis",n,t,e),o=x("x",n,t,e);return[r.reverse(o,s)]}case"Slice":{const s=x("begin",n,t,e),o=x("size",n,t,e);return[r.slice(x("x",n,t,e),s,o)]}case"StridedSlice":{const s=x("begin",n,t,e),o=x("end",n,t,e),i=x("strides",n,t,e),a=x("beginMask",n,t,e),l=x("endMask",n,t,e),u=x("ellipsisMask",n,t,e),c=x("newAxisMask",n,t,e),d=x("shrinkAxisMask",n,t,e),h=x("x",n,t,e);return[r.stridedSlice(h,s,o,i,a,l,u,c,d)]}case"Pack":return Lt(()=>{const s=x("axis",n,t,e),o=x("tensors",n,t,e),i=o[0].shape,a=r.squeeze(o[0]).shape,l=o.map(u=>{const c=Oi(u.shape,i);if(!c&&!Oi(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{const s=x("axis",n,t,e),o=x("tensor",n,t,e);return r.unstack(o,s)}case"Tile":{const s=x("reps",n,t,e);return[r.tile(x("x",n,t,e),s)]}case"Split":case"SplitV":{const s=x("axis",n,t,e),o=x("numOrSizeSplits",n,t,e),i=x("x",n,t,e);return r.split(i,o,s)}case"ScatterNd":{const s=x("indices",n,t,e),o=x("values",n,t,e),i=x("shape",n,t,e);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=x("x",n,t,e),o=x("indices",n,t,e);return[r.gatherND(s,o)]}case"SparseToDense":{const s=x("sparseIndices",n,t,e),o=x("outputShape",n,t,e),i=x("sparseValues",n,t,e),a=x("defaultValue",n,t,e);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"sparse":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(x("indices",n,t,e),x("values",n,t,e),x("denseShape",n,t,e),x("defaultValue",n,t,e));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(x("inputIndices",n,t,e),x("inputShape",n,t,e),x("newShape",n,t,e));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"spectral":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"FFT":return[r.fft(x("x",n,t,e))];case"IFFT":return[r.ifft(x("x",n,t,e))];case"RFFT":return[r.rfft(x("x",n,t,e))];case"IRFFT":return[r.irfft(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"string":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(x("data",n,t,e),x("dataSplits",n,t,e),x("separator",n,t,e),x("nGramWidths",n,t,e),x("leftPad",n,t,e),x("rightPad",n,t,e),x("padWidth",n,t,e),x("preserveShortSequences",n,t,e));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(x("input",n,t,e),x("delimiter",n,t,e),x("skipEmpty",n,t,e));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(x("input",n,t,e),x("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"transformation":return s(()=>((n,t,e,r=wt)=>{switch(n.op){case"Cast":return[r.cast(x("x",n,t,e),x("dtype",n,t,e))];case"ExpandDims":{const s=x("axis",n,t,e);return[r.expandDims(x("x",n,t,e),s)]}case"Squeeze":{const s=x("axis",n,t,e);return[r.squeeze(x("x",n,t,e),s)]}case"Reshape":return[r.reshape(x("x",n,t,e),x("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(x("x",n,t,e),x("padding",n,t,e),x("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(x("x",n,t,e),x("padding",n,t,e),x("constantValue",n,t,e))];case"SpaceToBatchND":{const s=x("blockShape",n,t,e),o=x("paddings",n,t,e);return[r.spaceToBatchND(x("x",n,t,e),s,o)]}case"BatchToSpaceND":{const s=x("blockShape",n,t,e),o=x("crops",n,t,e);return[r.batchToSpaceND(x("x",n,t,e),s,o)]}case"DepthToSpace":{const s=x("blockSize",n,t,e),o=x("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(x("x",n,t,e),s,o)]}case"BroadcastTo":return[r.broadcastTo(x("x",n,t,e),x("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(x("s0",n,t,e),x("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,a,l));case"hash_table":return Kge(i,a,l,r);case"custom":const u=ZU(i.op);if(u&&u.customExecutor)return u.customExecutor(new $ge(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return Ou(o)?o.then(i=>[].concat(i)):[].concat(o)}class oW{constructor(t={},e={},r={},s={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function iW(n,t,e,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,u=Object.keys(n).map(h=>$s(h)[0]);let c=[];null!=r&&(c=r.map(h=>$s(h.name)[0]));const d=[...t];for(;d.length>0;){const h=d.pop();if((aW(h)||uye(h)||cye(h))&&null==i&&(i=h,a=i.children.map(p=>p.name).filter(p=>s.has(p))),s.add(h.name),null==e[h.name]&&-1===u.indexOf(h.name)&&-1===c.indexOf(h.name)){if(0===h.inputs.length){o.push(h.name);continue}h.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),d.push(p))})}}return{inputs:n,outputs:t,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}const iye=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],aye=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],lye=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function aW(n){return iye.indexOf(n.op)>=0}function uye(n){return aye.indexOf(n.op)>=0}function cye(n){return lye.indexOf(n.op)>=0}class f_{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new f_(t.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const r=t.map(o=>o.name).sort(),s=e.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(t,e){const r=iW(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const a=e.map(u=>u.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}return function oye(n,t,e){const{usedNodes:r,inputs:s}=e,o=[],i=Object.keys(s).map(c=>$s(c)[0]).map(c=>n.nodes[c]),a=n.initNodes;i.forEach(c=>{r.has(c.name)&&o.push(c)}),n.weights.forEach(c=>{r.has(c.name)&&o.push(c)}),null!=a&&a.forEach(c=>{r.has(c.name)&&o.push(c)});const l=new Set,u=[];for(;o.length>0;){const c=o.pop();l.add(c.name),t[c.name]||u.push(c),c.children.forEach(d=>{!l.has(d.name)&&r.has(d.name)&&d.inputs.every(h=>l.has(h.name))&&o.push(d)})}return u}(this.graph,this.weightMap,r)}execute(t,e){t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(d=>this.graph.nodes[$s(d)[0]]),o=e.map(d=>$s(d)[0]);let i=o.map(d=>this.graph.nodes[d]);this.resetIntermediateTensors(),0===i.length&&(i=this._outputs);const a=this.getCompilationKey(s,i);let l=this.compiledMap.get(a);null==l&&(l=this.compile(t,i),this.compiledMap.set(a,l));const u={},c={};return Lt(()=>{const d=new oW(this.weightMap,u,c,this.functionExecutorMap),h=Object.assign({},this.weightMap);Object.keys(t).forEach(m=>{const[g,y]=$s(m),b=[];b[y]=t[m],h[g]=b});const p=this.getFrozenTensorIds(h),f={};for(let m=0;m<l.length;m++){const g=l[m];if(!h[g.name]){const y=sW(g,h,d,this._resourceManager);if(Ou(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);h[g.name]=y,this.checkTensorForDisposal(g.name,g,h,d,p,o,f)}}return null==this.parent&&d.dispose(p),e.map(m=>ns(m,h,d))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,o,i,a){"control"===e.category||-1!==i.indexOf(t)||(r[t].forEach(l=>{null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length)}),e.inputs.forEach(l=>{if("control"!==l.category){const u=function hge(n,t,e){return t[h_(n,e.currentContextId)]}(l.name,r,s);null!=u&&u.forEach(c=>{if(c&&!c.kept&&!o.has(c.id)){const d=a[c.id];if(1===d){if(this.keepTensorForDebug){const[h,p]=Wi(e.name,s);this.intermediateTensors[h]||(this.intermediateTensors[h]=[]),this.intermediateTensors[h][p]=c}else c.dispose();delete a[c.id]}else null!=d&&a[c.id]--}})}}))}executeAsync(t,e){var r=this;return $(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(e=>e.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const t in this.intermediateTensors)this.intermediateTensors[t].forEach(e=>e.dispose()),delete this.intermediateTensors[t]}_executeAsync(t,e,r=!1,s={},o={}){var i=this;return $(function*(){r||(t=i.mapInputs(t),i.checkInputs(t),i.checkInputShapeAndType(t),e=i.mapOutputs(e),i.checkOutputs(e));try{i.keepTensorForDebug=at().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){console.warn(d.message)}i.resetIntermediateTensors();const a=new oW(i.weightMap,s,o,i.functionExecutorMap);i.tensorsMap=yield i.executeWithControlFlow(t,a,e,r);const l=e.map(d=>ns(d,i.tensorsMap,a)),u=l.map(d=>d.id),c=Object.keys(t).map(d=>t[d].id);return i.keepIds=new Set([...u,...c,...i.weightIds]),i.keepTensorForDebug||i.disposeTensorsMap(),null==i.parent&&a.dispose(i.keepIds),l})()}executeFunctionAsync(t,e,r){var s=this;return $(function*(){const o=t.reduce((i,a,l)=>(i[s.inputs[l].name]=a,i),{});return s._executeAsync(o,s.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,s){var o=this;return $(function*(){const i=Object.keys(t),a=i.map(v=>o.graph.nodes[$s(v)[0]]),l=r.map(v=>$s(v)[0]);let u=l.map(v=>o.graph.nodes[v]);0===u.length&&(u=o._outputs);const{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:p}=iW(t,u,o.weightMap,o._initNodes),f=[...a,...o.graph.weights,...o._initNodes||[]].map(v=>({node:v,contexts:e.currentContext})),m=Object.assign({},o.weightMap);Object.keys(t).forEach(v=>{const[w,S]=$s(v),T=[];T[S]=t[v],m[w]=T});const g={},y=o.getFrozenTensorIds(m),b={};for(;f.length>0;){const v=o.processStack(a,f,e,m,b,y,l,g,c);yield Promise.all(v)}null==h&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=u.filter(v=>!aW(v)&&!ns(v.name,m,e)).map(v=>v.name);if(_.length>0){let v="";throw null!=h&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${_}] from the provided inputs [${i}]. Consider providing the following inputs: [${d}]. ${v}`)}return m})()}processStack(t,e,r,s,o,i,a,l,u){const c=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&x("isConstant",d.node,s,r)&&([h]=Wi(d.node.name,r)),null==s[d.node.name]){const p=sW(d.node,s,r,this._resourceManager);h||([h]=Wi(d.node.name,r));const f=r.currentContext;Ou(p)?c.push(p.then(m=>(s[h]=m,r.currentContext=f,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u),m))):(s[h]=p,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u))}else this.processChildNodes(d.node,e,r,s,o,u)}return c}processChildNodes(t,e,r,s,o,i){t.children.forEach(a=>{const[l]=Wi(a.name,r);o[l]||!i.has(a.name)||("Merge"===a.op?a.inputNames.some(u=>!!ns(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!ns(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[s]=$s(e),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value;D(i.length===r.shape.length&&r.shape.every((l,u)=>-1===i[u]||i[u]===l),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&D(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){const e={};for(const r in t)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[r]?e[this._signature.inputs[r].name]=t[r]:e[r]=t[r];return e}checkInputs(t){const e=Object.keys(t).filter(r=>{const[s]=$s(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e,{})}checkOutputs(t){t.forEach(e=>{const[r]=$s(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class dye{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class lW{constructor(t,e={},r=en){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new dye}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Ou(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const o=this.artifacts.userDefinedMetadata;null!=o.signature&&(r=o.signature),null!=o.structuredOutputKeys&&(this.structuredOutputKeys=o.structuredOutputKeys)}this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new f_(QU.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const o=QU.Instance.transformGraph(t.modelInitializer);this.initializer=new f_(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(t,e){var r=this;return $(function*(){if("string"==typeof t){const s=r.io.getSaveHandlers(t);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}predict(t,e){const r=this.execute(t,this.outputNodes);if(this.structuredOutputKeys){const o={};return(r instanceof En?[r]:r).forEach((i,a)=>o[this.structuredOutputKeys[a]]=i),o}return r}normalizeInputs(t){if(!(t instanceof En||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,r,s)=>(e[r]=t[s],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return $(function*(){t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function uW(n){return kE.apply(this,arguments)}function kE(){return(kE=$(function*(n,t={},e=en){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=fye(n));const r=new lW(n,t,e);return yield r.load(),r})).apply(this,arguments)}function fye(n){return n.endsWith("/")||(n+="/"),`${n}model.json?tfjs-format=file`}function m_(n,t,e,r){return new(e||(e=Promise))(function(s,o){function i(u){try{l(r.next(u))}catch(c){o(c)}}function a(u){try{l(r.throw(u))}catch(c){o(c)}}function l(u){u.done?s(u.value):new e(function(c){c(u.value)}).then(i,a)}l((r=r.apply(n,t||[])).next())})}function g_(n,t){var e,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(u){return function(c){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,r=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(!(s=(s=i.trys).length>0&&s[s.length-1])&&(6===c[0]||2===c[0])){i=0;continue}if(3===c[0]&&(!s||c[1]>s[0]&&c[1]<s[3])){i.label=c[1];break}if(6===c[0]&&i.label<s[1]){i.label=s[1],s=c;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(c);break}s[2]&&i.ops.pop(),i.trys.pop();continue}c=t.call(n,i)}catch(d){c=[6,d],r=0}finally{e=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}var mye={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},Cl=224,gye={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},Ud={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}},bye=function(){function n(t,e,r,s,o){void 0===s&&(s=-1),void 0===o&&(o=1),this.version=t,this.alpha=e,this.modelUrl=r,this.inputMin=s,this.inputMax=o,this.normalizationConstant=(o-s)/255}return n.prototype.load=function(){return m_(this,void 0,void 0,function(){var t,r,s,o=this;return g_(this,function(i){switch(i.label){case 0:return this.modelUrl?(t=this,[4,uW(this.modelUrl)]):[3,2];case 1:return t.model=i.sent(),[3,4];case 2:return r=this,[4,uW(Ud[this.version][this.alpha].url,{fromTFHub:!0})];case 3:r.model=i.sent(),i.label=4;case 4:return[4,(s=Lt(function(){return o.model.predict(vl([1,Cl,Cl,3]))})).data()];case 5:return i.sent(),s.dispose(),[2]}})})},n.prototype.infer=function(t,e){var r=this;return void 0===e&&(e=!1),Lt(function(){t instanceof En||(t=pz(t));var s=qe(xe(_n(t,"float32"),r.normalizationConstant),r.inputMin),o=s;(t.shape[0]!==Cl||t.shape[1]!==Cl)&&(o=dE.resizeBilinear(s,[Cl,Cl],!0));var i,a=ie(o,[-1,Cl,Cl,3]);if(e){var u=r.model.execute(a,gye[r.version]);i=kf(u,[1,2])}else{var c=r.model.predict(a);i=Xt(c,[0,1],[-1,1e3])}return i})},n.prototype.classify=function(t,e){return void 0===e&&(e=3),m_(this,void 0,void 0,function(){var r,s;return g_(this,function(o){switch(o.label){case 0:return[4,_ye(r=this.infer(t),e)];case 1:return s=o.sent(),r.dispose(),[2,s]}})})},n}();function _ye(n,t){return m_(this,void 0,void 0,function(){var e,r,s,o,i,a,l;return g_(this,function(u){switch(u.label){case 0:return[4,(e=QC(n)).data()];case 1:for(r=u.sent(),e.dispose(),s=[],l=0;l<r.length;l++)s.push({value:r[l],index:l});for(s.sort(function(c,d){return d.value-c.value}),o=new Float32Array(t),i=new Int32Array(t),l=0;l<t;l++)o[l]=s[l].value,i[l]=s[l].index;for(a=[],l=0;l<i.length;l++)a.push({className:mye[i[l]],probability:o[l]});return[2,a]}})})}class cW{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class NE{refCount(t){return Os("refCount")}incRef(t){return Os("incRef")}timerAvailable(){return!0}time(t){return Os("time")}read(t){return Os("read")}readSync(t){return Os("readSync")}readToGPU(t,e){return Os("readToGPU")}numDataIds(){return Os("numDataIds")}disposeData(t,e){return Os("disposeData")}write(t,e,r){return Os("write")}move(t,e,r,s,o){return Os("move")}createTensorFromGPUData(t,e,r){return Os("createTensorFromGPUData")}memory(){return Os("memory")}floatPrecision(){return Os("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Os("dispose")}}function Os(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function dW(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,El(n,t,e)}function Hu(n,t,e){return Math.max(n,Math.min(t,e))}function DE(n){return n%2==0?n:n+1}function El(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function C(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Ro(n,t,e=""){C(zt(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function AE(n){C(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function ne(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function zt(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Wd(n){return n%1==0}function RE(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Gd(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function hW(n,t=(s=>0),e,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(n())return void s();i++;const l=t(i);null!=e&&i>=e?o():null!=r?r(a,l):setTimeout(a,l)};a()})}function pW(n,t){let e=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)e*=n[o];else if(-1===n[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function bt(n,t){const e=t.length;return C((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),C(n.every(r=>Wd(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Il(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||s?null:bt(t,n).sort();let i=0;for(let a=0;a<n.length;++a){if(null!=o){if(o[i]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),o[i]<=a&&i++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function Ar(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);e=new Uint8Array(t)}return e}function Jn(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function fW(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function y_(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Df(n){return"string"==typeof n||n instanceof String}function $E(n){return"number"==typeof n}function Af(n){return Array.isArray(n)?Af(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":$E(n)?"float32":Df(n)?"string":function Eye(n){return"boolean"==typeof n}(n)?"bool":"float32"}function OE(n){return!!(n&&n.constructor&&n.call&&n.apply)}function FE(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Be(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function mW(n,t,e,r=!1){const s=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=e[n+i]}else{const o=t[0],i=t.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=mW(n+l*a,i,e,r)}return s}function di(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,o)=>s*o)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return mW(0,n,t,e)}function ME(n,t){const e=Gr(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Gr(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function gW(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return di(n,new Float32Array(e));if("int32"===t)return di(n,new Int32Array(e));if("bool"===t)return di(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function ka(n){n.forEach(t=>{C(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Gi(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function Hd(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function b_(n){return n&&n.then&&"function"==typeof n.then}const yW="tfjsflags";class kye{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Nye,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return $(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(b_(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);yW in t&&t[yW].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function Aye(n,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}(s,o)})}}function Nye(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function Dye(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function ee(){return bW}let PE,bW=null;function _W(){if(null==PE){let n;if("undefined"!=typeof window)n=window;else if("undefined"!=typeof global)n=global;else if("undefined"!=typeof process)n=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}PE=n}return PE}function LE(n,t){const e=function $ye(){const n=_W();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const __="Abs",Rf="Acos",$f="Acosh",jd="Add",VE="AddN",v_="ArgMax",w_="ArgMin",Of="Asin",Ff="Asinh",Mf="Atan",Pf="Atanh",Lf="Atan2",x_="AvgPool",UE="AvgPoolGrad",S_="AvgPool3D",WE="AvgPool3DGrad",T_="BatchMatMul",C_="BatchToSpaceND",GE="Bincount",vW="BroadcastArgs",Vf="Cast",Bf="Ceil",zf="ClipByValue",HE="Complex",E_="ComplexAbs",I_="Concat",k_="Conv2D",jE="Conv2DBackpropFilter",N_="Conv2DBackpropInput",D_="Conv3D",qE="Conv3DBackpropFilterV2",KE="Conv3DBackpropInputV2",Uf="Cos",Wf="Cosh",XE="Cumprod",A_="Cumsum",YE="CropAndResize",ZE="DenseBincount",QE="DepthToSpace",R_="DepthwiseConv2dNative",JE="DepthwiseConv2dNativeBackpropFilter",eI="DepthwiseConv2dNativeBackpropInput",$_="Dilation2D",tI="Dilation2DBackpropInput",nI="Dilation2DBackpropFilter",Gf="RealDiv",Hf="Elu",rI="EluGrad",jf="Erf",O_="Equal",qf="Exp",F_="ExpandDims",Kf="Expm1",oI="Fill",iI="FlipLeftRight",Xf="Floor",Yf="FloorDiv",M_="FusedBatchNorm",P_="GatherV2",SW="GatherNd",L_="Greater",Zf="GreaterEqual",Qf="Identity",aI="IFFT",lI="Imag",Jf="IsFinite",em="IsInf",tm="IsNan",V_="LeakyRelu",B_="Less",z_="LessEqual",TW="LinSpace",nm="Log",rm="Log1p",U_="LogicalAnd",W_="LogicalNot",G_="LogicalOr",H_="LRN",uI="LRNGrad",j_="Max",sm="Maximum",q_="MaxPool",cI="MaxPoolGrad",K_="MaxPool3D",dI="MaxPool3DGrad",CW="MaxPoolWithArgmax",X_="Mean",Y_="Min",om="Minimum",Z_="MirrorPad",im="Mod",EW="Multinomial",am="Multiply",Q_="Neg",J_="NotEqual",hI="NonMaxSuppressionV3",pI="NonMaxSuppressionV4",fI="NonMaxSuppressionV5",ev="OnesLike",tv="OneHot",nv="Pack",rv="PadV2",lm="Pow",sv="Prelu",ov="Prod",IW="RaggedGather",kW="RaggedRange",NW="RaggedTensorToTensor",mI="Range",gI="Real",um="Reciprocal",cm="Relu",iv="Reshape",av="ResizeNearestNeighbor",yI="ResizeNearestNeighborGrad",lv="ResizeBilinear",bI="ResizeBilinearGrad",dm="Relu6",uv="Reverse",hm="Round",pm="Rsqrt",DW="ScatterNd",AW="SearchSorted",cv="Select",fm="Selu",dv="Slice",mm="Sin",gm="Sinh",ym="Sign",bm="Sigmoid",_m="Softplus",vm="Sqrt",hv="Sum",pv="SpaceToBatchND",fv="SplitV",mv="Softmax",_I="SparseFillEmptyRows",vI="SparseReshape",wI="SparseSegmentMean",xI="SparseSegmentSum",RW="SparseToDense",wm="SquaredDifference",SI="Square",TI="StridedSlice",CI="StringNGrams",EI="StringSplit",II="StringToHashBucketFast",xm="Sub",Sm="Tan",Tm="Tanh",Cm="Tile",kI="TopK",NI="Transform",qd="Transpose",DI="Unique",gv="Unpack",yv="UnsortedSegmentSum",bv="ZerosLike",Em="Step",AI="FromPixels",RI="RotateWithOffset",_v="_FusedMatMul",vv="FusedConv2D",wv="FusedDepthwiseConv2D";function to(...n){ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(...n)}function Mye(...n){ee().getBool("IS_TEST")||ee().getBool("PROD")||console.log(...n)}const Kd=LE("kernelRegistry",()=>new Map),Im=LE("gradRegistry",()=>new Map);function $I(n,t){const e=MI(n,t);return Kd.get(e)}function $W(n){return Im.get(n)}function OI(n){const t=Kd.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===n&&e.push(i)}return e}function FI(n){const{kernelName:t,backendName:e}=n,r=MI(t,e);Kd.has(r)&&to(`The kernel '${t}' for backend '${e}' is already registered`),Kd.set(r,n)}function Pye(n){const{kernelName:t}=n;Im.has(t)&&ee().getBool("DEBUG")&&to(`Overriding the gradient for '${t}'`),Im.set(t,n)}function MI(n,t){return`${t}_${n}`}const ju=NB()||O1;function xv(n){return ju.fromString(n,!0,16)}const OW=xv("c3a5c85c97cb3127"),qu=xv("b492b66fbe98f273"),rs=xv("9ae16a3b2f90404f");function PI(n){return n.xor(n.shru(47))}function FW(n,t,e){const r=n.slice(t,t+e);return ju.fromBytes(Array.from(r),!0,!0)}function an(n,t){return FW(n,t,8)}function MW(n,t){return FW(n,t,4)}function vr(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function kl(n,t,e=xv("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Sv(n,t,e,r){return function Lye(n,t,e,r,s,o){s=s.add(n),o=vr(o.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(e),o=o.add(vr(s,44)),[s.add(r),o.add(i)]}(an(n,t),an(n,t+8),an(n,t+16),an(n,t+24),e,r)}function Uye(n,t=n.length){const e=ju.fromNumber(81,!0);if(t<=32)return t<=16?function Vye(n,t=n.length){if(t>=8){const e=rs.add(2*t),r=an(n,0).add(rs),s=an(n,t-8);return kl(vr(s,37).mul(e).add(r),vr(r,25).add(s).mul(e),e)}if(t>=4){const e=rs.add(2*t);return kl(MW(n,0).shl(3).add(t),MW(n,t-4),e)}if(t>0){const i=t+(n[t-1]<<2);return PI(rs.mul(n[0]+(n[t>>1]<<8)).xor(OW.mul(i))).mul(rs)}return rs}(n,t):function Bye(n,t=n.length){const e=rs.add(2*t),r=an(n,0).mul(qu),s=an(n,8),o=an(n,t-8).mul(e),i=an(n,t-16).mul(rs);return kl(vr(r.add(s),43).add(vr(o,30)).add(i),r.add(vr(s.add(rs),18)).add(o),e)}(n,t);if(t<=64)return function zye(n,t=n.length){const e=rs.add(2*t),r=an(n,0).mul(rs),s=an(n,8),o=an(n,t-8).mul(e),i=an(n,t-16).mul(rs),a=vr(r.add(s),43).add(vr(o,30)).add(i),l=kl(a,r.add(vr(s.add(rs),18)).add(o),e),u=an(n,16).mul(e),c=an(n,24),d=a.add(an(n,t-32)).mul(e),h=l.add(an(n,t-24)).mul(e);return kl(vr(u.add(c),43).add(vr(d,30)).add(h),u.add(vr(c.add(r),18)).add(d),e)}(n,t);let r=e,s=e.mul(qu).add(113),o=PI(s.mul(rs).add(113)).mul(rs),i=[ju.UZERO,ju.UZERO],a=[ju.UZERO,ju.UZERO];r=r.mul(rs).add(an(n,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=vr(r.add(s).add(i[0]).add(an(n,l+8)),37).mul(qu),s=vr(s.add(i[1]).add(an(n,l+48)),42).mul(qu),r=r.xor(a[1]),s=s.add(i[0]).add(an(n,l+40)),o=vr(o.add(a[0]),33).mul(qu),i=Sv(n,l,i[1].mul(qu),r.add(a[0])),a=Sv(n,l+32,o.add(a[1]),s.add(an(n,l+16))),[o,r]=[r,o],l+=64}while(l!==u);const d=qu.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=vr(r.add(s).add(i[0]).add(an(n,l+8)),37).mul(d),s=vr(s.add(i[1]).add(an(n,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(an(n,l+40))),o=vr(o.add(a[0]),33).mul(d),i=Sv(n,l,i[1].mul(d),r.add(a[0])),a=Sv(n,l+32,o.add(a[1]),s.add(an(n,l+16))),[o,r]=[r,o],kl(kl(i[0],a[0],d).add(PI(s).mul(OW)).add(o),kl(i[1],a[1],d).add(r),d)}function Nl(n,t){return"string"===t?Dl(n):Ku([n],t)}function Ku(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Xu(n)),ee().getBool("DEBUG")&&function Sye(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function Wye(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function Hr(){return ee().platform.now()}function Dl(n,t="utf-8"){return t=t||"utf-8",ee().platform.encode(n,t)}function Al(n,t="utf-8"){return t=t||"utf-8",ee().platform.decode(n,t)}function $o(n){return ee().platform.isTypedArray(n)}function Xu(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||b_(n)||null==n||$o(n)&&e)t.push(n);else if(Array.isArray(n)||$o(n))for(let r=0;r<n.length;++r)Xu(n[r],t,e);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Xu(n[s],t,e)}return t}class Hye{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new qye)}profileKernel(t,e,r){let s;const o=()=>{s=r()};let i;const a=Hr();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Hr()-a})}if(ee().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{jye(d,c.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:i}=t;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],o,l[2])})})}}function jye(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class qye{logKernelProfile(t,e,r,s,o,i){const a="number"==typeof s?Gd(`${s}ms`,9):s.error,l=Gd(t,25),u=e.rank,c=e.size,d=Gd(e.shape.toString(),14);let h="";for(const p in o){const f=o[p];if(null!=f){const m=f.shape||e.shape,g=m.length;h+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Yye(n,t,e,r){const s=Be(t),o=function Zye(n,t,e,r){const s=ne(t),o=r[r.length-1],i=new Array(o).fill(0),a=t.length,l="complex64"===e?Dm(n):n;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],Nm(l[c+d],0,e).length)}return i}(n,t,e,s),i=t.length,a=Tv(n,t,e,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function Nm(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:Df(n)?`'${n}'`:"bool"===e?LW(n):parseFloat(n.toFixed(7)).toString(),Gd(r,t)}function LW(n){return 0===n?"false":"true"}function Tv(n,t,e,r,s,o=!0){const i="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[Nm(Dm(n)[0],0,e)]:"bool"===e?[LW(n[0])]:[n[0].toString()];if(1===l){if(a>20){let y=Array.from(n.slice(0,3*i)),b=Array.from(n.slice((a-3)*i,a*i));return"complex64"===e&&(y=Dm(y),b=Dm(b)),["["+y.map((_,v)=>Nm(_,s[v],e)).join(", ")+", ..., "+b.map((_,v)=>Nm(_,s[a-3+v],e)).join(", ")+"]"]}return["["+("complex64"===e?Dm(n):Array.from(n)).map((g,y)=>Nm(g,s[y],e)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...Tv(n.slice(g,g+d),u,e,c,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...Tv(n.slice(g,g+d),u,e,c,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...Tv(n.slice(g,g+d),u,e,c,s,m===a-1))}const p=2===l?",":"";h[0]="["+(a>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function Dm(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class jr{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=ne(t),null!=r){const s=r.length;C(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Jn(e,this.size),this.strides=Be(t)}set(t,...e){0===e.length&&(e=[0]),C(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return hi().makeTensor(this.values,this.shape,this.dtype)}}let hi=null,Xd=null,VW=null;class yn{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ne(t),this.strides=Be(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return $(function*(){const e=yield t.data();return Xd.buffer(t.shape,t.dtype,e)})()}bufferSync(){return Xd.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return $(function*(){const e=yield t.data();return di(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return di(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return $(function*(){t.throwIfDisposed();const e=hi().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>Al(s))}catch(s){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),hi().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=hi().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>Al(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return $(function*(){t.throwIfDisposed();const e=yield hi().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(hi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Xd.print(this,t)}clone(){return this.throwIfDisposed(),Xd.clone(this)}toString(t=!1){return Yye(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Xd.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),hi().makeVariable(this,t,e,r)}}function re(){return LE("Tensor",()=>yn)}Object.defineProperty(yn,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),re();class Cv extends yn{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!zt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);hi().disposeTensor(this),this.dataId=t.dataId,hi().incRef(this,null)}dispose(){hi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Cv,Symbol.hasInstance,{value:n=>n instanceof yn&&null!=n.assign&&n.assign instanceof Function});var Ev=(()=>{return(n=Ev||(Ev={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",Ev;var n})(),Iv=(()=>{return(n=Iv||(Iv={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",Iv;var n})(),kv=(()=>{return(n=kv||(kv={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",kv;var n})(),Nv=(()=>{return(n=Nv||(Nv={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",Nv;var n})();const tbe={float32:kv,int32:Ev,bool:Iv,complex64:Nv};function Fs(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return tbe[n][t]}function VI(n){return Fs(n,"int32")}function Ln(n,t){if(n.dtype===t.dtype)return[n,t];const e=Fs(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function BI(n,t){return t.some(e=>e.id===n.id)}function Rl(n){const t=[];return BW(n,t,new Set),t}function BW(n,t,e){if(null==n)return;if(n instanceof yn)return void t.push(n);if(!function nbe(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const o=r[s];e.has(o)||(e.add(o),BW(o,t,e))}}function zI(n){return null!=n.kernelName}class zW{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let rbe=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new zW}ready(){var e=this;return $(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(to(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return $(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new Hye(r.backendInstance),!0})()}setupRegisteredKernels(){OI(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){OI(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof NE||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,to(`Initialization of backend ${e} failed`),to(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return to(`Initialization of backend ${e} failed`),to(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=B.runKernel(Qf,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>B.runKernel(Vf,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==$I(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=zI(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(zI(e)){const{kernelName:m,inputs:g,attrs:y}=e,b=$I(m,this.backendName);C(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const _=this.backend.numDataIds();u=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const v=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,_,v);const w=v.map(S=>null!=S.rank?S:this.makeTensorFromTensorInfo(S));if(o){const S=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:m}=e,g=y=>{!o||(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,g));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}const{inputs:d,attrs:h}=e,p=zI(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),r=f.outputs):r=l()}),o&&this.addTapeNode(c,d,r,p,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=$W(e);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(C(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=e;"string"===(s=s||"float32")&&Df(e[0])&&(i=e.map(u=>Dl(u)));const a=o.write(i,r,s),l=new yn(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=function Cye(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,s,o){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},o)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:o,dtype:i}=e,a=new yn(o,i,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const i=new Cv(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*y_(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Cv||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*y_(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return $(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:i},u=$W(e);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const p=s[h],f=Gr(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=Rl(e),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,r,s,o=!1){if(C(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));C(i instanceof yn,()=>"The result y returned by f() must be a tensor.");const a=function Kye(n,t,e){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const o={};o[e.id]=!0;const i={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const p=u.inputs[h];r[p.id]&&(c[h]=p)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=null==s?function sbe(n){const t=ME(ne(n),"float32");return B.makeTensor(t,n,"float32")}(i.shape):s,function Xye(n,t,e,r){for(let s=t.length-1;s>=0;s--){const o=t[s],i=[];if(o.outputs.forEach(l=>{const u=n[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!zt(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==n[c.id])n[c.id]=u;else{const d=n[c.id];n[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),obe);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return C(OE(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;C(r.every(l=>l instanceof yn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=e(...r,u),C(s.value instanceof yn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),C(OE(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];C(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),C(d.every(p=>p instanceof yn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((p,f)=>{h[f]=()=>p}),h},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return $(function*(){const s=Hr(),o=yield r.backend.time(e);return o.wallMs=Hr()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new zW;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function UW(){const n=_W();if(null==n._tfengine){const t=new kye(n);n._tfengine=new rbe(t)}return function Rye(n){bW=n}(n._tfengine.ENV),function Qye(n){hi=n}(()=>n._tfengine),n._tfengine}const B=UW();function obe(n,t){return B.runKernel(jd,{a:n,b:t})}function WW(n){if(n||function ibe(){return"undefined"!=typeof navigator&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function GW(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const no=ee();function Am(n,t){let e=n;if($o(n))return"string"===t?[]:[n.length];if("object"==typeof n){if("texture"in n)return[n.height,n.width*(n.channels||"RGBA").length];if("buffer"in n&&!(n.buffer instanceof ArrayBuffer))return[n.buffer.size/(null==t?4:y_(t))]}if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||$o(e)&&"string"!==t;)s.push(e.length),e=e[0];return Array.isArray(n)&&ee().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&HW(n,s,[]),s}function HW(n,t,e){if(e=e||[],!Array.isArray(n)&&!$o(n))return void C(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);C(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),C(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)HW(n[s],r,e.concat(s))}function jW(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function k(n,t,e,r="numeric"){if(n instanceof yn)return jW(r,n.dtype,t,e),n;let s=Af(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),jW(r,s,t,e),null==n||!$o(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const o=Am(n,s);!$o(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?Ku(n,s):Xu(n,[],!0);return B.makeTensor(a,o,s)}function qW(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>k(o,`${t}[${i}]`,e,r))}function U(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+="__op";const s=(...o)=>{B.startScope(e);try{const i=r(...o);return b_(i)&&console.error("Cannot return a Promise inside of tidy."),B.endScope(i),i}catch(i){throw B.endScope(null),i}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}no.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),no.registerFlag("IS_BROWSER",()=>GW()),no.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),no.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),no.registerFlag("PROD",()=>!1),no.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>no.getBool("DEBUG")),no.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),no.registerFlag("IS_TEST",()=>!1),no.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),no.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),no.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),no.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const Yu=U({complex_:function lbe(n,t){const e=k(n,"real","complex"),r=k(t,"imag","complex");return Ro(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),B.runKernel(HE,{real:e,imag:r})}});function Rm(n,t,e,r){if(null==r)r=Af(n);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if("object"==typeof n&&("texture"in n||"buffer"in n&&!(n.buffer instanceof ArrayBuffer))){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return B.backend.createTensorFromGPUData(n,t||e,r)}if(!$o(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ka(t);const s=ne(t),o=ne(e);C(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<e.length;++i){const a=e[i],l=i!==e.length-1||a!==ne(t.slice(i));C(e[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!$o(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?Ku(n,r):Xu(n,[],!0),B.makeTensor(n,t,r)}function Zu(n,t,e){return Rm(n,t,Am(n,e),e)}function KW(n,t){return GI.apply(this,arguments)}function GI(){return GI=$(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(n)?n[i].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=$(function*(h){const p=yield l.bytes(),f=p.reduce((y,b)=>y+b.length,0)+4*p.length,m=new Uint8Array(f);let g=0;for(let y=0;y<p.length;y++){const b=p[y],_=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(_,g),g+=4,m.set(b,g),g+=b.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=t&&(u.group=t),e.push(u)}return{data:cbe(yield Promise.all(r)),specs:e}}),GI.apply(this,arguments)}function cbe(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(o=>{if(t+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const HI="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function XW(n){return HI?Buffer.byteLength(n):new Blob([n]).size}function jI(n){if(1===n.length)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function ZW(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function pbe(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function qI(){return(qI=$(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),pbe(n,e,r)})).apply(this,arguments)}function Av(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:XW(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:XW(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}class Nn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Nn.instance&&(Nn.instance=new Nn),Nn.instance}static registerSaveRouter(t){Nn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Nn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Nn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Nn.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?Nn.getInstance().loadRouters:Nn.getInstance().saveRouters).forEach(i=>{const a=i(t,r);null!==a&&s.push(a)}),s}}const Rv="tensorflowjs",Qu="models_store",$l="model_info_store";function YI(){if(!ee().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n="undefined"==typeof window?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ZI(n){const t=n.result;t.createObjectStore(Qu,{keyPath:"modelPath"}),t.createObjectStore($l,{keyPath:"modelPath"})}let Yd=(()=>{class n{constructor(e){if(this.indexedDB=YI(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return $(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return $(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const i=this.indexedDB.open(Rv,1);i.onupgradeneeded=()=>ZI(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(Qu,"readonly"),c=l.objectStore(Qu).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{const l=Av(r),u=a.transaction($l,"readwrite");let c=u.objectStore($l);const d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(Qu,"readwrite");const f=h.objectStore(Qu).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});f.onsuccess=()=>s({modelArtifactsInfo:l}),f.onerror=m=>{c=u.objectStore($l);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),o(f.error)),g.onerror=y=>(a.close(),o(f.error))}},d.onerror=p=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return n.URL_SCHEME="indexeddb://",n})();const JW=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Yd.URL_SCHEME)?function vbe(n){return new Yd(n)}(n.slice(Yd.URL_SCHEME.length)):null;Nn.registerSaveRouter(JW),Nn.registerLoadRouter(JW);class xbe{constructor(){this.indexedDB=YI()}listModels(){var t=this;return $(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(Rv,1);s.onupgradeneeded=()=>ZI(s),s.onsuccess=()=>{const o=s.result,i=o.transaction($l,"readonly"),l=i.objectStore($l).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(t){var e=this;return $(function*(){return t=function wbe(n){return n.startsWith(Yd.URL_SCHEME)?n.slice(Yd.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const o=e.indexedDB.open(Rv,1);o.onupgradeneeded=()=>ZI(o),o.onsuccess=()=>{const i=o.result,a=i.transaction($l,"readwrite"),l=a.objectStore($l),u=l.get(t);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{c=i.transaction(Qu,"readwrite");const f=c.objectStore(Qu).delete(t);f.onsuccess=()=>r(u.result.modelArtifactsInfo),f.onerror=m=>s(u.error)};d.onsuccess=h,d.onerror=p=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const Hi="/",Ju="tensorflowjs_models",eG="info",Sbe="model_topology",Tbe="weight_specs",Cbe="weight_data",Ebe="model_metadata";function tG(n){return{info:[Ju,n,eG].join(Hi),topology:[Ju,n,Sbe].join(Hi),weightSpecs:[Ju,n,Tbe].join(Hi),weightData:[Ju,n,Cbe].join(Hi),modelMetadata:[Ju,n,Ebe].join(Hi)}}function nG(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function rG(n){const t=n.split(Hi);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Hi)}let Zd=(()=>{class n{constructor(e){if(!ee().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=tG(this.modelPath)}save(e){var r=this;return $(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),i=Av(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function dbe(n){if(HI)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:i}}catch(a){throw nG(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return $(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=i;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(s.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(s.trainingConfig=u.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function hbe(n){if(HI){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),s})()}}return n.URL_SCHEME="localstorage://",n})();const sG=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Zd.URL_SCHEME)?function kbe(n){return new Zd(n)}(n.slice(Zd.URL_SCHEME.length)):null;Nn.registerSaveRouter(sG),Nn.registerLoadRouter(sG);class Nbe{constructor(){C(ee().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),C("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return $(function*(){const e={},r=Ju+Hi,s=Hi+eG;for(let o=0;o<t.LS.length;++o){const i=t.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(e[rG(i)]=JSON.parse(t.LS.getItem(i)))}return e})()}removeModel(t){var e=this;return $(function*(){const r=tG(t=function Ibe(n){return n.startsWith(Zd.URL_SCHEME)?n.slice(Zd.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return nG(r),s})()}}class ss{constructor(){this.managers={}}static getInstance(){return null==ss.instance&&(ss.instance=new ss),ss.instance}static registerManager(t,e){C(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),C(t.length>0,()=>"scheme must not be an empty string.");const r=ss.getInstance();C(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=ss.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(ss.getInstance().managers)}}class Dbe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!=typeof window&&ee().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),this.functionRefs[r.data.index](),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(t,e)}isTypedArray(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}}if(ee().get("IS_BROWSER")){ee().setPlatform("browser",new Dbe);try{ss.registerManager(Zd.URL_SCHEME,new Nbe)}catch(n){}try{ss.registerManager(Yd.URL_SCHEME,new xbe)}catch(n){}}let Jd;function _t(n,t="float32",e){return t=t||"float32",ka(n),new jr(n,t,e)}ee().get("IS_NODE")&&!ee().get("IS_BROWSER")&&ee().setPlatform("node",new class Rbe{constructor(){this.util=K(4),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=ee().global.fetch?ee().global.fetch(t,e):(null==Jd&&(Jd=K(755)),Jd(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const Se=U({cast_:function $be(n,t){const e=k(n,"x","cast");if(!function Tye(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return B.runKernel(Vf,{x:e},{dtype:t})}}),ec=U({clone_:function Obe(n){const e={x:k(n,"x","clone","string_or_numeric")};return B.runKernel(Qf,e)}});function ji(){return B}function rk(){return B.memory()}function te(n,t){return B.tidy(n,t)}function mt(n){Rl(n).forEach(e=>e.dispose())}function qi(n){return B.keep(n)}function iG(n,t,e=1){return B.registerBackend(n,t,e)}UW(),function Jye(n){Xd=n}({buffer:_t,cast:Se,clone:ec,print:function Fbe(n,t=!1){console.log(n.toString(t))}}),function ebe(n){VW=n}(function Mbe(n){ee().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const fe=U({add_:function Vbe(n,t){let e=k(n,"a","add"),r=k(t,"b","add");return[e,r]=Ln(e,r),B.runKernel(jd,{a:e,b:r})}}),aG=U({floorDiv_:function Bbe(n,t){let e=k(n,"a","floorDiv"),r=k(t,"b","floorDiv");return[e,r]=Ln(e,r),B.runKernel(Yf,{a:e,b:r})}}),ze=U({div_:function zbe(n,t){let e=k(n,"a","div"),r=k(t,"b","div");return[e,r]=Ln(e,r),"int32"===e.dtype&&"int32"===r.dtype?aG(e,r):B.runKernel(Gf,{a:e,b:r},{})}}),L=U({mul_:function Ube(n,t){let e=k(n,"a","mul"),r=k(t,"b","mul");return[e,r]=Ln(e,r),B.runKernel(am,{a:e,b:r})}}),os=U({sqrt_:function Wbe(n){const e={x:k(n,"x","sqrt","float32")};return B.runKernel(vm,e)}}),ln=U({square_:function Gbe(n){const t=k(n,"x","square");return B.runKernel("Square",{x:t},{})}}),$t=U({zerosLike_:function Hbe(n){const e={x:k(n,"x","zerosLike")};return B.runKernel(bv,e)}});function Na(n){return B.customGrad(n)}function Je(n,t){if(($o(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&$o(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Rm(n,[],[],t)}class eh{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Oo{constructor(){this.classNameMap={}}static getMap(){return null==Oo.instance&&(Oo.instance=new Oo),Oo.instance}static register(t){Oo.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function de(n){C(null!=n.className,()=>"Class being registered does not have the static className property defined."),C("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),C(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Oo.register(n)}class Ol extends eh{minimize(t,e=!1,r){const{value:s,grads:o}=this.computeGradients(t,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return mt(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function jbe(n,t){C(OE(n),()=>"The f passed in variableGrads(f) must be a function"),C(null==t||Array.isArray(t)&&t.every(u=>u instanceof Cv),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const u in B.registeredVariables)t.push(B.registeredVariables[u])}const r=e?t.filter(u=>!u.trainable):null,s=t.length;C((t=t.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=B.gradients(n,t,null,!0);C(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),C(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return t.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),null!=r&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}(t,e)}dispose(){null!=this.iterations_&&mt(this.iterations_)}saveIterations(){var t=this;return $(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Je(t.iterations_,"int32")}})()}getWeights(){return $(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return $(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return $(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(Ol,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class lG extends Ol{constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=B.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=B.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:te(()=>$t(o).variable(!1))}),null==this.accumulatedUpdates[s]&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:te(()=>$t(o).variable(!1))});const a=Array.isArray(t)?t[s].tensor:t[r];if(null==a)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;te(()=>{const c=fe(L(l,this.rho),L(ln(a),1-this.rho)),d=L(ze(os(fe(u,this.epsilon)),os(fe(l,this.epsilon))),a),h=fe(L(u,this.rho),L(ln(d),1-this.rho));l.assign(c),u.assign(h);const p=fe(L(d,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(mt(this.accumulatedGrads.map(t=>t.variable)),mt(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return $(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return $(function*(){const r=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function $m(n,t,e){return ka(n),B.runKernel(oI,{},{shape:n,value:t,dtype:e})}class uG extends Ol{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=B.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:te(()=>$m(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(t)?t[s].tensor:t[r];if(null==i)return;const a=this.accumulatedGrads[s].variable;te(()=>{const l=fe(a,ln(i));a.assign(l);const u=fe(L(ze(i,os(fe(l,B.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&mt(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return $(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return $(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const th=U({pow_:function qbe(n,t){let e=k(n,"base","pow"),r=k(t,"exp","pow");return[e,r]=Ln(e,r),B.runKernel(lm,{a:e,b:r})}}),Fe=U({sub_:function Kbe(n,t){let e=k(n,"a","sub"),r=k(t,"b","sub");return[e,r]=Ln(e,r),B.runKernel(xm,{a:e,b:r})}});class cG extends Ol{constructor(t,e,r,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],te(()=>{this.accBeta1=Je(e).variable(),this.accBeta2=Je(r).variable()}),null==s&&(this.epsilon=B.backend.epsilon())}static get className(){return"Adam"}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);te(()=>{const r=Fe(1,this.accBeta1),s=Fe(1,this.accBeta2);e.forEach((o,i)=>{const a=B.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:te(()=>$t(a).variable(!1))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:te(()=>$t(a).variable(!1))});const u=Array.isArray(t)?t[i].tensor:t[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=fe(L(c,this.beta1),L(u,1-this.beta1)),p=fe(L(d,this.beta2),L(ln(u),1-this.beta2)),f=ze(h,r),m=ze(p,s);c.assign(h),d.assign(p);const g=fe(L(ze(f,fe(os(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(L(this.accBeta1,this.beta1)),this.accBeta2.assign(L(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&mt(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&mt(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return $(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return $(function*(){t=yield e.extractIterations(t),te(()=>{e.accBeta1.assign(th(e.beta1,e.iterations_+1)),e.accBeta2.assign(th(e.beta2,e.iterations_+1))});const r=t.length/2;e.accumulatedFirstMoment=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const wr=U({abs_:function Xbe(n){const t=k(n,"x","abs");return B.runKernel("complex64"===t.dtype?E_:__,{x:t})}});function nh(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const o=e-1-s,i=n[o]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function cr(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],o=t.length-r-1,i=t[o];(null==s||1===s&&i>1)&&e.unshift(o)}return e}function tt(n,t){const e=[],r=Math.max(n.length,t.length);for(let s=0;s<r;s++){let o=n[n.length-s-1];null==o&&(o=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===o)e.unshift(i);else if(1===i)e.unshift(o);else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);e.unshift(o)}}return e}const Fl=U({maximum_:function Ybe(n,t){let e=k(n,"a","maximum"),r=k(t,"b","maximum");return[e,r]=Ln(e,r),"bool"===e.dtype&&(e=Se(e,"int32"),r=Se(r,"int32")),tt(e.shape,r.shape),B.runKernel(sm,{a:e,b:r})}});class dG extends Ol{constructor(t,e,r,s=null,o=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],te(()=>{this.iteration=Je(0).variable(),this.accBeta1=Je(e).variable()}),null==s&&(this.epsilon=B.backend.epsilon())}static get className(){return"Adamax"}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);te(()=>{const r=Fe(1,this.accBeta1),s=ze(-this.learningRate,fe(L(this.iteration,this.decay),1));e.forEach((o,i)=>{const a=B.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:$t(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:$t(a).variable(!1)});const u=Array.isArray(t)?t[i].tensor:t[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=fe(L(c,this.beta1),L(u,1-this.beta1)),p=L(d,this.beta2),f=wr(u),m=Fl(p,f);c.assign(h),d.assign(m);const g=fe(L(ze(s,r),ze(h,fe(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(fe(this.iteration,1)),this.accBeta1.assign(L(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&mt(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&mt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return $(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return $(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class sk extends Ol{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}static get className(){return"SGD"}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=Array.isArray(t)?t[s].tensor:t[r];if(null==o)return;const i=B.registeredVariables[r];te(()=>{const a=fe(L(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=qi(Je(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return $(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return $(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class hG extends sk{constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Je(this.momentum)}static get className(){return"Momentum"}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=B.registeredVariables[r];null==this.accumulations[s]&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:te(()=>$t(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(t)?t[s].tensor:t[r];null!=a&&te(()=>{let l;const u=fe(L(this.m,i),a);l=fe(L(this.c,this.useNesterov?fe(a,L(u,this.m)):u),o),i.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&mt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return $(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return $(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class pG extends Ol{constructor(t,e=.9,r=0,s=null,o=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==s&&(this.epsilon=B.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=B.registeredVariables[r],i=!1;null==this.accumulatedMeanSquares[s]&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:te(()=>$t(o).variable(i))}),null==this.accumulatedMoments[s]&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:te(()=>$t(o).variable(i))}),null==this.accumulatedMeanGrads[s]&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:te(()=>$t(o).variable(i))});const a=Array.isArray(t)?t[s].tensor:t[r];if(null==a)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;te(()=>{const c=fe(L(l,this.decay),L(ln(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=fe(L(d,this.decay),L(a,1-this.decay)),p=ze(L(a,this.learningRate),os(Fe(c,fe(ln(h),this.epsilon)))),f=fe(L(u,this.momentum),p);l.assign(c),d.assign(h),u.assign(f);const m=Fe(o,f);o.assign(m)}else{const d=fe(L(l,this.decay),L(ln(a),1-this.decay)),h=fe(L(u,this.momentum),ze(L(a,this.learningRate),os(fe(d,this.epsilon))));l.assign(d),u.assign(h);const p=Fe(o,h);o.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&mt(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&mt(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&mt(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return $(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return $(function*(){t=yield e.extractIterations(t);const r=e.centered?t.length/3:t.length/2,s=!1;e.accumulatedMeanSquares=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.accumulatedMoments=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*r,3*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const Zbe=[lG,uG,cG,dG,hG,pG,sk];function fG(n){return new Promise(t=>setTimeout(t)).then(n)}let ok=(()=>{class n{constructor(e){if(!ee().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return $(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=ZW(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(l.download=r.modelJsonFileName,l.href=a,yield fG(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;u.download=r.weightDataFileName,u.href=s,yield fG(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Av(e)}}})()}}return n.URL_SCHEME="downloads://",n})();function mG(n,t,e,r){(function i(l){C(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,u){C(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),C(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),C(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=null==e?0:e,r=null==r?1:r);let s=0;return Promise.all(n.map(l=>(l.then(u=>{const c=e+ ++s/n.length*(r-e);return t(c),u}),l)))}function gG(n,t){return ik.apply(this,arguments)}function ik(){return(ik=$(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?ee().platform.fetch:t.fetchFunc,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield mG(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield mG(a,t.onProgress,.5,1)})).apply(this,arguments)}Nn.registerSaveRouter(n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ok.URL_SCHEME)?function s_e(n="model"){return new ok(n)}(n.slice(ok.URL_SCHEME.length)):null);let yG=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(C("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=ee().platform.fetch,C(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&C(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return $(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i=ZW(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:Av(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return $(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch(a){let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return function QW(n,t){return qI.apply(this,arguments)}(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return $(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function l_e(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||o,l=function fbe(n){const t=[];for(const e of n)t.push(...e.weights);return t}(e),u=[],c=[];for(const h of e)for(const p of h.paths)null!=r.weightUrlConverter?c.push(r.weightUrlConverter(p)):u.push(a+p+i);return r.weightUrlConverter&&u.push(...yield Promise.all(c)),[l,jI(yield gG(u,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function bG(n){return null!=n.match(yG.URL_SCHEME_REGEX)}const _G=(n,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>bG(r)):bG(n),e)return function vG(n,t){return new yG(n,t)}(n,t)}return null};let tc;Nn.registerSaveRouter(_G),Nn.registerLoadRouter(_G);const g_e=U({fromPixels_:function xG(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if("undefined"!=typeof ImageData&&n instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&n instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement)o=!0;else if(null!=n.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(null!=$I(AI,B.backendName))return B.runKernel(AI,{pixels:n},{numChannels:t});const[u,c]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d,h;if(i)d=n.getContext("2d").getImageData(0,0,u,c).data;else if(r||e)d=n.data;else if(o||s||a){if(null==tc)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");tc=new OffscreenCanvas(1,1).getContext("2d")}else tc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});tc.canvas.width=u,tc.canvas.height=c,tc.drawImage(n,0,0,u,c),d=tc.getImageData(0,0,u,c).data}if(4===t)h=new Int32Array(d);else{const f=u*c;h=new Int32Array(f*t);for(let m=0;m<f;m++)for(let g=0;g<t;++g)h[m*t+g]=d[4*m+g]}return function d_e(n,t,e){if(AE(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Am(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Rm(n,t,r,e)}(h,[c,u,t],"int32")}});function hk(n,t,e){const r=n.shape.length;C(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),C(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)C(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function b_e(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function pk(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function SG(n,t,e,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[t]=1:(s.splice(t,0,1),s.pop());return s}function TG(n,t,e){return e<=n?e:e-(t-1)}function CG(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function __e(n,t,e,r,s,o,i,a,l){const u=n.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&e>0){const p=t[0],f=e+1;c=EG(i,p,f,r,n),d=IG(a,p,f,s,n),h=SG(o,p,f,n)}else for(let p=0;p<u;p++)c[p]=NG(i,r,o,n,p,l),d[p]=DG(a,s,o,n,p,l),h[p]=kG(o,p,l);return{begin:c,end:d,strides:h}}function EG(n,t,e,r,s){const o=[...s],i=CG(e,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=TG(t,e,a);let u=r[l];n&1<<l&&(u=0),o[a]=u}return o}function IG(n,t,e,r,s){const o=[...s],i=CG(e,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=TG(t,e,a);let u=r[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=Hu(0,o[a],s[a])}return o}function kG(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function NG(n,t,e,r,s,o){let i=t[s];(n&1<<s||o&1<<s||null==i)&&(i=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Hu(0,i,l-1),i}function DG(n,t,e,r,s,o){let i=t[s];const a=e[s]||1;(n&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?Hu(0,i,l):Hu(-1,i,l-1),i}function fk(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function mk(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function Fv(n,t,e){let r;const s=n.shape.length;let o;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(i=>{C(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((i,a)=>i>=0?i:(C(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function gk(n,t,e,r,s,o,i,a,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!=(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<d.dims;_++)c&&0!=(1<<_&a)&&d.numAddAxisAfterEllipsis++,1<<_&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function v_e(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let _=0;_<n.length;++_){if(0===h.strides[_])throw Error(`strides[${_}] must be non-zero`);const v=!!(h.shrinkAxisMask&1<<_),w=n[_];if(-1===w){g.push(v?1:-1);continue}const S=[h.beginMask&1<<_,h.endMask&1<<_],T=[h.strides[_]>0?0:-1,h.strides[_]>0?w:w-1];if(v&&h.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[_];const I=!!(h.beginMask&1<<_&&h.endMask&1<<_);if(h.beginValid&&h.endValid){if(v){const j=h.begin[_]<0?w+h.begin[_]:h.begin[_];if(h.begin[_]=j,h.end[_]=h.begin[_]+1,j<0||j>=w)throw Error(`slice index ${h.begin[_]} of dimension ${_} out of bounds.`)}else h.begin[_]=AG(h.begin[_],0,h.strides[_],w,S,T),h.end[_]=AG(h.end[_],1,h.strides[_],w,S,T);const F=1===h.strides[_]&&0===h.begin[_]&&h.end[_]===w;p=p&&F,f=f&&(0===_&&1===h.strides[_]||F)}else p=p&&1===h.strides[_]&&I,f=f&&(0===_&&1===h.strides[_]||I);let N,R=!1;if(h.beginValid&&h.endValid?(N=h.end[_]-h.begin[_],R=!0):v?(N=1,R=!0):I&&w>=0&&(N=h.strides[_]<0?-w:w,R=!0),R){let F;F=0===N||N<0!=h.strides[_]<0?0:Math.trunc(N/h.strides[_])+(N%h.strides[_]!=0?1:0),g.push(F)}else g.push(-1)}for(let _=0;_<h.finalShapeGatherIndices.length;++_){const v=h.finalShapeGatherIndices[_];v>=0?y.push(g[v]):-2===v&&y.push(1)}return{finalShapeSparse:y.filter((_,v)=>-2!==h.finalShapeGatherIndices[v]),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function AG(n,t,e,r,s,o){if(s[t])return e>0?o[t]:o[t+1&1];{const i=n<0?r+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const RG=U({all_:function x_e(n,t=null,e=!1){const s={x:k(n,"x","all","bool")};return B.runKernel("All",s,{axis:t,keepDims:e})}}),yk=U({any_:function S_e(n,t=null,e=!1){const s={x:k(n,"x","any","bool")};return B.runKernel("Any",s,{axis:t,keepDims:e})}}),Om=U({argMax_:function T_e(n,t=0){const r={x:k(n,"x","argMax")};return B.runKernel(v_,r,{axis:t})}});function Fm(n,t,e,r,s="NHWC",o){return xr(n,[...t,n[3]],e,o,r,null,null,Aa(s))}function Fo(n,t,e,r,s,o,i="channelsLast"){const[a,l]=Mm(t);let u;if("channelsLast"===i)u=[a,l,n[3],n[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,n[1],n[1]]}return xr(n,u,e,r,s,o,!1,i)}function Da(n,t,e,r,s,o,i="NDHWC"){const[a,l,u]=_k(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,n[4],n[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,n[1],n[1]]}return Ml(n,c,e,r,s,!1,d,o)}function xr(n,t,e,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=n}const[h,p,,f]=t,[m,g]=Mm(e),[y,b]=Mm(r),_=rh(h,y),v=rh(p,b),{padInfo:w,outHeight:S,outWidth:T}=function I_e(n,t,e,r,s,o,i,a,l){let u,c,d;if("number"==typeof n){u={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const p=function C_e(n,t,e,r,s){null==r&&(r=bk(n,t,e));const i=n[1];return[Pm((n[0]-t+2*r)/e+1,s),Pm((i-t+2*r)/e+1,s)]}([t,e],o,r,n,a);c=p[0],d=p[1]}else if("same"===n){c=Math.ceil(t/r),d=Math.ceil(e/s);const h=Math.max(0,(c-1)*r+o-t),p=Math.max(0,(d-1)*s+i-e),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2);u={top:f,bottom:m,left:g,right:p-g,type:"SAME"}}else if("valid"===n)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-o+1)/r),d=Math.ceil((e-i+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],p="channelsLast"===l?n[1][1]:n[2][1],f="channelsLast"===l?n[2][0]:n[3][0],m="channelsLast"===l?n[2][1]:n[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Pm((t-o+h+p)/r+1,a),d=Pm((e-i+f+m)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,_,v,o,a),I=i?f*d:f;let N;return"channelsFirst"===a?N=[l,I,S,T]:"channelsLast"===a&&(N=[l,S,T,I]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:S,outWidth:T,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:_,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:n,outShape:N,filterShape:t}}function Ml(n,t,e,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=n;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=n}const[p,f,m,,g]=t,[y,b,_]=_k(e),[v,w,S]=_k(r),T=rh(p,v),I=rh(f,w),N=rh(m,S),{padInfo:R,outDepth:F,outHeight:j,outWidth:q}=function k_e(n,t,e,r,s,o,i,a,l,u,c){let d,h,p,f;if("valid"===n&&(n=0),"number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const g=function E_e(n,t,e,r,s,o){null==s&&(s=bk(n,t[0],r[0]));const i=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*s>=t[a]&&(i[a]=Pm((n[a]-t[a]+2*s)/r[a]+1,o));return i}([t,e,r,1],[a,l,u],1,[s,o,i],n,c);h=g[0],p=g[1],f=g[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{h=Math.ceil(t/s),p=Math.ceil(e/o),f=Math.ceil(r/i);const m=(h-1)*s+a-t,g=(p-1)*o+l-e,y=(f-1)*i+u-r,b=Math.floor(m/2),_=m-b,v=Math.floor(g/2),w=g-v,S=Math.floor(y/2);d={top:v,bottom:w,left:S,right:y-S,front:b,back:_,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(s,u,c,d,y,b,_,T,I,N,a),X=o?g*h:g;let Q;return"channelsFirst"===i?Q=[l,X,F,j,q]:"channelsLast"===i&&(Q=[l,F,j,q,X]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:F,outHeight:j,outWidth:q,outChannels:X,padInfo:R,strideDepth:y,strideHeight:b,strideWidth:_,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:T,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:w,dilationWidth:S,inShape:n,outShape:Q,filterShape:t}}function bk(n,t,e,r=1){const s=rh(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function Mm(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function _k(n){return"number"==typeof n?[n,n,n]:n}function rh(n,t){return t<=1?n:n+(n-1)*(t-1)}function Pm(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Pl(n){const[t,e,r]=Mm(n);return 1===t&&1===e&&1===r}function Rr(n,t){return Pl(n)||Pl(t)}function nc(n){return Mm(n).every(t=>t>0)}function Aa(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function is(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)C(Wd(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{C(Wd(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const H=U({reshape_:function N_e(n,t){const r={x:k(n,"x","reshape","string_or_numeric")};return B.runKernel(iv,r,{shape:t})}}),vk=U({avgPool_:function D_e(n,t,e,r,s){const o=k(n,"x","avgPool","float32");C(Rr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),C(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),is("avgPool",r,s);let d=B.runKernel(x_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d=Se(d,o.dtype),l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),R_e=U({avgPool3d_:function A_e(n,t,e,r,s,o="NDHWC"){const i=k(n,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),C(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),C("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),C("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),is("avgPool3d",r,s);let d=B.runKernel(S_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d=Se(d,a.dtype),l?H(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});function $_e(n){let t;return t=0===n.rank||1===n.rank?H(n,[1,1,1,n.size]):2===n.rank?H(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?H(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const Mv=U({batchNorm_:function O_e(n,t,e,r,s,o){null==o&&(o=.001);const i=k(n,"x","batchNorm"),a=k(t,"mean","batchNorm"),l=k(e,"variance","batchNorm");let u,c;null!=s&&(u=k(s,"scale","batchNorm")),null!=r&&(c=k(r,"offset","batchNorm")),C(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:$_e(i),scale:u,offset:c,mean:a,variance:l},f=B.runKernel(M_,h,{varianceEpsilon:o});return H(f,i.shape)}}),M_e=U({batchNorm2d_:function F_e(n,t,e,r,s,o){const i=k(n,"x","batchNorm"),a=k(t,"mean","batchNorm"),l=k(e,"variance","batchNorm");let u,c;return null!=s&&(u=k(s,"scale","batchNorm")),null!=r&&(c=k(r,"offset","batchNorm")),C(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),C(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),C(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&C(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&C(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Mv(i,a,l,c,u,o)}}),L_e=U({batchNorm3d_:function P_e(n,t,e,r,s,o){const i=k(n,"x","batchNorm"),a=k(t,"mean","batchNorm"),l=k(e,"variance","batchNorm");let u,c;return null!=s&&(u=k(s,"scale","batchNorm")),null!=r&&(c=k(r,"offset","batchNorm")),C(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),C(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),C(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&C(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&C(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Mv(i,a,l,c,u,o)}}),B_e=U({batchNorm4d_:function V_e(n,t,e,r,s,o){const i=k(n,"x","batchNorm"),a=k(t,"mean","batchNorm"),l=k(e,"variance","batchNorm");let u,c;return null!=s&&(u=k(s,"scale","batchNorm")),null!=r&&(c=k(r,"offset","batchNorm")),C(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),C(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),C(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&C(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&C(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Mv(i,a,l,c,u,o)}}),Lm=U({broadcastTo_:function z_e(n,t){let e=k(n,"broadcastTo","x");const r=e.shape;if(ka(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=H(e,u)}const s=e.shape,o=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?ec(e):B.runKernel(Cm,{x:e},{reps:o})}}),ro=U({clipByValue_:function U_e(n,t,e){const r=k(n,"x","clipByValue");return C(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?$m(r.shape,t,r.dtype):B.runKernel(zf,{x:r},{clipValueMin:t,clipValueMax:e})}}),qr=U({concat_:function W_e(n,t=0){C(n.length>=1,()=>"Pass at least one tensor to concat");const e=qW(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?ec(e[0]):B.runKernel(I_,e,{axis:t})}}),H_e=U({concat1d_:function G_e(n){return qr(n,0)}}),q_e=U({concat2d_:function j_e(n,t){return qr(n,t)}}),X_e=U({concat3d_:function K_e(n,t){return qr(n,t)}}),Z_e=U({concat4d_:function Y_e(n,t){return qr(n,t)}}),rc=U({conv2d_:function Q_e(n,t,e,r,s="NHWC",o=[1,1],i){const a=k(n,"x","conv2d","float32"),l=k(t,"filter","conv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),C(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),is("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];C(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),C(Rr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),C(nc(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),C(nc(e),()=>"Error in conv2D: Strides should be larger than 0.");const f=B.runKernel(k_,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?H(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),$G=U({conv1d_:function J_e(n,t,e,r,s="NWC",o=1,i){const a=k(n,"x","conv1d"),l=k(t,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=H(a,[1,a.shape[0],a.shape[1]])),C(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),C(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),is("conv1d",r,i),C(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),C(Rr(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),C(nc(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),C(nc(e),()=>"Error in conv1D: Stride should be larger than 0."),C("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=H(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=H(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=rc(h,d,[1,e],r,"NHWC",[1,o],i);return H(g,c?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),wk=U({conv2DBackpropInput_:function eve(n,t,e,r,s,o="NHWC",i){C(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,u=!1;3===t.rank&&(u=!0,l=H(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),C(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),C(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),C(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];C(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),C(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),is("conv2dDerInput",s,i);const f=B.runKernel(N_,{dy:l,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?H(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),OG=U({conv2dTranspose_:function tve(n,t,e,r,s,o){const i=k(n,"x","conv2dTranspose"),a=k(t,"filter","conv2dTranspose");return wk(e,i,a,r,s,"NHWC",o)}}),rve=U({conv3d_:function nve(n,t,e,r,s="NDHWC",o=[1,1,1]){const i=k(n,"x","conv3d"),a=k(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),C(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),C(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),C(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),C(Rr(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),C("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),C(nc(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),C(nc(e),()=>"Error in conv3D: Strides should be larger than 0.");const h=B.runKernel(D_,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:o});return u?H(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),FG=U({conv3DBackpropInput_:function sve(n,t,e,r,s){C(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,i=t,a=!1;4===t.rank&&(a=!0,i=H(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const l=o[4],u=i.shape[4];C(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),C(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),C(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),C(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),C(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=B.runKernel(KE,{dy:i,filter:e},{pad:s,strides:r,inputShape:o});return a?H(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),ive=U({conv3dTranspose_:function ove(n,t,e,r,s){const o=k(n,"x","conv3dTranspose"),i=k(t,"filter","conv3dTranspose");return FG(e,o,i,r,s)}}),MG=U({denseBincount_:function ave(n,t,e,r=!1){const s=k(n,"x","denseBincount"),o=k(t,"weights","denseBincount");return C("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),C(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),C(e>=0,()=>`size must be non-negative, but got ${e}.`),C(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),B.runKernel(ZE,{x:s,weights:o},{size:e,binaryOutput:r})}}),Pv=U({depthwiseConv2d_:function lve(n,t,e,r,s="NHWC",o=[1,1],i){const a=k(n,"x","depthwiseConv2d","float32"),l=k(t,"filter","depthwiseConv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),C(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];C(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),is("depthwiseConv2d",r,i);const f=B.runKernel(R_,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?H(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Lv=U({elu_:function uve(n){const e={x:k(n,"x","elu","float32")};return B.runKernel(Hf,e)}}),Ki=U({equal_:function cve(n,t){let e=k(n,"a","equal","string_or_numeric"),r=k(t,"b","equal","string_or_numeric");return[e,r]=Ln(e,r),tt(e.shape,r.shape),B.runKernel(O_,{a:e,b:r})}}),Mo=U({exp_:function dve(n){const e={x:k(n,"x","exp")};return B.runKernel(qf,e)}}),xs=U({expandDims_:function hve(n,t=0){const e=k(n,"x","expandDims","string_or_numeric");return C(t<=e.rank,()=>"Axis must be <= rank of the tensor"),B.runKernel(F_,{input:e},{dim:t})}}),pi=U({tile_:function pve(n,t){const e=k(n,"x","tile","string_or_numeric");return C(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),B.runKernel(Cm,{x:e},{reps:t})}}),PG=U({eye_:function fve(n,t,e,r="float32"){null==t&&(t=n);const s=_t([n,t],r),o=n<=t?n:t;for(let a=0;a<o;++a)s.set(1,a,a);const i=H(s.toTensor(),[n,t]);if(null==e)return i;if(1===e.length)return pi(xs(i,0),[e[0],1,1]);if(2===e.length)return pi(xs(xs(i,0),0),[e[0],e[1],1,1]);if(3===e.length)return pi(xs(xs(xs(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Vv=U({floor_:function mve(n){const e={x:k(n,"x","floor","float32")};return B.runKernel(Xf,e)}}),xk=U({gather_:function gve(n,t,e=0,r=0){const s=k(n,"x","gather"),o=k(t,"indices","gather","int32");return B.runKernel(P_,{x:s,indices:o},{axis:e,batchDims:r})}}),so=U({greater_:function yve(n,t){let e=k(n,"a","greater","string_or_numeric"),r=k(t,"b","greater","string_or_numeric");return[e,r]=Ln(e,r),tt(e.shape,r.shape),B.runKernel(L_,{a:e,b:r})}}),sc=U({greaterEqual_:function bve(n,t){let e=k(n,"a","greaterEqual","string_or_numeric"),r=k(t,"b","greaterEqual","string_or_numeric");return[e,r]=Ln(e,r),tt(e.shape,r.shape),B.runKernel(Zf,{a:e,b:r})}}),Sk=U({leakyRelu_:function _ve(n,t=.2){const r={x:k(n,"x","leakyRelu")};return B.runKernel(V_,r,{alpha:t})}}),Po=U({log_:function vve(n){const e={x:k(n,"x","log","float32")};return B.runKernel(nm,e)}}),Tk=U({log1p_:function wve(n){const e={x:k(n,"x","log1p")};return B.runKernel(rm,e)}}),fi=U({max_:function xve(n,t=null,e=!1){const s={x:k(n,"x","max")};return B.runKernel(j_,s,{reductionIndices:t,keepDims:e})}}),Me=U({sum_:function Sve(n,t=null,e=!1){let r=k(n,"x","sum");return"bool"===r.dtype&&(r=Se(r,"int32")),B.runKernel(hv,{x:r},{axis:t,keepDims:e})}}),LG=U({logSoftmax_:function Tve(n,t=-1){const e=k(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Na((s,o)=>{const a=fi(s,t,!0),l=Fe(s,a),u=Fe(Se(l,"float32"),Po(Me(Mo(l),t,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[p]=h,m=Mo(p);return Fe(d,L(Me(d,t,!0),m))}}})(e)}}),Ra=U({logicalAnd_:function Cve(n,t){const e=k(n,"a","logicalAnd","bool"),r=k(t,"b","logicalAnd","bool");return tt(e.shape,r.shape),B.runKernel(U_,{a:e,b:r})}}),Ut=U({matMul_:function Eve(n,t,e=!1,r=!1){let s=k(n,"a","matMul"),o=k(t,"b","matMul");return[s,o]=Ln(s,o),B.runKernel(T_,{a:s,b:o},{transposeA:e,transposeB:r})}}),Ck=U({maxPool_:function Ive(n,t,e,r,s){const o=k(n,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),C(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),C(Rr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),is("maxPool",r,s);const d=B.runKernel(q_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Nve=U({maxPool3d_:function kve(n,t=[1,1,1],e,r,s,o="NDHWC"){const i=k(n,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),C(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),C("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),is("maxPool3d",r,s);const d=B.runKernel(K_,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return l?H(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Gn=U({mean_:function Dve(n,t=null,e=!1){const s={x:k(n,"x","mean")};return B.runKernel(X_,s,{axis:t,keepDims:e})}}),Bv=U({min_:function Ave(n,t=null,e=!1){const s={x:k(n,"x","min")};return B.runKernel(Y_,s,{axis:t,keepDims:e})}}),zv=U({minimum_:function Rve(n,t){let e=k(n,"a","minimum"),r=k(t,"b","minimum");return[e,r]=Ln(e,r),"bool"===e.dtype&&(e=Se(e,"int32"),r=Se(r,"int32")),tt(e.shape,r.shape),B.runKernel(om,{a:e,b:r})}});function Ek(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function VG(n,t,e){const r=n.length+t.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[o++]):s.push(t[i++]);return s}function Sr(n,t){const e=[],r=n.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&e.push(n[o]);return[e,t.map(o=>n[o])]}function Hn(n,t){return VG(n,t.map(r=>1),t)}function $r(n,t,e){C(Ek(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Dn(n,t){if(Ek(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function Ll(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function jn(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Ik=U({moments_:function $ve(n,t=null,e=!1){const r=bt(t,(n=k(n,"x","moments")).shape),s=Gn(n,r,e);let o=s.shape;e||(o=Hn(s.shape,r));const i=ln(Fe(Se(n,"float32"),H(s,o)));return{mean:s,variance:Gn(i,r,e)}}}),An=U({neg_:function Ove(n){const e={x:k(n,"x","neg")};return B.runKernel(Q_,e)}}),Vm=U({notEqual_:function Fve(n,t){let e=k(n,"a","notEqual","string_or_numeric"),r=k(t,"b","notEqual","string_or_numeric");return[e,r]=Ln(e,r),tt(e.shape,r.shape),B.runKernel(J_,{a:e,b:r})}}),BG=U({oneHot_:function Mve(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:k(n,"indices","oneHot","int32")};return B.runKernel(tv,i,{dtype:s,depth:t,onValue:e,offValue:r})}});function Tr(n,t="float32"){if(ka(n),"complex64"===t){const r=Tr(n,"float32"),s=Tr(n,"float32");return Yu(r,s)}const e=Gr(ne(n),t);return B.makeTensor(e,n,t)}function Vl(n,t="float32"){if(ka(n),"complex64"===t){const r=Vl(n,"float32"),s=Tr(n,"float32");return Yu(r,s)}const e=ME(ne(n),t);return B.makeTensor(e,n,t)}const Lo=U({onesLike_:function Pve(n){const e={x:k(n,"x","onesLike")};return B.runKernel(ev,e)}}),kk=U({pad_:function Lve(n,t,e=0){const r=k(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return B.runKernel(rv,{x:r},{paddings:t,constantValue:e})}}),Nk=U({prelu_:function Vve(n,t){const e=k(n,"x","prelu"),r=k(t,"alpha","prelu");return B.runKernel(sv,{x:e,alpha:r})}});class Dk{constructor(t,e,r,s,o){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=xl.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Bve{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=xl.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Hve=U({randomNormal_:function Gve(n,t=0,e=1,r,s){if(ka(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new Dk(t,e,r,!1,s),i=_t(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Uv=U({randomUniform_:function jve(n,t=0,e=1,r="float32",s){ka(n);const o=_t(n,r),i=new Bve(t,e,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}});function Bm(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return B.runKernel(mI,{},{start:n,stop:t,step:e,dtype:r})}const $a=U({relu_:function qve(n){const e={x:k(n,"x","relu")};return B.runKernel(cm,e)}}),oc=U({reverse_:function Kve(n,t){const r={x:k(n,"x","reverse")};return B.runKernel(uv,r,{dims:t})}}),zG=U({selu_:function Xve(n){const e={x:k(n,"x","selu")};return B.runKernel(fm,e)}}),UG=U({separableConv2d_:function Yve(n,t,e,r,s,o=[1,1],i="NHWC"){const a=k(n,"x","separableConv2d"),l=k(t,"depthwiseFilter","separableConv2d"),u=k(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),C(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),C(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),C(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),C(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];C(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=Pv(c,l,r,s,i,o),g=rc(f,u,1,"valid",i);return d?H(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),sh=U({sigmoid_:function Zve(n){const e={x:k(n,"x","sigmoid","float32")};return B.runKernel(bm,e)}}),Yt=U({slice_:function Qve(n,t,e){const r=k(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return B.runKernel(dv,{x:r},{begin:t,size:e})}}),Rk=U({slice1d_:function Jve(n,t,e){const r=k(n,"x","slice1d");return C(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Yt(r,[t],[e])}}),WG=U({slice2d_:function ewe(n,t,e){const r=k(n,"x","slice2d");return C(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Yt(r,t,e)}}),$k=U({slice3d_:function twe(n,t,e){const r=k(n,"x","slice3d");return C(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Yt(r,t,e)}}),Wv=U({slice4d_:function nwe(n,t,e){const r=k(n,"x","slice4d");return C(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Yt(r,t,e)}}),Ok=U({softmax_:function rwe(n,t=-1){const e=k(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return B.runKernel(mv,{logits:e},{dim:t})}}),zm=U({softplus_:function swe(n){const e={x:k(n,"x","softplus")};return B.runKernel(_m,e)}}),oo=U({split_:function owe(n,t,e=0){const s={x:k(n,"x","split")};return B.runKernel(fv,s,{numOrSizeSplits:t,axis:e})}}),Um=U({squeeze_:function iwe(n,t){const e=k(n,"x","squeeze","string_or_numeric");return H(e,Il(e.shape,t).newShape)}}),Oa=U({stack_:function awe(n,t=0){const e=qW(n,"tensors","stack","string_or_numeric");return C(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&C(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),B.runKernel(nv,e,{axis:t})}}),Fk=U({tanh_:function lwe(n){const e={x:k(n,"x","tanh","float32")};return B.runKernel(Tm,e)}});function Ss(n,t){AE(n);const e=Am(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Rm(n,null,e,t)}function oh(n,t,e){if(AE(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Am(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Rm(n,t,r,e)}const GG=U({truncatedNormal_:function uwe(n,t=0,e=1,r,s){if(ka(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new Dk(t,e,r,!0,s),i=_t(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),ic=U({unstack_:function cwe(n,t=0){const e=k(n,"x","unstack","string_or_numeric");return C(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),B.runKernel(gv,{value:e},{axis:t})}}),Ms=U({where_:function hwe(n,t,e){const r=k(t,"a","where"),s=k(e,"b","where"),o=k(n,"condition","where","bool"),i=tt(tt(o.shape,r.shape),s.shape),a=Lm(o,i),l=Lm(r,i),u=Lm(s,i);return B.runKernel(cv,{condition:a,t:l,e:u})}}),Mk=U({imag_:function pwe(n){const e={input:k(n,"input","imag")};return B.runKernel(lI,e)}}),Gv=U({real_:function fwe(n){const e={input:k(n,"input","real")};return B.runKernel(gI,e)}}),At=U({transpose_:function mwe(n,t,e){const r=k(n,"x","transpose");if(null==t&&(t=r.shape.map((i,a)=>a).reverse()),C(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{C(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:t};return"complex64"===r.dtype?te(()=>{let i=Gv(r),a=Mk(r);return i=B.runKernel(qd,{x:i},o),a=B.runKernel(qd,{x:a},o),e&&(a=An(a)),Yu(i,a)}):B.runKernel(qd,s,o)}}),bwe=U({dropout_:function ywe(n,t,e,r){const s=k(n,"x","dropout");if(C("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),C(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof yn?s.clone():s;const o=function gwe(n,t){if(null==t)return n.shape.slice();if(zt(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),i=1-t,a=ze(Vv(fe(Uv(o,0,1,"float32",r),i)),i);return L(s,a)}}),Pk=U({fft_:function _we(n){return C("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),B.runKernel("FFT",{input:n})}}),Lk=U({rfft_:function vwe(n,t){C("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,s=Yt(n,f,m),e=t}else if(null!=t&&t>e){const f=n.shape.map(m=>m);f[n.shape.length-1]=t-e,s=qr([n,Tr(f)],n.shape.length-1),e=t}else s=n;const o=$t(s),i=H(Yu(s,o),[r,e]),a=Pk(i),l=Math.floor(e/2)+1,u=Gv(a),c=Mk(a),d=oo(u,[l,e-l],u.shape.length-1),h=oo(c,[l,e-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,H(Yu(d[0],h[0]),p)}}),Hv=U({ifft_:function wwe(n){return C("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),B.runKernel(aI,{input:n})}}),HG=U({irfft_:function xwe(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=H(n,[e,t]);r=Hv(s)}else{const s=[e,2*(t-1)],o=H(Gv(n),[e,t]),i=H(Mk(n),[e,t]),a=oc(Yt(o,[0,1],[e,t-2]),1),l=L(oc(Yt(i,[0,1],[e,t-2]),1),Je(-1)),u=qr([o,a],1),c=qr([i,l],1),d=H(Yu(u,c),[s[0],s[1]]);r=Hv(d)}if(r=Gv(r),3===n.rank&&0!==n.shape[0]){const s=r,o=n.shape[0];r=H(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),Vk=U({conv2DBackpropFilter_:function Swe(n,t,e,r,s,o="NHWC",i){let a=n;3===n.rank&&(a=H(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=H(t,[1,t.shape[0],t.shape[1],t.shape[2]])),C(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),C(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),C(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return C(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),C(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),is("conv2dDerFilter",s,i),B.runKernel(jE,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:e})}}),jG=U({relu6_:function Twe(n){const e={x:k(n,"x","relu6")};return B.runKernel(dm,e)}}),Wm=U({step_:function Cwe(n,t=0){const r={x:k(n,"x","step")};return B.runKernel(Em,r,{alpha:t})}});function jv(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return L(n,Wm(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function qv(n,t){let e=t;const r=cr(n.shape,t.shape);return r.length>0&&(e=Me(e,r)),H(e,n.shape)}function Kv(n,t,e,r){if("linear"===t)return n;if("relu"===t)return $a(n);if("elu"===t)return Lv(n);if("relu6"===t)return jG(n);if("prelu"===t)return Nk(n,e);if("leakyrelu"===t)return Sk(n,r);if("sigmoid"===t)return sh(n);throw new Error(`Unknown fused activation ${t}.`)}const Xv=(n,t)=>!(n>0)||"linear"===t,Iwe=U({fusedConv2d_:function Ewe({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Xv(B.state.gradientDepth,l=l||"linear")){C("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=rc(n,t,e,r,s,o,i);return null!=a&&(S=fe(S,a)),Kv(S,l,u,c)}const d=k(n,"x","conv2d","float32"),h=k(t,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=H(d,[1,d.shape[0],d.shape[1],d.shape[2]])),C(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),C(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),is("fused conv2d",r,i);const m="NHWC"===s?p.shape[3]:p.shape[1];C(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),C(Rr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const g=xr(p.shape,h.shape,e,o,r,i);let y,b;if(null!=a&&(y=k(a,"bias","fused conv2d"),[y]=Ln(y,d),"NHWC"===s?tt(g.outShape,y.shape):(C(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),C(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=u){const S=u.shape;if(C(S.length<=1||3===S.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`),1===S.length)C(1===S[0]||S[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===S.length)try{tt(S,g.outShape)}catch(T){throw Error(`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}b=k(u,"prelu weights","fused conv2d")}const _=(S,T)=>{C("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[I,N,R,F]=T,j=jv(S,R,l);C(Pl(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const Q=[wk(N.shape,j,I,e,r),Vk(N,j,I.shape,e,r)];if(null!=F){const V=qv(F,j);Q.push(V)}return Q},v={x:p,filter:h,bias:y,preluActivationWeights:b},w={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?Na((T,I,N)=>{let R=B.runKernel(vv,v,w);return N([I,T,R]),f&&(R=H(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:_}})(p,h):Na((T,I,N,R)=>{let F=B.runKernel(vv,v,w);return R([I,T,F,N]),f&&(F=H(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:_}})(p,h,y)}}),qG=U({depthwiseConv2dNativeBackpropFilter_:function kwe(n,t,e,r,s,o=[1,1],i){let a=n;3===n.rank&&(a=H(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=H(t,[1,t.shape[0],t.shape[1],t.shape[2]])),B.runKernel(JE,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:e})}}),KG=U({depthwiseConv2dNativeBackpropInput_:function Nwe(n,t,e,r,s,o=[1,1],i){let a=t,l=!1;3===t.rank&&(l=!0,a=H(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=B.runKernel(eI,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:n});return l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),XG=U({fusedMatMul_:function Awe({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(!1===Xv(B.state.gradientDepth,o)){let F=Ut(n,t,e,r);return null!=s&&(F=fe(F,s)),Kv(F,o,i,a)}let l=k(n,"a","fused matMul"),u=k(t,"b","fused matMul");[l,u]=Ln(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=ne(f),y=ne(m);C(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const _=tt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),v=H(l,e?[g,c,h]:[g,h,c]),w=H(u,r?[y,p,d]:[y,d,p]);let S,T;null!=s&&(S=k(s,"bias","fused matMul"),[S]=Ln(S,l),tt(_,S.shape)),null!=i&&(T=k(i,"prelu weights","fused matMul"));const I=(F,j)=>{const[q,X,Q,V]=j,G=jv(H(F,Q.shape),Q,o);let W,Y;return e||r?!e&&r?(W=Ut(G,X,!1,!1),Y=Ut(G,q,!0,!1)):e&&!r?(W=Ut(X,G,!1,!0),Y=Ut(q,G,!1,!1)):(W=Ut(X,G,!0,!0),Y=Ut(G,q,!0,!0)):(W=Ut(G,X,!1,!0),Y=Ut(q,G,!0,!1)),null!=s?[W,Y,qv(V,G)]:[W,Y]},N={a:v,b:w,bias:S,preluActivationWeights:T},R={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?Na((j,q,X)=>{const Q=B.runKernel(_v,N,R);return X([j,q,Q]),{value:H(Q,_),gradFunc:I}})(v,w):Na((j,q,X,Q)=>{const V=B.runKernel(_v,N,R);return Q([j,q,V,X]),{value:H(V,_),gradFunc:I}})(v,w,S)}}),Bwe=U({cropAndResize_:function Vwe(n,t,e,r,s="bilinear",o=0){const i=k(n,"image","cropAndResize"),a=k(t,"boxes","cropAndResize","float32"),l=k(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return C(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),C(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),C(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),C(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),C(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),C("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),B.runKernel(YE,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),Uwe=U({flipLeftRight_:function zwe(n){const t=k(n,"image","flipLeftRight","float32");return C(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),B.runKernel(iI,{image:t},{})}}),Gwe=U({grayscaleToRGB_:function Wwe(n){const t=k(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];C(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),C(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,pi(t,s)}}),jwe=U({rotateWithOffset_:function Hwe(n,t,e=0,r=.5){const s=k(n,"image","rotateWithOffset","float32");return C(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),B.runKernel(RI,{image:s},{radians:t,fillValue:e,center:r})}});function ih(n,t,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=n.shape[0];return e=Math.min(e,i),C(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),C(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),C(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),C(1===t.rank,()=>"scores must be a 1D tensor"),C(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),C(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const Kwe=U({nonMaxSuppression_:function qwe(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=k(n,"boxes","nonMaxSuppression","float32"),i=k(t,"scores","nonMaxSuppression","float32"),a=ih(o,i,e,r,s);return B.runKernel(hI,{boxes:o,scores:i},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function Xwe(n,t,e){const r=function Ywe(n,t,e){return function Qwe(n,t,e){let r=0,s=n.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=e(t,n[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(n,t,e||Zwe)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function Zwe(n,t){return n>t?1:n<t?-1:0}function Bk(n,t,e,r,s){return Wk(n,t,e,r,s,0)}function zk(n,t,e,r,s,o){return Wk(n,t,e,r,s,0,!1,o,!0)}function Uk(n,t,e,r,s,o){return Wk(n,t,e,r,s,o,!0)}function Wk(n,t,e,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(JG);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<e&&u.length>0;){const g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:_}=g;if(y<s)break;let v=!1;for(let w=d.length-1;w>=_;--w){const S=Jwe(n,b,d[w]);if(S>=r){v=!0;break}if(g.score=g.score*e0e(r,c,S),g.score<=s)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&Xwe(u,g,JG))}const p=d.length,f=e-p;a&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function Jwe(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(a-o)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(o,u),g=Math.max(i,c),y=Math.min(a,d),b=Math.min(l,h),_=Math.max(y-m,0)*Math.max(b-g,0);return _/(p+f-_)}function e0e(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function JG(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function Gk(){return(Gk=$(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=k(n,"boxes","nonMaxSuppressionAsync"),i=k(t,"scores","nonMaxSuppressionAsync"),a=ih(o,i,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=Bk(u,c,e,r,s);return o!==n&&o.dispose(),i!==t&&i.dispose(),Ss(d,"int32")})).apply(this,arguments)}const s0e=U({nonMaxSuppressionWithScore_:function r0e(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=k(n,"boxes","nonMaxSuppression"),a=k(t,"scores","nonMaxSuppression"),l=ih(i,a,e,r,s,o),d=B.runKernel(fI,{boxes:i,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function Hk(){return(Hk=$(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=k(n,"boxes","nonMaxSuppressionAsync"),a=k(t,"scores","nonMaxSuppressionAsync"),l=ih(i,a,e,r,s,o);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=Uk(c,d,e,r,s,o);return i!==n&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Ss(h,"int32"),selectedScores:Ss(p)}})).apply(this,arguments)}const l0e=U({nonMaxSuppressionPadded_:function a0e(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=k(n,"boxes","nonMaxSuppression"),a=k(t,"scores","nonMaxSuppression"),l=ih(i,a,e,r,s,null),f=B.runKernel(pI,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:f[0],validOutputs:f[1]}}});function jk(){return(jk=$(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=k(n,"boxes","nonMaxSuppressionAsync"),a=k(t,"scores","nonMaxSuppressionAsync"),l=ih(i,a,e,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=yield Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:m}=zk(h,p,u,c,d,o);return i!==n&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Ss(f,"int32"),validOutputs:Je(m,"int32")}})).apply(this,arguments)}const eH=U({resizeBilinear_:function d0e(n,t,e=!1,r=!1){const s=k(n,"images","resizeBilinear");C(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),C(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),C(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=H(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,u=B.runKernel(lv,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return i?H(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),tH=U({resizeNearestNeighbor_:function h0e(n,t,e=!1,r=!1){const s=k(n,"images","resizeNearestNeighbor");C(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),C(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),C("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),C(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=H(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,u=B.runKernel(av,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return i?H(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),f0e=U({bincount_:function p0e(n,t,e){const r=k(n,"x","bincount"),s=k(t,"weights","bincount");return C("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),C(e>=0,()=>`size must be non-negative, but got ${e}.`),C(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),B.runKernel(GE,{x:r,weights:s},{size:e})}}),ah=U({lessEqual_:function m0e(n,t){let e=k(n,"a","lessEqual","string_or_numeric"),r=k(t,"b","lessEqual","string_or_numeric");return[e,r]=Ln(e,r),tt(e.shape,r.shape),B.runKernel(z_,{a:e,b:r})}}),nH=U({round_:function g0e(n){const e={x:k(n,"x","round")};return B.runKernel(hm,e)}}),_0e=U({threshold_:function y0e(n,t="binary",e=!1,r=.5){const s=k(n,"image","threshold"),l=s.shape[0]*s.shape[1];let c,d,h,p,u=L(Ss([r]),255);if(C(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),C(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),C("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),C("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[c,d,h]=oo(s,[1,1,1],-1);const g=L(c,.2989),y=L(d,.587),b=L(h,.114);p=fe(fe(g,y),b)}else p=n;"otsu"===t&&(u=function b0e(n,t){let o,i,a,l,u,c,e=Ss([-1]),r=Ss([0]),s=Ss([0]);for(let d=0;d<n.size-1;d++){o=Yt(n,0,d+1),i=Yt(n,d+1),u=ze(Me(o),t),c=ze(Me(i),t);const h=Me(L(o,Bm(0,o.size)));a=ze(h,Me(o));const p=$m(i.shape,o.size),f=fe(Bm(0,i.size),p),m=L(i,f);l=ze(Me(m),Me(i));const g=Fe(a,l),y=Fe(a,l),b=L(u,c);s=L(L(b,g),y);const _=so(s,r);r=Ms(_,s,r),e=Ms(_,Ss([d]),e)}return e}(f0e(Se(nH(p),"int32"),Zu([]),256),l));const f=e?ah(p,u):so(p,u);return Se(L(f,255),"int32")}}),w0e=U({transform_:function v0e(n,t,e="nearest",r="constant",s=0,o){const i=k(n,"image","transform","float32"),a=k(t,"transforms","transform","float32");return C(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),C(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),C(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),B.runKernel(NI,{image:i,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),S0e=U({bandPart_:function x0e(n,t,e){C(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),C(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=k(n,"a","bandPart");C(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);t<0&&(t=o),e<0&&(e=i);const a=H(Bm(0,o,1,"int32"),[-1,1]),l=Bm(0,i,1,"int32"),u=Fe(a,l),c=Ra(ah(u,Je(+t,"int32")),sc(u,Je(-e,"int32"))),d=Tr([o,i],r.dtype);return H(Oa(ic(H(r,[-1,o,i])).map(h=>Ms(c,h,d))),s)}});function rH(n,t,e=null){if(0===n.rank)return wr(n);if(1!==n.rank&&null===e)return rH(H(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Me(wr(n),e);if(t===1/0)return fi(wr(n),e);if(t===-1/0)return Bv(wr(n),e);if("euclidean"===t||2===t)return os(Me(th(wr(n),Je(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return fi(Me(wr(n),e[0]),e[1]-1);if(t===1/0)return fi(Me(wr(n),e[1]),e[0]);if(t===-1/0)return Bv(Me(wr(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return os(Me(ln(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Yv=U({norm_:function T0e(n,t="euclidean",e=null,r=!1){const s=rH(n=k(n,"x","norm"),t,e);let o=s.shape;if(r){const i=bt(e,n.shape);o=Hn(s.shape,i)}return H(s,o)}}),E0e=U({gramSchmidt_:function C0e(n){let t;if(Array.isArray(n)){t=!1,C(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)C(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else t=!0,n=oo(n,n.shape[0],0).map(s=>Um(s,[0]));C(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push(B.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=L(Me(L(e[i],o)),e[i]);o=Fe(o,a)}return ze(o,Yv(o,"euclidean"))}));return t?Oa(e,0):e}});function sH(n,t=!1){return B.tidy(()=>{C(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=PG(e),o=ec(n);const i=oh([[1]],[1,1]);let a=ec(i);const l=e>=r?r:e;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=B.tidy(()=>{const p=Yt(o,[u,u],[e-u,1]),f=Yv(p),m=Yt(o,[u,u],[1,1]),g=Ms(so(m,0),oh([[-1]]),oh([[1]])),y=Fe(m,L(g,f)),b=ze(p,y);a=1===b.shape[0]?ec(i):qr([i,Yt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const _=An(ze(Ut(g,y),f)),v=Yt(o,[u,0],[e-u,r]),w=L(_,a),S=At(a);if(0===u)o=Fe(v,Ut(w,Ut(S,v)));else{const N=Fe(v,Ut(w,Ut(S,v)));o=qr([Yt(o,[0,0],[u,r]),N],0)}const T=At(w),I=Yt(s,[0,u],[e,s.shape[1]-u]);if(0===u)s=Fe(I,Ut(Ut(I,a),T));else{const N=Fe(I,Ut(Ut(I,a),T));s=qr([Yt(s,[0,0],[e,u]),N],1)}return[a,o,s]}),mt([c,d,h])}return!t&&e>r&&(s=Yt(s,[0,0],[e,r]),o=Yt(o,[0,0],[r,r])),[s,o]})}const k0e=U({qr_:function I0e(n,t=!1){if(C(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return sH(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),r=ic(H(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=sH(l,t);s.push(u),o.push(c)}),[H(Oa(s,0),n.shape),H(Oa(o,0),n.shape)]}}}),oH=U({squaredDifference_:function B0e(n,t){let e=k(n,"a","squaredDifference"),r=k(t,"b","squaredDifference");return[e,r]=Ln(e,r),tt(e.shape,r.shape),B.runKernel(wm,{a:e,b:r},{})}}),iH=U({logSumExp_:function j0e(n,t=null,e=!1){const r=k(n,"x","logSumExp"),s=bt(t,r.shape),o=fi(r,s,!0),i=Fe(r,o),a=Mo(i),l=Me(a,s),u=Po(l),c=fe(H(o,u.shape),u);if(e){const d=Hn(c.shape,s);return H(c,d)}return c}}),Bl={flipLeftRight:Uwe,grayscaleToRGB:Gwe,resizeNearestNeighbor:tH,resizeBilinear:eH,rotateWithOffset:jwe,cropAndResize:Bwe,nonMaxSuppression:Kwe,nonMaxSuppressionAsync:function t0e(n,t,e){return Gk.apply(this,arguments)},nonMaxSuppressionWithScore:s0e,nonMaxSuppressionWithScoreAsync:function o0e(n,t,e){return Hk.apply(this,arguments)},nonMaxSuppressionPadded:l0e,nonMaxSuppressionPaddedAsync:function u0e(n,t,e){return jk.apply(this,arguments)},threshold:_0e,transform:w0e},cxe={bandPart:S0e,gramSchmidt:E0e,qr:k0e},lh=class dxe{static sgd(t){return new sk(t)}static momentum(t,e,r=!1){return new hG(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,o=!1){return new pG(t,e,r,s,o)}static adam(t=.001,e=.9,r=.999,s=null){return new cG(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new lG(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,o=0){return new dG(t,e,r,s,o)}static adagrad(t,e=.1){return new uG(t,e)}},hxe="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:n=>n();function aH(){return new Promise(n=>hxe(()=>n()))}function qk(n,t){const e=n[0].length;n.forEach((s,o)=>{C(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),C(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,o)=>{for(let i=0;i<e;i++)C(i===t||s[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Xi(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var Vo=(()=>{return(n=Vo||(Vo={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",Vo;var n})();function lH(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const o=e[s],i=r[r.length-e.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${o} but shape[${s+n}] = ${a}`)}else r[i]=o}return r}function uH(n){const t={FIRST_DIM_SIZE:Vo.FIRST_DIM_SIZE,VALUE_ROWIDS:Vo.VALUE_ROWIDS,ROW_LENGTHS:Vo.ROW_LENGTHS,ROW_SPLITS:Vo.ROW_SPLITS,ROW_LIMITS:Vo.ROW_LIMITS,ROW_STARTS:Vo.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function cH(n){return 0===n.length?0:n[0]===Vo.FIRST_DIM_SIZE?n.length-1:n.length}function dH(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const o=n[s],i=t[s+1];if(o>=0&&i>=0&&1!==o&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${o} but ragged tensor input.flatValues.shape[${s-n.length}] = ${i}`)}}const Kk=30;function Zv(n){return n<=Kk?n:FE(n,Math.floor(Math.sqrt(n)))}function Xk(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function Gm(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=t.length;for(let i=0;i<o;++i)s=s.concat([n[i+1]/t[i],t[i]]);s=s.concat(n.slice(o+1))}return s}function Hm(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<n;++i)i>=2*t+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function jm(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let o=1;o<n.length;++o)s.push(o<=t.length?r?t[o-1]*n[o]:n[o]/t[o-1]:n[o]);return s}function Yk(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function Zk(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function Qk(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===ne(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=n.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<e;++d)u*=a[d],l.push(a[d]);const c=[...Be(n.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}function hH(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(o+" update.rank != "+(s+n.length-r));for(let i=0;i<s;++i)if(e.shape[i]!==t.shape[i])throw new Error(o+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-s;++i)if(e.shape[i+s]!==n[i+r])throw new Error(o+` updates.shape[${i+s}] (${e.shape[i+s]}) != shape[${i+s}] (${n[i+s]})`)}function pxe(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}hH(e,t,n)}function qm(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,o=e.length;let i=1;for(let d=s;d<o;++d)i*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:ne(t.shape)/a,sliceSize:i,strides:[...Be(e.slice(0,s)),1],outputSize:ne(e)}}const Qv=1.7580993408473768,Jv=1.0507009873554805,Jk=.3275911,eN=.254829592,tN=-.284496736,nN=1.421413741,rN=-1.453152027,sN=1.061405429;function Ma(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function pH(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function fH(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function mH(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function oN(n,t){return{real:n[2*t],imag:n[2*t+1]}}function gH(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function yH(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function bH(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const fxe=/->/g;function aN(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(fxe,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");C(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const o=r.split(","),i=o.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const p=s[h];if(!o.some(f=>-1!==f.indexOf(p)))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);-1===a.indexOf(p)&&a.push(p)}for(let h=0;h<r.length;++h){const p=r[h];-1===a.indexOf(p)&&","!==p&&a.push(p)}const l=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<o[h].length;++p)l[h].push(a.indexOf(o[h][p]))}const u=a.length,d=[];for(let h=s.length;h<u;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function lN(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function uN(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const o=e[s].shape;for(let i=0;i<t[s].length;++i)void 0===r[t[s][i]]?r[t[s][i]]=o[i]:C(r[t[s][i]]===o[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function cN(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<e.length;++i){const l=mxe(t,e[i]);for(const u of l)-1===o.indexOf(u)&&(r[i].push(u),o.push(u))}return{path:e,steps:r}}function dN(n){return n.every((t,e)=>t===e)}function mxe(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function hN(n,t,e=0){let r=[];if("number"==typeof t)C(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{C(t.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(-1!==o){const i=t.reduce((a,l)=>l>0?a+l:a);t[o]=n.shape[e]-i}C(n.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function wH(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function xH(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function SH(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function TH(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function CH(n,t){return`size ${n} must be non-negative, not ${t}`}function EH(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function IH(n,t){return`Input to reshape is a SparseTensor with ${ne(n)}\n  dense values, but the requested shape requires a multiple of ${ne(t)}. inputShape=${n} outputShape= ${t}`}function kH(n,t){return`Input to reshape is a tensor with ${ne(n)} dense values, but the requested shape has ${ne(t)}. inputShape=${n} outputShape=${t}`}function pN(){return"segment ids must be >= 0"}function NH(){return"segment ids are not increasing"}function DH(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function AH(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function RH(n,t){let r,e=!1;for(n<=Kk?(r=n,e=!0):r=FE(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=FE(n,r+1);return r}function $H(n,t,e){const r=[],s=n.length;for(let o=0;o<s;o++)r.push(o!==t?n[o]:e);return r}function fN(n,t,e,r){const s=t.shape.length,o=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=n.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<e;d++)a.push(n.shape[d]),u*=n.shape[d];for(let d=r;d<s;d++)a.push(t.shape[d]);for(let d=e+1;d<o;d++)a.push(n.shape[d]),c*=n.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function ac(n){try{return n.map(t=>Al(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function OH(n){return n.map(t=>Dl(t))}function FH(n,t){const e=[];for(let o=0;o<t.length;o++)t[o]&&e.push(o);const r=_t(n,"int32"),s=_t([e.length,n.length],"int32");for(let o=0;o<e.length;o++){const i=r.indexToLoc(e[o]);s.values.set(i,o*n.length)}return s.toTensor()}!function Qbe(){for(const n of Zbe)de(n)}();const MH={kernelName:__,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,Wm(Se(e,"float32"),-1))}}},gxe={kernelName:Rf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=ln(Se(e,"float32")),s=os(Fe(Je(1),r));return An(ze(n,s))}}}},yxe={kernelName:$f,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=os(Fe(ln(Se(e,"float32")),1));return ze(n,r)}}}},bxe={kernelName:jd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{let a=n;const l=cr(e.shape,s);return l.length>0&&(a=Me(a,l)),H(a,e.shape)},b:()=>{let a=n;const l=cr(r.shape,s);return l.length>0&&(a=Me(a,l)),H(a,r.shape)}}}},_xe={kernelName:VE,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}},vxe={kernelName:v_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$t(e)}}},wxe={kernelName:w_,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$t(e)}}},xxe={kernelName:Of,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,os(Fe(Je(1),ln(Se(e,"float32")))))}}},Sxe={kernelName:Ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=os(fe(Je(1),ln(Se(e,"float32"))));return ze(n,r)}}}},Txe={kernelName:Lf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=fe(ln(e),ln(r));let l=L(n,ze(r,a));const u=cr(e.shape,s);return u.length>0&&(l=Me(l,u)),H(l,e.shape)},b:()=>{const a=fe(ln(e),ln(r));let l=An(L(n,ze(e,a)));const u=cr(r.shape,s);return u.length>0&&(l=Me(l,u)),H(l,r.shape)}}}},Cxe={kernelName:Mf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,fe(ln(Se(e,"float32")),1))}}},Exe={kernelName:Pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,Fe(Je(1),ln(Se(e,"float32"))))}}},kxe=U({avgPool3dGrad_:function Ixe(n,t,e,r,s,o){const i=k(n,"dy","avgPool3dGrad"),a=k(t,"input","avgPool3dGrad");let l=i,u=a,c=!1;4===a.rank&&(c=!0,l=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=H(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),C(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),C(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),is("avgPool3dGrad",s,o);const p=B.runKernel(WE,{dy:l,input:u},{filterSize:e,strides:r,pad:s,dimRoundingMode:o});return c?H(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Nxe={kernelName:S_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:a}=e;return{x:()=>kxe(n,r,s,o,i,a)}}},Axe=U({avgPoolGrad_:function Dxe(n,t,e,r,s){const o=k(n,"dy","avgPoolGrad"),i=k(t,"input","avgPoolGrad");C(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;3===i.rank&&(u=!0,a=H(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),C(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),C(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=B.runKernel(UE,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return u?H(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Rxe={kernelName:x_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:o,pad:i}=e;return{x:()=>Axe(n,r,s,o,i)}}},$xe={kernelName:T_,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,s]=t,{transposeA:o,transposeB:i}=e;return o||i?!o&&i?{a:()=>Ut(n,s,!1,!1),b:()=>Ut(n,r,!0,!1)}:o&&!i?{a:()=>Ut(s,n,!1,!0),b:()=>Ut(r,n,!1,!1)}:{a:()=>Ut(s,n,!0,!0),b:()=>Ut(n,r,!0,!0)}:{a:()=>Ut(n,s,!1,!0),b:()=>Ut(r,n,!0,!1)}}},mN=U({spaceToBatchND_:function Oxe(n,t,e){const r=k(n,"x","spaceToBatchND");return C(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),C(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),C(r.shape.reduce((i,a,l)=>l>0&&l<=t.length?i&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),B.runKernel(pv,{x:r},{blockShape:t,paddings:e})}}),Fxe={kernelName:C_,gradFunc:(n,t,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>mN(n,r,s)}}},Mxe={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const s=e.inputShape,o=e.shape,i=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>Me(n,a,!0)}}},Pxe={kernelName:Vf,gradFunc:n=>({x:()=>n.clone()})},Lxe={kernelName:Bf,gradFunc:n=>({x:()=>$t(n)})},Vxe={kernelName:zf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:s,clipValueMax:o}=e;return{x:()=>Ms(Ra(sc(r,s),ah(r,o)),n,$t(n))}}},Bxe={kernelName:E_,inputsToSave:["x"],gradFunc:MH.gradFunc},zxe={kernelName:I_,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(l=>l.shape),{axis:s}=e,o=bt(s,t[0].shape)[0],i=r.map(l=>l[o]);return oo(n,i,o).map(l=>()=>l)}},Uxe={kernelName:k_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{dilations:o,strides:i,pad:a,dataFormat:l}=e;return C(Pl(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>wk(r.shape,n,s,i,a,l),filter:()=>Vk(r,n,s.shape,i,a,l)}}},Wxe={kernelName:N_,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>rc(n,s,o,i,a,1,l),filter:()=>Vk(n,r,s.shape,o,i,a,l)}}},Hxe=U({conv3DBackpropFilter_:function Gxe(n,t,e,r,s){let o=n;4===n.rank&&(o=H(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let i=t;return 4===i.rank&&(i=H(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),C(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),C(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),C(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),C(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),C(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`),B.runKernel(qE,{x:o,dy:i},{strides:r,pad:s,filterShape:e})}}),jxe={kernelName:D_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:o}=e;C(Pl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,a]=t;return{x:()=>FG(i.shape,n,a,s,o),filter:()=>Hxe(i,n,a.shape,s,o)}}},PH=U({sin_:function qxe(n){const e={x:k(n,"x","sin","float32")};return B.runKernel(mm,e)}}),Kxe={kernelName:Uf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(An(PH(Se(e,"float32"))),n)}}},LH=U({sinh_:function Xxe(n){const e={x:k(n,"x","sinh")};return B.runKernel(gm,e)}}),Yxe={kernelName:Wf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(LH(Se(e,"float32")),n)}}},VH=U({cumsum_:function Zxe(n,t=0,e=!1,r=!1){const o={x:k(n,"x","cumsum")};return B.runKernel(A_,o,{axis:t,exclusive:e,reverse:r})}}),Qxe={kernelName:A_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s,exclusive:o,reverse:i}=e;return{x:()=>{const a=Dn([s],r.rank);let l=VH(n,s,o,!i);return null!=a&&(l=At(l,a)),l}}}},Jxe={kernelName:R_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:i}=e,a=null==r?[1,1]:r;C(Pl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=t;return C(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),C(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),C(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),C(Rr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),is("depthwiseConv2d",o,i),{x:()=>KG(l.shape,n,u,s,o,a,i),filter:()=>qG(l,n,u.shape,s,o,a,i)}}},eSe={kernelName:$_,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,o={x:r,filter:s,dy:n},i={x:r,filter:s,dy:n};return{x:()=>B.runKernel(tI,o,e),filter:()=>B.runKernel(nI,i,e)}}},tSe={kernelName:Hf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>B.runKernel(rI,r)}}},nSe={kernelName:jf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=L(Mo(An(ln(e))),2/Math.sqrt(Math.PI));return{x:()=>L(n,r)}}},rSe={kernelName:qf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,e)}}},sSe={kernelName:F_,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>H(n,e.shape)}}},oSe={kernelName:Kf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,Mo(e))}}},iSe={kernelName:Xf,gradFunc:n=>({x:()=>$t(n)})},aSe={kernelName:Yf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=ze(n,Se(r,"float32")),l=cr(e.shape,s);return l.length>0?H(Me(a,l),e.shape):a},b:()=>{let a=L(n,Se(e,"float32"));const l=cr(r.shape,s);l.length>0&&(a=H(Me(a,l),r.shape));const u=ln(r);return An(ze(a,Se(u,"float32")))}}}},BH=U({rsqrt_:function lSe(n){const e={x:k(n,"x","rsqrt","float32")};return B.runKernel(pm,e)}}),uSe={kernelName:M_,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[s,o,i,a]=t,l=null==a?Je(1):a,u=cr(o.shape,s.shape),c=[];if(1===o.rank){for(let v=0;v<s.shape.length-1;++v)c.push(s.shape[v]);c.push(1)}const d=Fe(s,o),h=L(n,l),p=BH(fe(i,Je(r))),f=L(L(L(p,p),p),Je(-.5));return{x:()=>H(L(L(n,1===o.rank?pi(H(p,[1,1,1,o.shape[0]]),c):p),l),s.shape),mean:()=>{let v=L(L(p,Je(-1)),h);return 1===o.rank&&(v=Me(v,u)),H(v,o.shape)},variance:()=>{let v=L(L(f,d),h);return 1===o.rank&&(v=Me(v,u)),H(v,o.shape)},scale:()=>{const v=L(d,p);let w=L(n,v);return 1===o.rank&&(w=Me(w,u)),H(w,o.shape)},offset:()=>{let v=n;return 1===o.rank&&(v=Me(v,u)),H(v,o.shape)}}}},zH=U({unsortedSegmentSum_:function cSe(n,t,e){const r=k(n,"x","unsortedSegmentSum"),s=k(t,"segmentIds","unsortedSegmentSum","int32");return C(Wd(e),()=>"numSegments must be of dtype int"),B.runKernel(yv,{x:r,segmentIds:s},{numSegments:e})}}),dSe={kernelName:P_,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,s]=t,{axis:o}=e,i=bt(o,r.shape)[0];return{x:()=>{const l=r.shape,u=s.size,c=l.slice(0,i),d=c.length,h=l.slice(o,l.length).slice(1),p=h.length,f=UH(0,d),m=UH(d+1,d+1+p),g=WH([c,[u],h]),y=H(n,g),b=H(s,[u]),_=WH([[d],f,m]),v=At(y,_);let w=zH(v,b,r.shape[i]);const S=Ll(_);return w=At(w,S),w},indices:()=>s}}};function UH(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function WH(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const hSe={kernelName:Zf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>$t(e),b:()=>$t(r)}}},pSe={kernelName:Qf,gradFunc:n=>({x:()=>Se(n,"float32")})},fSe={kernelName:Jf,gradFunc:n=>({x:()=>$t(n)})},mSe={kernelName:em,gradFunc:n=>({x:()=>$t(n)})},gSe={kernelName:tm,gradFunc:n=>({x:()=>$t(n)})},ySe={kernelName:V_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:s}=e,o=so(r,0);return{x:()=>Ms(o,n,L(n,s))}}},bSe={kernelName:rm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,fe(e,1))}}},_Se={kernelName:nm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,Se(e,"float32"))}}},vSe={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;return{logits:()=>{const i=Mo(r);return Fe(n,L(Me(n,s,!0),i))}}}},xSe=U({localResponseNormalizationBackprop_:function wSe(n,t,e,r=5,s=1,o=1,i=.5){return B.runKernel(uI,{x:n,y:t,dy:e},{depthRadius:r,bias:s,alpha:o,beta:i})}}),SSe={kernelName:H_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{depthRadius:o,bias:i,alpha:a,beta:l}=e;return{x:()=>xSe(r,s,n,o,i,a,l)}}};function GH(n,t,e,r){return t.rank<e.rank&&(t=H(t,Hn(t.shape,r))),n.rank<e.rank&&(n=H(n,Hn(n.shape,r))),{x:()=>L(n,Se(Ki(e,t),n.dtype))}}const HH={kernelName:j_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:s}=r,o=t[0],l=GH(n,t[1],o,bt(s,o.shape));return{x:()=>l.x()}}},jH=U({less_:function TSe(n,t){let e=k(n,"a","less","string_or_numeric"),r=k(t,"b","less","string_or_numeric");return[e,r]=Ln(e,r),tt(e.shape,r.shape),B.runKernel(B_,{a:e,b:r})}}),CSe={kernelName:sm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>L(n,Se(sc(e,r),"float32")),b:()=>L(n,Se(jH(e,r),"float32"))}}},ISe=U({maxPool3dGrad_:function ESe(n,t,e,r,s,o,i){const a=k(n,"dy","maxPool3dGrad"),l=k(t,"input","maxPool3dGrad"),u=k(e,"output","maxPool3dGrad");let c=a,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=H(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=H(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=H(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),C(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),C(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),C(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),is("maxPool3dGrad",o,i);const g=B.runKernel(dI,{dy:c,input:d,output:h},{filterSize:r,strides:s,pad:o,dimRoundingMode:i});return p?H(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),kSe={kernelName:K_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>ISe(n,r,s,o,i,a,l)}}},DSe=U({maxPoolGrad_:function NSe(n,t,e,r,s,o,i){const a=k(n,"dy","maxPoolGrad"),l=k(t,"input","maxPoolGrad"),u=k(e,"output","maxPoolGrad");return C(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),C(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),C(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),is("maxPoolGrad",o,i),B.runKernel(cI,{dy:a,input:l,output:u},{filterSize:r,strides:s,pad:o,dimRoundingMode:i})}}),ASe={kernelName:q_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:o,strides:i,pad:a}=e;return{x:()=>DSe(n,r,s,o,i,a)}}},RSe={kernelName:X_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e,o=bt(s,r.shape),l=ne(Sr(r.shape,o)[1]);return{x:()=>{const c=r.shape.slice();o.forEach(p=>{c[p]=1});const d=H(n,c);return ze(L(d,Vl(r.shape,"float32")),l)}}}},$Se={kernelName:Y_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:s}=r,[o,i]=t,l=GH(n,i,o,bt(s,o.shape));return{x:()=>l.x()}}},OSe={kernelName:om,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>L(n,Se(ah(e,r),"float32")),b:()=>L(n,Se(so(e,r),"float32"))}}},FSe={kernelName:Z_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Yt(n,o,r.shape)}}},MSe={kernelName:im,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=cr(e.shape,s);return a.length>0?H(Me(n,a),e.shape):n},b:()=>{const a=L(n,An(Vv(ze(e,r)))),l=cr(r.shape,s);return l.length>0?H(Me(a,l),r.shape):a}}}},PSe={kernelName:am,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=L(n,Se(r,"float32")),l=cr(e.shape,s);return l.length>0?H(Me(a,l),e.shape):a},b:()=>{const a=L(n,Se(e,"float32")),l=cr(r.shape,s);return l.length>0?H(Me(a,l),r.shape):a}}}},LSe={kernelName:Q_,gradFunc:n=>({x:()=>An(n)})},VSe={kernelName:tv,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Tr(e.shape,"float32")}}},BSe={kernelName:ev,gradFunc:n=>({x:()=>$t(n)})},zSe={kernelName:nv,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return ic(n,r).map(o=>()=>o)}},qH={kernelName:rv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Yt(n,o,r.shape)}}},USe={kernelName:lm,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,s]=t,o=e,i=r,a=tt(o.shape,i.shape);return{a:()=>{const c=Se(i,"float32");let d=L(n,L(c,th(o,Fe(c,Je(1)))));const h=cr(o.shape,a);return h.length>0&&(d=Me(d,h)),H(d,o.shape)},b:()=>{const c=so(o,0),d=Ms(c,Po(o),$t(o));let h=L(n,L(s,d));const p=cr(i.shape,a);return p.length>0&&(h=Me(h,p)),H(h,i.shape)}}}},WSe={kernelName:sv,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,s=so(e,0);return{x:()=>Ms(s,n,L(n,r)),alpha:()=>{let o=Ms(s,$t(n),L(n,e));const i=cr(r.shape,n.shape);return i.length>0&&(o=Me(o,i)),H(o,r.shape)}}}},gN=U({cumprod_:function GSe(n,t=0,e=!1,r=!1){const o={x:k(n,"x","cumprod")};return B.runKernel(XE,o,{axis:t,exclusive:e,reverse:r})}});const qSe={kernelName:ov,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;let o=[];return o=null==s?r.shape.map((i,a)=>a):"number"==typeof s?[s]:s,{x:()=>function jSe(n,t,e){const r=n.shape.length,s=r-e.length,o=Dn(e,r);let i=n;null!=o&&(i=At(n,o));const a=i.shape.slice(),u=a.splice(r-e.length,e.length).reduce((h,p)=>h*p,1);a.push(u);let d=function HSe(n,t,e){const r=n.shape.slice();r[e]=1;const s=H(t,r),o=gN(n,e,!0,!1),i=gN(n,e,!0,!0),a=L(o,i);return L(s,a)}(i.reshape(a),t,s);if(d=d.reshape(i.shape),null!=o){const h=Ll(o);d=At(d,h)}return d}(r,n,o)}}},KSe={kernelName:Gf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=ze(n,Se(r,"float32")),l=cr(e.shape,s);return l.length>0?H(Me(a,l),e.shape):a},b:()=>{let a=L(n,Se(e,"float32"));const l=cr(r.shape,s);l.length>0&&(a=H(Me(a,l),r.shape));const u=ln(r);return An(ze(a,Se(u,"float32")))}}}},XSe={kernelName:um,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,An(ln(e)))}}},YSe={kernelName:dm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=L(ah(e,6),Wm(e));return{x:()=>L(n,Se(r,"float32"))}}},ZSe={kernelName:cm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,Se(Wm(e),"float32"))}}},QSe={kernelName:iv,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>H(n,e.shape)}}},JSe={kernelName:lv,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>B.runKernel(bI,s,e)}}},eTe={kernelName:av,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>B.runKernel(yI,s,e)}}},tTe={kernelName:uv,gradFunc:(n,t,e)=>{const{dims:r}=e,s=bt(r,n.shape);return{x:()=>oc(n,s)}}},nTe={kernelName:hm,gradFunc:n=>({x:()=>$t(n)})},rTe={kernelName:pm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>An(ze(n,L(th(e,1.5),2)))}}},yN=U({logicalNot_:function sTe(n){const e={x:k(n,"x","logicalNot","bool")};return B.runKernel(W_,e)}}),oTe={kernelName:cv,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>Se($t(e),"float32"),t:()=>L(n,Se(e,n.dtype)),e:()=>L(n,Se(yN(e),n.dtype))}}},iTe={kernelName:fm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=so(e,Je(0)),s=Je(Qv),o=Je(Jv),i=L(n,o),a=L(L(n,s),Mo(Se(e,"float32")));return Ms(r,i,a)}}}},aTe={kernelName:bm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,L(e,Fe(Je(1),e)))}}},lTe={kernelName:ym,gradFunc:n=>({x:()=>$t(n)})},bN=U({cos_:function uTe(n){const e={x:k(n,"x","cos","float32")};return B.runKernel(Uf,e)}}),cTe={kernelName:mm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(bN(Se(e,"float32")),n)}}},KH=U({cosh_:function dTe(n){const e={x:k(n,"x","cosh","float32")};return B.runKernel(Wf,e)}}),hTe={kernelName:gm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(KH(Se(e,"float32")),n)}}},pTe={kernelName:dv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:s,size:o}=e,i=r.shape,[a,l]=Fv(r,s,o),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>kk(n,u)}}},fTe={kernelName:mv,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:s}=e,i=L(n,r);return{logits:()=>Fe(i,L(Me(i,[s],!0),r))}}},mTe={kernelName:_m,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,sh(e))}}},_N=U({batchToSpaceND_:function gTe(n,t,e){const r=k(n,"x","batchToSpaceND"),s=t.reduce((a,l)=>a*l);return C(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),C(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),C(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),B.runKernel(C_,{x:r},{blockShape:t,crops:e})}}),XH={kernelName:pv,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>_N(n,r,s)}}},YH={kernelName:fv,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>qr(n,r)}}},ATe=[MH,gxe,yxe,bxe,_xe,vxe,wxe,xxe,Sxe,Txe,Cxe,Exe,Nxe,Rxe,$xe,Fxe,Mxe,Pxe,Lxe,Vxe,Bxe,zxe,Wxe,Uxe,jxe,Kxe,Yxe,Qxe,Jxe,eSe,KSe,tSe,nSe,rSe,sSe,oSe,aSe,iSe,uSe,dSe,hSe,pSe,fSe,mSe,gSe,ySe,bSe,_Se,vSe,SSe,HH,HH,CSe,kSe,ASe,RSe,$Se,OSe,FSe,MSe,PSe,LSe,VSe,BSe,zSe,qH,qH,USe,WSe,qSe,XSe,YSe,ZSe,QSe,JSe,eTe,tTe,nTe,rTe,oTe,iTe,aTe,lTe,cTe,hTe,pTe,fTe,mTe,XH,XH,YH,YH,{kernelName:vm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,L(os(Se(e,"float32")),2))}}},{kernelName:wm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(2);return{a:()=>L(n,L(s,Fe(e,r))),b:()=>L(n,L(s,Fe(r,e)))}}},{kernelName:SI,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(n,L(Se(e,"float32"),2))}}},{kernelName:Em,gradFunc:n=>({x:()=>$t(n)})},{kernelName:xm,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{let a=n;const l=cr(e.shape,s);return l.length>0&&(a=Me(a,l)),H(a,e.shape)},b:()=>{let a=n;const l=cr(r.shape,s);return l.length>0&&(a=Me(a,l)),H(An(a),r.shape)}}}},{kernelName:hv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,s=r.shape.slice(),{axis:o}=e;bt(o,r.shape).forEach(u=>{s[u]=1});const a=H(n,s),l=L(a,Vl(r.shape,"float32"));return{x:()=>l}}},{kernelName:Sm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ze(n,ln(bN(e)))}}},{kernelName:Tm,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>L(Fe(Je(1),ln(e)),n)}}},{kernelName:Cm,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:s}=e;return{x:()=>{let i=$t(r);if(1===r.rank)for(let a=0;a<s[0];++a)i=fe(i,Yt(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)i=fe(i,Yt(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=fe(i,Yt(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=fe(i,Yt(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},{kernelName:qd,gradFunc:(n,t,e)=>{const r=e,{perm:s}=r,o=Ll(s);return{x:()=>At(n,o)}}},{kernelName:gv,gradFunc:(n,t,e)=>{const r=e,{axis:s}=r;return{value:()=>Oa(n,s)}}},{kernelName:yv,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function NTe(n,t){const e=Fl(t,$t(t)),r=xk(n,e);let s=sc(t,Je(0,"int32"));const o=r.rank-s.rank;for(let a=0;a<o;++a)s=xs(s,a+1);s=Ra(s,Vl(r.shape,"bool"));const i=$t(r);return Ms(s,r,i)}(n,e)}}},{kernelName:bv,gradFunc:n=>({x:()=>$t(n)})}];for(const n of ATe)Pye(n);re().prototype.abs=function(){return this.throwIfDisposed(),wr(this)};const $Te=U({acos_:function RTe(n){const e={x:k(n,"x","acos")};return B.runKernel(Rf,e)}});re().prototype.acos=function(){return this.throwIfDisposed(),$Te(this)};const FTe=U({acosh_:function OTe(n){const e={x:k(n,"x","acosh")};return B.runKernel($f,e)}});re().prototype.acosh=function(){return this.throwIfDisposed(),FTe(this)},re().prototype.add=function(n){return this.throwIfDisposed(),fe(this,n)},re().prototype.all=function(n,t){return this.throwIfDisposed(),RG(this,n,t)},re().prototype.any=function(n,t){return this.throwIfDisposed(),yk(this,n,t)},re().prototype.argMax=function(n){return this.throwIfDisposed(),Om(this,n)};const PTe=U({argMin_:function MTe(n,t=0){const r={x:k(n,"x","argMin")};return B.runKernel(w_,r,{axis:t})}});re().prototype.argMin=function(n){return this.throwIfDisposed(),PTe(this,n)},re().prototype.asScalar=function(){return this.throwIfDisposed(),C(1===this.size,()=>"The array must have only 1 element."),H(this,[])},re().prototype.asType=function(n){return this.throwIfDisposed(),Se(this,n)},re().prototype.as1D=function(){return this.throwIfDisposed(),H(this,[this.size])},re().prototype.as2D=function(n,t){return this.throwIfDisposed(),H(this,[n,t])},re().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),H(this,[n,t,e])},re().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),H(this,[n,t,e,r])},re().prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),H(this,[n,t,e,r,s])};const VTe=U({asin_:function LTe(n){const e={x:k(n,"x","asin")};return B.runKernel(Of,e)}});re().prototype.asin=function(){return this.throwIfDisposed(),VTe(this)};const zTe=U({asinh_:function BTe(n){const e={x:k(n,"x","asinh")};return B.runKernel(Ff,e)}});re().prototype.asinh=function(){return this.throwIfDisposed(),zTe(this)};const WTe=U({atan_:function UTe(n){const e={x:k(n,"x","atan")};return B.runKernel(Mf,e)}});re().prototype.atan=function(){return this.throwIfDisposed(),WTe(this)};const HTe=U({atan2_:function GTe(n,t){let e=k(n,"a","atan2"),r=k(t,"b","atan2");return[e,r]=Ln(e,r),B.runKernel(Lf,{a:e,b:r})}});re().prototype.atan2=function(n){return this.throwIfDisposed(),HTe(this,n)};const qTe=U({atanh_:function jTe(n){const e={x:k(n,"x","atanh")};return B.runKernel(Pf,e)}});re().prototype.atanh=function(){return this.throwIfDisposed(),qTe(this)},re().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),vk(this,n,t,e,r)},re().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),_N(this,n,t)},re().prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),Mv(this,n,t,e,r,s)},re().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Lm(this,n)},re().prototype.cast=function(n){return this.throwIfDisposed(),Se(this,n)};const XTe=U({ceil_:function KTe(n){const e={x:k(n,"x","ceil","float32")};return B.runKernel(Bf,e)}});re().prototype.ceil=function(){return this.throwIfDisposed(),XTe(this)},re().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),ro(this,n,t)},re().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof yn&&(n=[n]),qr([this,...n],t)},re().prototype.conv1d=function(n,t,e,r,s,o){return this.throwIfDisposed(),$G(this,n,t,e,r,s,o)},re().prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),OG(this,n,t,e,r,s)},re().prototype.conv2d=function(n,t,e,r,s,o){return this.throwIfDisposed(),rc(this,n,t,e,r,s,o)},re().prototype.cos=function(){return this.throwIfDisposed(),bN(this)},re().prototype.cosh=function(){return this.throwIfDisposed(),KH(this)},re().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),gN(this,n,t,e)},re().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),VH(this,n,t,e)};const ZTe=U({depthToSpace_:function YTe(n,t,e="NHWC"){const r=k(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],i="NHWC"===e?r.shape[3]:r.shape[1];return C(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),C(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),C(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${r.shape}`),C(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`),B.runKernel(QE,{x:r},{blockSize:t,dataFormat:e})}});re().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),ZTe(this,n,t)},re().prototype.depthwiseConv2d=function(n,t,e,r,s,o){return this.throwIfDisposed(),Pv(this,n,t,e,r,s,o)};const JTe=U({dilation2d_:function QTe(n,t,e,r,s=[1,1],o="NHWC"){const i=k(n,"x","dilation2d"),a=k(t,"filter","dilation2d");C(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),C(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),C("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=H(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),C(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h=B.runKernel($_,{x:l,filter:a},{strides:e,pad:r,dilations:s});return u?H(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});re().prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),JTe(this,n,t,e,r,s)};const t1e=U({divNoNan_:function e1e(n,t){let e=k(n,"a","div"),r=k(t,"b","div");[e,r]=Ln(e,r);const s=ze(e,r),o=$t(s),i=Ki(r,o);return Ms(i,o,s)}});re().prototype.divNoNan=function(n){return this.throwIfDisposed(),t1e(this,n)},re().prototype.div=function(n){return this.throwIfDisposed(),ze(this,n)};const r1e=U({dot_:function n1e(n,t){const e=k(n,"t1","dot"),r=k(t,"t2","dot");C(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(C(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const i=H(e,[1,-1]),a=H(r,[-1,1]),l=Ut(i,a);return H(l,[])}if(1===e.rank&&2===r.rank){const i=H(e,[1,-1]),a=H(r,[r.shape[0],r.shape[1]]),l=Ut(i,a);return H(l,[l.size])}if(2===e.rank&&1===r.rank){const i=H(r,[-1,1]),a=Ut(e,i);return H(a,[a.size])}{const i=H(r,[r.shape[0],r.shape[1]]);return Ut(e,i)}}});re().prototype.dot=function(n){return this.throwIfDisposed(),r1e(this,n)},re().prototype.elu=function(){return this.throwIfDisposed(),Lv(this)},re().prototype.equal=function(n){return this.throwIfDisposed(),Ki(this,n)};const o1e=U({erf_:function s1e(n){let t=k(n,"x","erf");return C("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Se(t,"float32")),B.runKernel(jf,{x:t})}});re().prototype.erf=function(){return this.throwIfDisposed(),o1e(this)};const a1e=U({euclideanNorm_:function i1e(n,t=null,e=!1){return Yv(n,"euclidean",t,e)}});re().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),a1e(this,n,t)},re().prototype.exp=function(){return this.throwIfDisposed(),Mo(this)},re().prototype.expandDims=function(n){return this.throwIfDisposed(),xs(this,n)};const u1e=U({expm1_:function l1e(n){const e={x:k(n,"x","expm1")};return B.runKernel(Kf,e)}});re().prototype.expm1=function(){return this.throwIfDisposed(),u1e(this)},re().prototype.fft=function(){return this.throwIfDisposed(),Pk(this)},re().prototype.flatten=function(){return this.throwIfDisposed(),H(this,[this.size])},re().prototype.floor=function(){return this.throwIfDisposed(),Vv(this)},re().prototype.floorDiv=function(n){return this.throwIfDisposed(),aG(this,n)},re().prototype.gather=function(n,t){return this.throwIfDisposed(),xk(this,n,t)},re().prototype.greaterEqual=function(n){return this.throwIfDisposed(),sc(this,n)},re().prototype.greater=function(n){return this.throwIfDisposed(),so(this,n)},re().prototype.ifft=function(){return this.throwIfDisposed(),Hv(this)},re().prototype.irfft=function(){return this.throwIfDisposed(),HG(this)};const d1e=U({isFinite_:function c1e(n){const e={x:k(n,"x","isFinite")};return B.runKernel(Jf,e)}});re().prototype.isFinite=function(){return this.throwIfDisposed(),d1e(this)};const p1e=U({isInf_:function h1e(n){const e={x:k(n,"x","isInf")};return B.runKernel(em,e)}});re().prototype.isInf=function(){return this.throwIfDisposed(),p1e(this)};const m1e=U({isNaN_:function f1e(n){const e={x:k(n,"x","isNaN")};return B.runKernel(tm,e)}});re().prototype.isNaN=function(){return this.throwIfDisposed(),m1e(this)},re().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Sk(this,n)},re().prototype.lessEqual=function(n){return this.throwIfDisposed(),ah(this,n)},re().prototype.less=function(n){return this.throwIfDisposed(),jH(this,n)};const y1e=U({localResponseNormalization_:function g1e(n,t=5,e=1,r=1,s=.5){const o=k(n,"x","localResponseNormalization");C(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),C(Wd(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=H(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=B.runKernel(H_,{x:i},{depthRadius:t,bias:e,alpha:r,beta:s});return a?H(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});re().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),y1e(this,n,t,e,r)};const _1e=U({logSigmoid_:function b1e(n){const t=k(n,"x","logSigmoid");return Na(r=>({value:An(zm(An(r))),gradFunc:i=>L(i,sh(An(r)))}))(t)}});re().prototype.logSigmoid=function(){return this.throwIfDisposed(),_1e(this)},re().prototype.logSoftmax=function(n){return this.throwIfDisposed(),LG(this,n)},re().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),iH(this,n,t)},re().prototype.log=function(){return this.throwIfDisposed(),Po(this)},re().prototype.log1p=function(){return this.throwIfDisposed(),Tk(this)},re().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ra(this,n)},re().prototype.logicalNot=function(){return this.throwIfDisposed(),yN(this)};const ZH=U({logicalOr_:function v1e(n,t){const e=k(n,"a","logicalOr","bool"),r=k(t,"b","logicalOr","bool");return tt(e.shape,r.shape),B.runKernel(G_,{a:e,b:r})}});re().prototype.logicalOr=function(n){return this.throwIfDisposed(),ZH(this,n)};const x1e=U({logicalXor_:function w1e(n,t){const e=k(n,"a","logicalXor","bool"),r=k(t,"b","logicalXor","bool");return tt(e.shape,r.shape),Ra(ZH(n,t),yN(Ra(n,t)))}});re().prototype.logicalXor=function(n){return this.throwIfDisposed(),x1e(this,n)},re().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Ut(this,n,t,e)},re().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),Ck(this,n,t,e,r)},re().prototype.max=function(n,t){return this.throwIfDisposed(),fi(this,n,t)},re().prototype.maximum=function(n){return this.throwIfDisposed(),Fl(this,n)},re().prototype.mean=function(n,t){return this.throwIfDisposed(),Gn(this,n,t)},re().prototype.min=function(n,t){return this.throwIfDisposed(),Bv(this,n,t)},re().prototype.minimum=function(n){return this.throwIfDisposed(),zv(this,n)};const T1e=U({mirrorPad_:function S1e(n,t,e){C("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=k(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");C(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)C(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),C(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return B.runKernel(Z_,{x:r},{paddings:t,mode:e})}});re().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),T1e(this,n,t)};const E1e=U({mod_:function C1e(n,t){let e=k(n,"a","mod"),r=k(t,"b","mod");return[e,r]=Ln(e,r),B.runKernel(im,{a:e,b:r})}});re().prototype.mod=function(n){return this.throwIfDisposed(),E1e(this,n)},re().prototype.mul=function(n){return this.throwIfDisposed(),L(this,n)},re().prototype.neg=function(){return this.throwIfDisposed(),An(this)},re().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Yv(this,n,t,e)},re().prototype.notEqual=function(n){return this.throwIfDisposed(),Vm(this,n)},re().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),BG(this,n,t,e)},re().prototype.onesLike=function(){return this.throwIfDisposed(),Lo(this)},re().prototype.pad=function(n,t){return this.throwIfDisposed(),kk(this,n,t)};const D1e=U({pool_:function I1e(n,t,e,r,s,o,i){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const a=k(n,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(Rr(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const c=Fo(l.shape,t,o,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function N1e(n,t){const r=n.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function k1e(n,t,e){const r=e.map(c=>c[0]),s=e.map(c=>c[1]),o=n.concat(r,s),i=t.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],a[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:mN(l,d,f),_=("avg"===e?()=>vk(y,t,o,g,i):()=>Ck(y,t,o,g,i))(),v=p?_:_N(_,d,m);return u?H(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});re().prototype.pool=function(n,t,e,r,s,o){return this.throwIfDisposed(),D1e(this,n,t,e,r,s,o)},re().prototype.pow=function(n){return this.throwIfDisposed(),th(this,n)},re().prototype.prelu=function(n){return this.throwIfDisposed(),Nk(this,n)};const R1e=U({prod_:function A1e(n,t=null,e=!1){let r=k(n,"x","prod");return"bool"===r.dtype&&(r=Se(r,"int32")),B.runKernel(ov,{x:r},{axis:t,keepDims:e})}});re().prototype.prod=function(n,t){return this.throwIfDisposed(),R1e(this,n,t)};const O1e=U({reciprocal_:function $1e(n){const e={x:k(n,"x","reciprocal")};return B.runKernel(um,e)}});re().prototype.reciprocal=function(){return this.throwIfDisposed(),O1e(this)},re().prototype.relu=function(){return this.throwIfDisposed(),$a(this)},re().prototype.relu6=function(){return this.throwIfDisposed(),jG(this)},re().prototype.reshapeAs=function(n){return this.throwIfDisposed(),H(this,n.shape)},re().prototype.reshape=function(n){return this.throwIfDisposed(),H(this,n)},re().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),eH(this,n,t,e)},re().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),tH(this,n,t,e)},re().prototype.reverse=function(n){return this.throwIfDisposed(),oc(this,n)},re().prototype.rfft=function(){return this.throwIfDisposed(),Lk(this)},re().prototype.round=function(){return this.throwIfDisposed(),nH(this)},re().prototype.rsqrt=function(){return this.throwIfDisposed(),BH(this)},re().prototype.selu=function(){return this.throwIfDisposed(),zG(this)},re().prototype.separableConv2d=function(n,t,e,r,s,o){return this.throwIfDisposed(),UG(this,n,t,e,r,s,o)},re().prototype.sigmoid=function(){return this.throwIfDisposed(),sh(this)};const M1e=U({sign_:function F1e(n){const e={x:k(n,"x","sign")};return B.runKernel(ym,e)}});re().prototype.sign=function(){return this.throwIfDisposed(),M1e(this)},re().prototype.sin=function(){return this.throwIfDisposed(),PH(this)},re().prototype.sinh=function(){return this.throwIfDisposed(),LH(this)},re().prototype.slice=function(n,t){return this.throwIfDisposed(),Yt(this,n,t)},re().prototype.softmax=function(n){return this.throwIfDisposed(),Ok(this,n)},re().prototype.softplus=function(){return this.throwIfDisposed(),zm(this)},re().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),mN(this,n,t)},re().prototype.split=function(n,t){return this.throwIfDisposed(),oo(this,n,t)},re().prototype.sqrt=function(){return this.throwIfDisposed(),os(this)},re().prototype.square=function(){return this.throwIfDisposed(),ln(this)},re().prototype.squaredDifference=function(n){return this.throwIfDisposed(),oH(this,n)},re().prototype.squeeze=function(n){return this.throwIfDisposed(),Um(this,n)},re().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof yn?[this,n]:[this,...n];return Oa(e,t)},re().prototype.step=function(n){return this.throwIfDisposed(),Wm(this,n)};const L1e=U({stridedSlice_:function P1e(n,t,e,r,s=0,o=0,i=0,a=0,l=0){const c={x:k(n,"x","stridedSlice","string_or_numeric")};return B.runKernel(TI,c,{begin:t,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}});re().prototype.stridedSlice=function(n,t,e,r,s,o,i,a){return this.throwIfDisposed(),L1e(this,n,t,e,r,s,o,i,a)},re().prototype.sub=function(n){return this.throwIfDisposed(),Fe(this,n)},re().prototype.sum=function(n,t){return this.throwIfDisposed(),Me(this,n,t)};const B1e=U({tan_:function V1e(n){const e={x:k(n,"x","tan","float32")};return B.runKernel(Sm,e)}});re().prototype.tan=function(){return this.throwIfDisposed(),B1e(this)},re().prototype.tanh=function(){return this.throwIfDisposed(),Fk(this)},re().prototype.tile=function(n){return this.throwIfDisposed(),pi(this,n)},re().prototype.toBool=function(){return this.throwIfDisposed(),Se(this,"bool")},re().prototype.toFloat=function(){return this.throwIfDisposed(),Se(this,"float32")},re().prototype.toInt=function(){return this.throwIfDisposed(),Se(this,"int32")};const U1e=U({topk_:function z1e(n,t=1,e=!0){const r=k(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const o={x:r},i={k:t,sorted:e},[a,l]=B.runKernel(kI,o,i);return{values:a,indices:l}}});re().prototype.topk=function(n,t){return this.throwIfDisposed(),U1e(this,n,t)},re().prototype.transpose=function(n){return this.throwIfDisposed(),At(this,n)};const G1e=U({unique_:function W1e(n,t=0){const e=k(n,"x","unique","string_or_numeric");C(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[o,i]=B.runKernel(DI,r,s);return{values:o,indices:i}}});re().prototype.unique=function(n){return this.throwIfDisposed(),G1e(this,n)},re().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),zH(this,n,t)},re().prototype.unstack=function(n){return this.throwIfDisposed(),ic(this,n)},re().prototype.where=function(n,t){return this.throwIfDisposed(),Ms(n,this,t)},re().prototype.zerosLike=function(){return this.throwIfDisposed(),$t(this)};class Yi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Yi.prototype)}}class Bo extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Bo.prototype)}}class z extends Error{constructor(t){super(t),Object.setPrototypeOf(this,z.prototype)}}class nt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,nt.prototype)}}class vN extends Error{constructor(t){super(t),Object.setPrototypeOf(this,vN.prototype)}}Error;class JH{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function lc(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function ao(n,t){if(!n)throw new vN(t)}function ej(n,t){let e=0;for(const r of n)r===t&&e++;return e}function Ts(n){return 1===n.length?n[0]:n}function un(n){return Array.isArray(n)?n:[n]}function Pa(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function uc(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let zo={};function wN(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function xN(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>xN(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?xN(r):n[e]=r.value)}}}function Km(n,t={},e={},r="object",s=!1){if("string"==typeof n){const o=n;let i;if(o in e)i=e[o];else if(o in zo)i=zo[o];else if(i=t[o],null==i)throw new z(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const o=n;if(null==o.className||null==o.config)throw new z(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const i=o.className;let a,l;if(i in e?[a,l]=e[i]:i in zo?[a,l]=zo.className:i in t&&([a,l]=t[i]),null==a)throw new z(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const p of Object.keys(zo))u[p]=zo[p];for(const p of Object.keys(e))u[p]=e[p];o.config.customObjects=u;const d=Object.assign({},zo);for(const p of Object.keys(e))zo[p]=e[p];xN(o.config);const h=l(a,o.config,e,s);return zo=Object.assign({},d),h}{const u=Object.assign({},zo);for(const d of Object.keys(e))zo[d]=e[d];const c=new a(o.config);return zo=Object.assign({},u),c}}}function ew(n,t){return-1*function H1e(n,t){return n<t?-1:n>t?1:0}(n,t)}function zl(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function j1e(n){if(null==n)throw new z(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function cc(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new z(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function SN(n,t,e=0,r=1/0){return ao(e>=0),ao(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function Cr(n,t){Array.isArray(n)?(C(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>Cr(e,`element ${r+1} of ${t}`))):C(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${tj(n)}.`)}function tj(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>tj(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function nj(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let K1e=0;function rj(){return K1e++}const tw={};function nw(n=""){return n in tw||(tw[n]=0),tw[n]+=1,n+tw[n].toString()}const X1e=["channelsFirst","channelsLast"],Y1e=["nearest","bilinear"],Z1e=["valid","same","causal"],Q1e=["max","avg"],J1e=["sum","mul","concat","ave"],uh=new Map;function qn(n){cc(X1e,"DataFormat",n)}function lo(n){cc(Z1e,"PaddingMode",n)}function sj(n){cc(Q1e,"PoolMode",n)}const Xm=[];function dc(n,t){Xm.push(n);try{const e=t();return Xm.pop(),e}catch(e){throw Xm.pop(),e}}function ij(n){if(!lj(n))throw new Error("Not a valid tensor name: '"+n+"'");return function tCe(){return 0===Xm.length?"":Xm.join("/")+"/"}()+n}function aj(n){if(!lj(n))throw new Error("Not a valid tensor name: '"+n+"'");uh.has(n)||uh.set(n,0);const t=uh.get(n);if(uh.set(n,uh.get(n)+1),t>0){const e=`${n}_${t}`;return uh.set(e,1),e}return n}const nCe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function lj(n){return!!n.match(nCe)}function rCe(n){return n===parseInt(n.toString(),10)}function Ul(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function ch(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function Wl(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function mi(n,t){if(t<n)throw new z(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let rw;function dr(){return null==rw&&(rw=function Lbe(){return B.backend}().epsilon()),rw}function Zi(n,t){return Se(n,t)}function Ym(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),H(n,e)}function hc(n,t,e){return te(()=>{switch(n.rank){case 1:return Rk(n,t,e);case 2:return WG(n,[t,0],[e,n.shape[1]]);case 3:return $k(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Wv(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Yt(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Yt(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function TN(n,t,e){return te(()=>{switch(n.rank){case 1:return Rk(n,t,e);case 2:return WG(n,[0,t],[n.shape[0],e]);case 3:return $k(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Wv(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function sw(n,t,e,r){return te(()=>{switch(n.rank){case 1:return Rk(n,t,e);case 2:switch(r){case 1:return hc(n,t,e);case 2:return TN(n,t,e);default:throw new z(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return hc(n,t,e);case 2:return $k(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return TN(n,t,e);default:throw new z(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return hc(n,t,e);case 2:return Wv(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Wv(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return TN(n,t,e);default:throw new z(`The axis is not within the rank of the tensor ${r}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function CN(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),qr(n,t)}function cj(n,t){switch(n.rank){case 1:return H_e([n,t]);case 2:return q_e([n,t],0);case 3:return X_e([n,t],0);case 4:return Z_e([n,t],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function EN(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new z(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return pi(n,t)}function ow(n,t=0,e=1,r,s){return Hve(n,t,e,r,s)}function Qi(n,t,e,r){if(n.rank<2||t.rank<2)throw new nt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new nt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return XG({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?IN(n.rank,r,"channelsLast"):null,activation:e});{const s=n.shape.slice(),o=s.pop();n=H(n,[-1,o]);const i=t.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:t.rank},(f,m)=>0===m?t.rank-2:m<=t.rank-2?m-1:m);t=H(At(t,c),[l,-1]);const d=[...s,...u];return H(XG({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?IN(n.rank,r,"channelsLast"):null,activation:e}),d)}}function dj(n,t,e){return te(()=>(t=Array.isArray(t)?Ss(t,"int32"):Se(t,"int32"),xk(n,t,e)))}function Zm(n){return L(n,n)}function IN(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new z(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return H(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return H(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return H(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return H(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return H(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return H(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new z(`Unsupported input rank by biasAdd: ${t.rank}`)}function yi(n,t,e){return te(()=>(null==e&&(e="channelsLast"),qn(e),fe(n,IN(n.rank,t,e))))}function hj(n,t,e,r){return te(()=>bwe(n,t,e,r))}function Qm(n,t,e=!1){return e?n():t()}const hCe=["fanIn","fanOut","fanAvg"],pCe=["normal","uniform","truncatedNormal"];class Uo extends eh{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}de((()=>{class n extends Uo{apply(e,r){return Tr(e,r)}}return n.className="Zeros",n})());let pj=(()=>{class n extends Uo{apply(e,r){return Vl(e,r)}}return n.className="Ones",n})();de(pj),de((()=>{class n extends Uo{constructor(e){if(super(),"object"!=typeof e)throw new z(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new z(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return te(()=>L(Je(this.value),Vl(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),de((()=>{class n extends Uo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Uv(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),de((()=>{class n extends Uo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new nt(`randomNormal does not support dType ${r}.`);return ow(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),de((()=>{class n extends Uo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new nt(`truncatedNormal does not support dType ${r}.`);return GG(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),de((()=>{class n extends Uo{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return te(()=>{if(2!==e.length||e[0]!==e[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return L(this.gain,PG(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let uo=(()=>{class n extends Uo{constructor(e){if(super(),e.scale<0)throw new z(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function fCe(n){cc(hCe,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function mCe(n){cc(pCe,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function gCe(n,t="channelsLast"){let e,r;if(qn(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const s=Ul(n,2);e=n[1]*s,r=n[0]*s}else if("channelsLast"===t){const s=Ul(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=Ul(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),o=s[0],i=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(o+i)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new nt(`${this.getClassName()} does not support dType ${r}.`);return GG(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return Uv(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();de(uo);let fj=(()=>{class n extends uo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return uo.className}}return n.className="GlorotUniform",n})();de(fj);let mj=(()=>{class n extends uo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return uo.className}}return n.className="GlorotNormal",n})();de(mj);let gj=(()=>{class n extends uo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return uo.className}}return n.className="HeNormal",n})();de(gj);let yj=(()=>{class n extends uo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return uo.className}}return n.className="HeUniform",n})();de(yj);let bj=(()=>{class n extends uo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return uo.className}}return n.className="LeCunNormal",n})();de(bj);let _j=(()=>{class n extends uo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return uo.className}}return n.className="LeCunUniform",n})();de(_j),de((()=>{class n extends Uo{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new nt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,r){return te(()=>{if(e.length<2)throw new nt("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const o=ow(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let i=cxe.gramSchmidt(o);return e[0]>e[1]&&(i=At(i)),L(this.gain,i)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const vj={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function wj(n,t={}){return Km(n,Oo.getMap().classNameMap,t,"initializer")}function Rn(n){return wN(n)}function vn(n){if("string"==typeof n){const t=n in vj?vj[n]:n;if("GlorotNormal"===t)return new mj;if("GlorotUniform"===t)return new fj;if("HeNormal"===t)return new gj;if("HeUniform"===t)return new yj;if("LeCunNormal"===t)return new bj;if("LeCunUniform"===t)return new _j;{const e={};return e.className=t,e.config={},wj(e)}}return n instanceof Uo?n:wj(n)}function kN(n){return Array.isArray(n)&&Array.isArray(n[0])}function iw(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function Ze(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new z(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Vt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new z(`Expected exactly 1 Shape; got ${n.length}`)}return n}function aw(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return t}const xj="Variable";class Ji{constructor(t,e="float32",r=xj,s=!0,o=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=rj(),this.originalName=ij(r=null==r?xj:r),this.name=aj(this.originalName),this.trainable_=s,this.constraint=o,this.val=function dwe(n,t=!0,e,r){return B.makeVariable(n,t,e,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function yCe(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function NN(n){return n.map(t=>t.read())}function DN(n){n.forEach(t=>{t[0].write(t[1])})}class hr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class ea{constructor(t,e,r,s,o,i,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=a,this.id=rj(),null!=i&&(this.originalName=ij(i),this.name=aj(this.originalName)),this.rank=e.length}}let bCe=0;class lw{constructor(t,e){this.callArgs=e,this.id=bCe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)null!=r&&r.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let _Ce=0;class vt extends eh{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=_Ce++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=Pa(r)+"_"+nw(r)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let o=null;null!=t.batchSize&&(o=t.batchSize),r=[o].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Bo(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new z(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Ts(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Ts(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Yi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Yi(`Layer ${this.name} is not connected, no input to return.`);return Ts(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Yi(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Yi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ts(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=un(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=un(this.inputSpec);if(t.length!==e.length)throw new z(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const s=t[r],o=e[r];if(null==o)continue;const i=s.rank;if(null!=o.ndim&&i!==o.ndim)throw new z(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${i}`);if(null!=o.maxNDim&&i>o.maxNDim)throw new z(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${i}`);if(null!=o.minNDim&&i<o.minNDim)throw new z(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${i}.`);if(null!=o.dtype&&s.dtype!==o.dtype)throw new z(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const a=s.shape;for(const l in o.axes){const u=Number(l),c=o.axes[l],d=u>=0?a[u]:a[a.length+u];if(null!=c&&-1===[c,null].indexOf(d))throw new z(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(null!=o.shape)for(let a=0;a<o.shape.length;++a){const l=o.shape[a],u=s.shape[a];if(null!=l&&null!=u&&l!==u)throw new z(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=un(t);let s=!0;for(const i of r)if(!(i instanceof ea)){s=!1;break}let o=!0;for(const i of r)if(i instanceof ea){o=!1;break}if(s===o)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return dc(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const a of un(t))i.push(a.shape);this.build(Ts(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let i=this.call(t,e);const a=un(i),l=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),l.push(u);if(i=Ts(l),null!=this.activityRegularizer)throw new nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function vCe(n){n=un(n);const t=[];for(const e of n)t.push(e.shape);return Ts(t)}(t),a=this.computeOutputShape(i);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new ea(u,c,this,un(t),e,this.name,d)):new ea(u,a,this,un(t),e,this.name),this.addInboundNode(t,l,null,null,i,a,e),this._refCount++,null!=this.activityRegularizer)throw new nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=t[s]&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Yi(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Yi(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Bo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return aw(this.weights)}build(t){this.built=!0}getWeights(t=!1){return NN(t?this.trainableWeights:this.weights)}setWeights(t){te(()=>{const e=this.weights;if(e.length!==t.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],s=NN(e);for(let o=0;o<s.length;++o){const i=s[o],a=e[o],l=t[o];if(!zt(i.shape,l.shape))throw new z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}DN(r)})}addWeight(t,e,r,s,o,i,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new z(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():vn("zeros"));const u=s.apply(e,r),c=new Ji(u,r,t,i,a);return u.dispose(),null!=o&&this.addLoss(()=>o.apply(c.read())),null==i&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=un(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,s,o,i,a=null){const l=un(t);e=un(e),r=un(r),s=un(s),o=iw(o),i=iw(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new lw({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function Sj(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const u=Sj(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const c of u)-1===s.indexOf(c)&&s.push(c)}return s}}}let uw=(()=>{class n extends vt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:nw("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const o=new ea(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new lw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();de(uw);class Gl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Gl)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new z(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function SCe(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return Se(t,n.dtype)}catch(e){throw new z(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ea){if(null==this.id2Value[t.id])throw new z(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof ea){if(null==this.id2Value[t.id])throw new z(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&mt(this.id2Mask)}}const cw=new JH,dw=new JH;function Jm(n,t,e,r){const s=null!=e&&e.training,o=Array.isArray(n),i=o?n:[n],a=i.map(f=>f.name),l=[],u=t.names();for(const f of a)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=a.join(",")+"|"+t.names().sort().join(",");let h,d=cw.get(c);if(null==d){const f=function CCe(n,t){C(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const s=Tj(n[0],t);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const o of n){const{sorted:i,recipientMap:a}=Tj(o,t);for(const l of i)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:ECe(r)}}(i,t);d=f.sorted,h=f.recipientCounts,cw.put(c,d),dw.put(c,h)}h={},s||Object.assign(h,dw.get(c));const p=new Gl(t);for(let f=0;f<d.length;++f){if(null!=r){const N=rk().numTensors;N>r.maxNumTensors&&(r.maxNumTensors=N),N<r.minNumTensors&&(r.minNumTensors=N)}const m=d[f],g=m.sourceLayer;if(g instanceof uw)continue;const y=[],b=[],_=[];let v=!1;for(const N of m.inputs){const R=p.getValue(N),F=p.getMask(N);y.push(R),b.push(F),null!=F&&(v=!0),s||(h[N.name]--,0===h[N.name]&&!t.hasKey(N)&&-1===a.indexOf(N.name)&&!R.isDisposed&&!0!==N.sourceLayer.stateful&&_.push(R))}v&&((e=e||{}).mask=b[0]);const w=un(g.apply(y,e));let S=null;g.supportsMasking&&(S=g.computeMask(y,b));const T=ICe(m),I=Array.isArray(T)?T:[T];for(let N=0;N<I.length;++N){p.hasKey(I[N])||p.add(I[N],w[N],Array.isArray(S)?S[0]:S);const R=a.indexOf(I[N].name);-1!==R&&(l[R]=w[N])}s||mt(_)}return p.disposeMasks(),o?l:l[0]}function ECe(n){const t={};for(const e in n)t[e]=n[e].size;return t}function Tj(n,t){const e=new Set,r=[],s={};for(const a of t.names())e.add(a);const o=[],i=[];for(o.push(n);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(0===a.inputs.length||l)o.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)null==s[u.name]&&(s[u.name]=new Set),s[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function ICe(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function AN(n,t){return te(()=>os(Me(L(n,n),t,!0)))}ee().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function TCe(n){null!=cw&&cw.setMaxEntries(n),null!=dw&&dw.setMaxEntries(n)});class eg extends eh{getConfig(){return{}}}de((()=>{class n extends eg{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return te(()=>{const r=AN(e,this.axis),s=ro(r,0,this.maxValue);return L(e,ze(s,fe(dr(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),de((()=>{class n extends eg{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return te(()=>ze(e,fe(dr(),AN(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),de((()=>{class n extends eg{apply(e){return $a(e)}}return n.className="NonNeg",n})()),de((()=>{class n extends eg{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return te(()=>{const r=AN(e,this.axis),s=fe(L(this.rate,ro(r,this.minValue,this.maxValue)),L(1-this.rate,r));return L(e,ze(s,fe(dr(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const Cj={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function pr(n){return wN(n)}function Ej(n,t={}){return Km(n,Oo.getMap().classNameMap,t,"constraint")}function fr(n){return null==n?null:"string"==typeof n?Ej({className:n in Cj?Cj[n]:n,config:{}}):n instanceof eg?n:Ej(n)}function Hl(n){return RN.apply(this,arguments)}function RN(){return(RN=$(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const s in n){const o=n[s];if("number"!=typeof o){const i=o;t.push(i.data()),e.push(s),r.push(i)}}if(t.length>0){const s=yield Promise.all(t);for(let o=0;o<s.length;++o)n[e[o]]=s[o][0];mt(r)}})).apply(this,arguments)}function Ij(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class dh{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return $(function*(){})()}onEpochEnd(t,e){return $(function*(){})()}onBatchBegin(t,e){return $(function*(){})()}onBatchEnd(t,e){return $(function*(){})()}onTrainBegin(t){return $(function*(){})()}onTrainEnd(t){return $(function*(){})()}setModel(t){}}class NCe{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return $(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return $(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return $(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return $(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return $(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return $(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class DCe extends dh{constructor(){super()}onEpochBegin(t){var e=this;return $(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return $(function*(){null==e&&(e={});const s=null==e.size?0:e.size;r.seen+=s;for(const o in e){const i=e[o];if("number"==typeof i)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+i*s;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const l=te(()=>fe(r.totals[o],L(i,s)));r.totals[o]=l,null!=a&&a.dispose()}}})()}onEpochEnd(t,e){var r=this;return $(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:te(()=>{const o=L(ze(1,r.seen),r.totals[s]);e[s]=o,r.totals[s].dispose(),qi(e[s])}))})()}}class ACe extends dh{onTrainBegin(t){var e=this;return $(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return $(function*(){null==e&&(e={}),r.epoch.push(t);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var t=this;return $(function*(){const e=[],r=[],s=[];for(const i in t.history){const a=t.history[i];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(i),s.push(l))}const o=yield Promise.all(e);for(let i=0;i<o.length;++i)t.history[r[i]][s[i]].dispose(),t.history[r[i]][s[i]]=o[i][0]})()}}class RCe extends dh{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||aH,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");$E(this.yieldEvery)&&(this.maybeWait=function q1e(n,t,e){let s,r=null!=e?e():Hr();return(...i)=>{const a=null!=e?e():Hr();return a-r<t||(r=a,s=n(...i)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var s=this;return $(function*(){const o=[];null!=s.yield&&(yield Hl(r),o.push(s.yield(t,e,r))),o.push(s.nextFrameFunc()),yield Promise.all(o)})()}onEpochBegin(t,e){var r=this;return $(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield Hl(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return $(function*(){const s=[];null!=r.epochEnd&&(yield Hl(e),s.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(t,e){var r=this;return $(function*(){null!=r.batchBegin&&(yield Hl(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return $(function*(){const s=[];null!=r.batchEnd&&(yield Hl(e),s.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):$E(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return $(function*(){null!=e.trainBegin&&(yield Hl(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return $(function*(){null!=e.trainEnd&&(yield Hl(t),yield e.trainEnd(t))})()}}function kj(n,t){return null==n&&(n={}),n instanceof dh?[n]:Array.isArray(n)&&n[0]instanceof dh?n:un(n).map(r=>new RCe(r,t))}let $Ce=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){C(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(o=>{if(o===e)throw new z("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const s in n.constructors){const o=+s;e>=o&&r.push(...n.constructors[o])}return r.map(s=>new s)}}return n.constructors={},n})();function Nj(n,t,e,r,s,o,i,a,l){const u=new ACe,c=[new DCe,...$Ce.createCallbacks(t)];null!=n&&c.push(...n),c.push(u);const d=new NCe(c);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:o,batchSize:i,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:u}}function La(n,t={},e=!1){return Km(n,Oo.getMap().classNameMap,t,"layer",e)}function hw(n,t){return te(()=>{"float32"!==n.dtype&&(n=Se(n,"float32"));const e=Me(Zm(n),t,!0),r=$m(e.shape,dr()),s=os(Fl(e,r));return ze(n,s)})}function pw(n,t){return te(()=>Gn(Zm(Fe(t,n)),-1))}function $N(n,t){return te(()=>Gn(wr(Fe(t,n)),-1))}function ON(n,t){return te(()=>{const e=Fe(n,t),r=ro(wr(n),dr(),Number.MAX_VALUE),s=wr(ze(e,r));return L(100,Gn(s,-1))})}function tg(n,t,e=!1){return te(()=>{if(e)t=Ok(t);else{const r=Me(t,t.shape.length-1,!0);t=ze(t,r)}return t=ro(t,dr(),1-dr()),An(Me(L(Se(n,"float32"),Po(t)),t.shape.length-1))})}function fw(n,t,e=!1){return te(()=>{const r=Se(Vv(function aCe(n){const t=[Ul(n.shape)];return H(n,t)}(n)),"int32"),s=(t=ro(t,dr(),1-dr())).shape;return tg(H(BG(r,s[s.length-1]),s),t,e)})}function mw(n,t){return te(()=>{let e;return e=ro(t,dr(),1-dr()),e=Po(ze(e,Fe(1,e))),Gn(function VCe(n,t){if(!zt(n.shape,t.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return te(()=>{const e=$a(t),r=An(wr(t));return fe(Fe(e,L(t,n)),Tk(Mo(r)))})}(n,e),-1)})}function Dj(n,t){return te(()=>{const e=hw(n,-1),r=hw(t,-1),s=L(e,r);return An(Me(s,-1))})}const gw={meanSquaredError:pw,meanAbsoluteError:$N,meanAbsolutePercentageError:ON,meanSquaredLogarithmicError:function OCe(n,t){return te(()=>{const e=ro(t,dr(),Number.MAX_VALUE),r=Po(fe(1,e)),s=ro(n,dr(),Number.MAX_VALUE),o=Po(fe(1,s));return Gn(Zm(Fe(r,o)),-1)})},squaredHinge:function FCe(n,t){return te(()=>{const e=Fl(0,Fe(1,L(n,t)));return Gn(Zm(e),-1)})},hinge:function MCe(n,t){return te(()=>{const e=Fl(0,Fe(1,L(n,t)));return Gn(e,-1)})},categoricalHinge:function PCe(n,t){return te(()=>{const e=Me(L(n,t),-1),r=fi(L(Fe(1,n),t),-1);return Fl(0,fe(1,Fe(r,e)))})},logcosh:function LCe(n,t){return te(()=>{const e=Math.log(2),r=Fe(t,n),s=Fe(fe(r,zm(L(-2,r))),e);return Gn(s,-1)})},categoricalCrossentropy:tg,sparseCategoricalCrossentropy:fw,binaryCrossentropy:mw,kullbackLeiblerDivergence:function BCe(n,t){return te(()=>{const e=ro(n,dr(),1),r=ro(t,dr(),1);return Me(L(n,Po(ze(e,r))),-1)})},poisson:function zCe(n,t){return te(()=>{const e=Po(fe(dr(),t));return Gn(Fe(t,L(n,e)),-1)})},cosineProximity:Dj};function FN(n){if("string"==typeof n){if(n in gw)return gw[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(t)}return n}function Aj(n,t){return te(()=>{const e=L(.5,Lo(t)),r=Zi(so(t,e),n.dtype);return Gn(Ki(n,r),-1)})}function Rj(n,t){return te(()=>Zi(Ki(Om(n,-1),Om(t,-1)),"float32"))}function HCe(n,t){return mw(n,t)}function jCe(n,t){return n.rank===t.rank&&(n=Um(n,[n.rank-1])),(t=Om(t,-1)).dtype!==n.dtype&&(t=Se(t,n.dtype)),Se(Ki(n,t),"float32")}const Oj=tg,Fj=fw,yw={binaryAccuracy:Aj,categoricalAccuracy:Rj,precision:function GCe(n,t){return te(()=>{const e=function $j(n,t){return te(()=>Se(Me(Ra(Ki(n,1),Ki(t,1))),"float32"))}(n,t),r=function WCe(n,t){return te(()=>Se(Me(Ra(Ki(n,0),Ki(t,1))),"float32"))}(n,t),s=fe(e,r);return Se(Ms(so(s,0),ze(e,s),0),"float32")})},categoricalCrossentropy:Oj,sparseCategoricalCrossentropy:Fj,mse:pw,MSE:pw,mae:$N,MAE:$N,mape:ON,MAPE:ON,cosine:Dj};function eEe(n){if("string"==typeof n&&n in yw)return yw[n];if("string"!=typeof n&&null!=n)return n;throw new z(`Unknown metric ${n}`)}function bw(n){if(ao(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(gw))if(gw[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(yw))if(yw[e]===n){t=e;break}return void 0!==t?t:n.name}}function Pj(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!MN(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function MN(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!MN(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!MN(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function _w(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function oEe(n,t,e){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch(l){s="multiple"}try{r=JSON.stringify(n.outputShape)}catch(l){r="multiple"}_w([`${n.name} (${n.getClassName()})`,s,r,n.countParams().toString()],t,e)}function iEe(n,t,e,r){let s,o;try{o=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch(d){o="multiple"}try{s=JSON.stringify(n.outputShape)}catch(d){s="multiple"}const i=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)i.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),u=0===i.length?"":i[0];_w([`${a} (${l})`,o,s,n.countParams().toString(),u],t,r);for(let d=1;d<i.length;++d)_w(["","","","",i[d]],t,r)}function Lj(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function PN(n,t){if(null===n)return null;if("string"==typeof n)return uc(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const o=n[s];Lj(t,s,o)?e.push(o):e.push(PN(o,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const o=uc(r);e[o]=PN(s,o)}}return e}}function LN(n,t){if(null==n)return null;if("string"==typeof n)return Pa(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const o=n[s];Lj(t,s,o)?e.push(o):e.push(LN(o,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];e[Pa(r)]="name"!==r&&"className"!==r||"string"!=typeof s?LN(s,r):s}return e}}class bi extends vt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=nw(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],zl(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);zl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const _=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;ao(0===v,"input layer has >1 nodes"),ao(0===w,"input layer has >1 tensors"),this.inputLayers.push(_),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const _=this.inputLayers[b];if(!(_ instanceof uw))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${_.getClassName()}.`);this.inputNames.push(_.name),this.feedInputShapes.push(_.batchInputShape),this.feedInputNames.push(_.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},r={},s={},o={},i={},a=[],l=(b,_,v,w,S,T)=>{(null==w||null==S||null==T)&&(w=b.sourceLayer,S=b.nodeIndex,T=b.tensorIndex);const I=w.inboundNodes[S];if(-1!==v.indexOf(I))throw new Bo(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(-1!==_.indexOf(I))return;this.containerNodes.add(bi.nodeKey(w,S)),w.id in i||(i[w.id]=Object.keys(i).length),-1===v.indexOf(I)&&v.push(I);const N=I.inboundLayers.length;for(let R=0;R<N;R++)l(I.inputTensors[R],_,v,I.inboundLayers[R],I.nodeIndices[R],I.tensorIndices[R]);for(_.push(I);v.indexOf(I)>=0;)v.splice(v.indexOf(I),1);a.push(I)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const d=a.slice().reverse();for(const b of d){r[b.id]=b,b.id in e||(e[b.id]=0);let _=e[b.id];_=Math.max(_,null==s[b.outboundLayer.id]?0:s[b.outboundLayer.id]),s[b.outboundLayer.id]=_,o[b.outboundLayer.id]=b.outboundLayer,e[b.id]=_;for(let w=0;w<b.inboundLayers.length;w++){const I=b.inboundLayers[w].inboundNodes[b.nodeIndices[w]];e[I.id]=Math.max(_+1,null==e[I.id]?0:e[I.id]),r[I.id]=I}}const h={};for(const b in e){const _=e[b];_ in h||(h[_]=[]),h[_].push(r[b])}const p={};for(const b in s){const _=s[b];_ in p||(p[_]=[]),p[_].push(o[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(ew);this.layers=[];for(const b of f){const _=p[b];_.sort((v,w)=>{const S=i[v.id],T=i[w.id];return S<T?-1:S>T?1:0});for(const v of _)v instanceof bi&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(ew);const m=this.inputs.slice(),g=[];for(const b of f)for(const _ of h[b]){const v=_.outboundLayer;if(null!=v){for(const w of _.inputTensors)if(-1===m.indexOf(w))throw new Bo(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(const w of _.outputTensors)m.push(w);g.push(v.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const _=y.filter(v=>v===b).length;if(1!==_)throw new Bo(`The name "${b}" is used ${_} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new lw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let s=0;for(const i of this.layers)for(const a of i.weights){if(null!=r[a.originalName])throw new z(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const o=[];for(const i in t){let a=i;if(null==r[i]){const l=i.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])o.push([r[a],t[i]]);else if(e)throw new z(`Provided weight data has no target variable: ${i}`);delete r[a]}if(e){const i=[];for(const a in r)i.push(a);if(i.length>0)throw new z(`${i.length} of ${s} weights are not set: ${i}`)}DN(o)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.2.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=LN(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return te(()=>{t=un(t);const r=new Gl;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Jm(this.outputs,r,e)})}computeMask(t,e){return te(()=>{let r;return t=un(t),r=null==e?lc(null,t.length):un(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=iw(t);if(e.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(ew);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(c.id))continue;const d=[];for(let m=0;m<u.inboundLayers.length;m++)d.push(r[`${u.inboundLayers[m].name}_${u.nodeIndices[m]}_${u.tensorIndices[m]}`]);const p=iw(c.computeOutputShape(Ts(d))),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++)r[`${c.name}_${f}_${m}`]=p[m]}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const l=i[a];ao(l in r),o.push(r[l])}return Ts(o)}runInternalGraph(t,e){null==e&&(e=lc(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(ew);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(const m of h)m.id in r&&f.push(r[m.id]);if(f.length===h.length){let g,y,b,_,m={};if(null!=c.callArgs&&(m=c.callArgs),1===f.length){const[v,w]=f[0];null==m.mask&&(m.mask=w),b=un(d.call(v,m)),_=un(d.computeMask(v,w)),g=[v],y=[w]}else g=f.map(v=>v[0]),y=f.map(v=>v[1]),null==m.mask&&(m.mask=y),b=un(d.call(g,m)),_=un(d.computeMask(g,y));if(d.activityRegularizer)throw new nt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v)r[p[v].id]=[b[v],_[v]]}}}const o=[],i=[],a=[];for(const l of this.outputs){ao(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(t){const e={};let r;for(const s of this.layers){r=s instanceof bi?1:0;for(let o=0;o<s.inboundNodes.length;o++){const i=bi.nodeKey(s,o);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new z(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new z("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new z(`No such layer: ${t}`)}calculateLosses(){return te(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=bi.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],p=bi.nodeKey(i,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch(m){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],_=h.tensorIndices[g];let w=e[bi.nodeKey(y,h.nodeIndices[g])];null==w&&(w=0),m.push([y.name,w,_,f])}u.push(m)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=bi.nodeKey(a,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),s.push([a.name,c,this.inputLayersTensorIndices[i]])}t.inputLayers=s;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=bi.nodeKey(a,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),o.push([a.name,c,this.outputLayersTensorIndices[i]])}return t.outputLayers=o,t}static fromConfig(t,e,r={},s=!1){const o={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){const b=[];let _;for(const v of y){const w=v[0],S=v[1],T=v[2];if(_=null==v[3]?{}:v[3],!(w in o))return void a(g,y);const I=o[w];if(I.inboundNodes.length<=S)return void a(g,y);b.push(I.inboundNodes[S].outputTensors[T])}b.length>0&&g.apply(Ts(b),_)}function u(g){const y=g.name,b=La(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(s),o[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}const c=e.name,d=e.layers;for(const g of d)u(g);for(;!j1e(i);)for(const g of d){const y=o[g.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const _ of b)l(y,_)}}const h=[],p=[],f=e.inputLayers;for(const g of f){const y=g[0],b=g[1],_=g[2];ao(y in o),h.push(o[y].inboundNodes[b].outputTensors[_])}const m=e.outputLayers;for(const g of m){const y=g[0],b=g[1],_=g[2];ao(y in o),p.push(o[y].inboundNodes[b].outputTensors[_])}return new t({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){te(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Bj(n,t){return function Vj(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const s=[];return t.forEach(o=>{s.push(o in n?n[o]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function zj(n,t,e,r){return BN.apply(this,arguments)}function BN(){return(BN=$(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=te(()=>{if(1===n.shape.length)return ec(n);if(2===n.shape.length){if(n.shape[1]>1)return Om(n,1);if(1===n.shape[1])return H(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield s.data());mt(s);const i=[];return o.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Ss(i,"float32")}return null})).apply(this,arguments)}function aEe(n,t){return L(n,t)}function Uj(n,t){let e,r;e=t.xs,r=t.ys,C(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const o=Wj("input",n.inputNames,e),i=Wj("output",n.outputNames,r),a=o[0].shape[0];C(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),C(i.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<o.length;l++)C(o[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<i.length;l++)C(i[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:o,ys:i}}function Wj(n,t,e){if(e instanceof yn)return[e];if(Array.isArray(e))return C(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const s of t){if(null==e[s])throw new z(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function uEe(n){if(3===n.length)throw new nt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function zN(){return(zN=$(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(C(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),C(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),C(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),C(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),C(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=null!=e.validationData;let o,i;if(s)if(Gj(e.validationData))C(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=uEe(e.validationData);o=g.xs,i=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const c=kj(e.callbacks,e.yieldEvery),d=null==e.verbose?1:e.verbose,{callbackList:h,history:p}=Nj(c,d,e.epochs,null,null,dEe(t,e),null,s,u);h.setModel(n),n.history=p,yield h.onTrainBegin(),n.stopTraining_=!1;let f=null==e.initialEpoch?0:e.initialEpoch,m=yield t.iterator();for(;f<e.epochs;){const g={};yield h.onEpochBegin(f);let y=0,b=0;for(r||(m=yield t.iterator());!r||y<e.batchesPerEpoch;){const _=yield m.next();if(r&&_.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=_.value){const{xs:v,ys:w}=Uj(n,_.value),S={};S.batch=b,S.size=v[0].shape[0],yield h.onBatchBegin(b,S);const T=[];if(null!=e.classWeight){const R=Bj(e.classWeight,n.outputNames);for(let F=0;F<R.length;++F)T.push(yield zj(w[F],null,R[F]))}const I=v.concat(w).concat(T),N=a(I);mt(I);for(let R=0;R<l.length;++R){const j=N[R];S[l[R]]=j,qi(j)}yield h.onBatchEnd(b,S),Ij(S),b++,y++}if(r?y>=e.batchesPerEpoch:_.done){if(s){let v;v=Gj(e.validationData)?un(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):un(n.evaluate(o,i,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let w=0;w<n.metricsNames.length;++w)g[`val_${n.metricsNames[w]}`]=v[w]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(f,g),f++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function dEe(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function Gj(n){return"function"==typeof n.iterator}function hEe(n){return"function"==typeof n.next}function UN(){return(UN=$(function*(n,t,e){const r=null!=(e=e||{}).batches,s=n.testFunction;let o=[];if(e.verbose>0)throw new nt("Verbose mode is not implemented yet.");C(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const i=hEe(t)?t:yield t.iterator();let a=0,l=0;for(;!r||l<e.batches;){const u=yield i.next();if(o=te(()=>{if(u.value){const{xs:c,ys:d}=Uj(n,u.value),h=c.concat(d),p=te(()=>s(h));if(mt(h),0===l)for(let m=0;m<p.length;++m)o.push(Je(0));const f=h[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],y=o[m];o[m]=te(()=>fe(o[m],L(f,g))),l>0&&mt(y)}mt(p),a+=f,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=ze(o[u],a),mt(c)}return Ts(o)})).apply(this,arguments)}function WN(n){C(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function ng(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>hc(r,t,e-t)):hc(n,t,e-t)}function GN(n,t){return te(()=>null==n?null:Array.isArray(n)?n.map(e=>GN(e,t)):dj(n,"int32"===t.dtype?t:Se(t,"int32")))}function HN(n,t){const e=[];let r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}function Hj(n){const t=[];n instanceof yn&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(Ym(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function _i(n,t){if(null==n)return;const e=[];if(t instanceof yn)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(null!=t)for(const s in t)e.push(t[s].id);const r=[];if(n instanceof yn)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=n)for(const s in n){const o=n[s];-1===e.indexOf(o.id)&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function jN(n){return Array.isArray(n)}function jj(n){return!function fEe(n){return n instanceof yn}(n)&&!jN(n)}function qj(n,t,e,r=!0,s=""){if(null==t||0===t.length){if(null!=n){let i=!1;if(jN(n)&&n.length>0)i=!0;else if(jj(n)){for(const a in n)if(n.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new z(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(i=>null);let o;if(jj(n)){o=[];for(const i of t){if(null==n[i])throw new z(`No data provided for "${i}". Need data for each key in: ${t}`);o.push(n[i])}}else if(jN(n)){if(n.length!==t.length)throw new z(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(t.length>1)throw new z(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=Hj(o),null!=e)for(let i=0;i<t.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${s}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c>=0&&u!==c)throw new z(`${s} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function Kj(n,t,e,r=!0,s=""){let o;if(Array.isArray(n)){if(n.length!==t.length)throw new z(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(t.length>1)throw new z(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(null!=e)for(let i=0;i<t.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${s}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c!==u)throw new z(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let hh=(()=>{class n extends bi{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function nEe(n,t,e,r=console.log){const s=function sEe(n){let t=!0;const e=[],r=[];for(const s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of n.layers){let o=!1;for(const i of s.inboundNodes)if(-1!==r.indexOf(i)){if(o){t=!1;break}o=!0}if(!t)break}return t}(n),o=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c))),!s){o.push("Receives inputs"),i=[];for(const c in n.nodesByDepth)i.push(...n.nodesByDepth[c])}r("_".repeat(t)),_w(o,e,r),r("=".repeat(t));const a=n.layers;for(let c=0;c<a.length;++c)s?oEe(a[c],e,r):iEe(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function rEe(n){let t;return t=aw(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),u=aw(n.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function tEe(n){const t={Adagrad:()=>lh.adagrad(.01),Adadelta:()=>lh.adadelta(1,.95,dr()),Adam:()=>lh.adam(.001,.9,.999,dr()),Adamax:()=>lh.adamax(.002,.9,.999,dr(),0),RMSProp:()=>lh.rmsprop(.001,.9,0,dr()),SGD:()=>lh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new z(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ol))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>FN(l))}else{const a=FN(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new z(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(FN(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],dc("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const o=function yEe(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const s of t){let o=e.hasOwnProperty(s)?e[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};dc("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(c=>{let h,p,f;for(const m of c){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===mw?-1!==["accuracy","acc"].indexOf(m)?p=Aj:-1!==["crossentropy","ce"].indexOf(m)&&(p=HCe):this.lossFunctions[a]===fw?-1!==["accuracy","acc"].indexOf(m)?p=jCe:-1!==["crossentropy","ce"].indexOf(m)&&(p=Fj):-1!==["accuracy","acc"].indexOf(m)?p=Rj:-1!==["crossentropy","ce"].indexOf(m)&&(p=Oj),-1!==["accuracy","acc"].indexOf(m)?b="acc":-1!==["crossentropy","ce"].indexOf(m)&&(b="ce"),f=p,h=""+b}else f=eEe(m),h=""+bw(m);let g;dc(h,()=>{g=f}),i(a,h,g)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const o=null==s.batchSize?32:s.batchSize;WN(o);const a=this.standardizeUserDataXY(e,r,!0,o);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),Ts(this.testLoop(this.testFunction,l,o,s.verbose,s.steps))}finally{_i(a[0],e),_i(a[1],r)}}evaluateDataset(e,r){var s=this;return $(function*(){return s.makeTestFunction(),function pEe(n,t,e){return UN.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,o="steps"){let i;if(null!=s){if(i=null,null!=r)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new z("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),i=this.retrieveSymbolicTensors(s?r:[r]),a=new Gl;if(e instanceof yn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new z(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new z(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=Jm(i,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=lc(null,e.length);let s=e.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){const u=a.indexOf(e[l]);if(-1!==u&&(r[l]=i[u],s--),0===s)break}if(0===s)break}if(s>0){const o=[];throw r.forEach((i,a)=>{null==i&&o.push(e[a])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(e,r=32,s=!1){return te(()=>{const o=this.checkNumSamples(e);if(s)throw new nt("Verbose predictLoop() is not implemented yet.");const i=HN(o,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)te(()=>{const h=ng(e,i[l][0],i[l][1]),p=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)p.push({key:this.inputs[m],value:h[m]});else p.push({key:this.inputs[0],value:h});const f=new Gl(p);return Jm(this.outputs,f)}).forEach((c,d)=>a[d].push(c));return Ts(a.map(l=>qr(l,0)))})}predict(e,r={}){const s=Hj(e);Kj(s,this.inputNames,this.feedInputShapes,!1);try{const o=null==r.batchSize?32:r.batchSize;return WN(o),this.predictLoop(s,o)}finally{_i(s,e)}}predictOnBatch(e){Kj(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,o){if(null==this.optimizer_)throw new Bo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];i.push(this.feedLossFns[a]===fw?l.slice(0,l.length-1).concat([1]):l)}if(function mEe(n,t,e){const r=zl(n.map(o=>o.shape[0]));r.sort();const s=zl(t.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(s.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!zt(r,s))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=qj(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=qj(r,this.feedOutputNames,i,!1,"target")),function gEe(n,t,e){const r=[pw,mw,tg];for(let s=0;s<n.length;++s){const o=n[s],i=t[s],a=e[s];if(null!=i){if(i===tg&&1===o.shape[o.shape.length-1])throw new z(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const d=l[c],h=u[c];if(null!=h&&d!==h)throw new z(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,o,i=!0,a){var l=this;return $(function*(){const[u,c]=l.standardizeUserDataXY(e,r,i,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=o){const h=Bj(o,l.outputNames);d=[];for(let p=0;p<h.length;++p)d.push(yield zj(c[p],null,h[p]))}return[u,c,d]})()}testLoop(e,r,s,o=0,i){return te(()=>{const a=this.checkNumSamples(r,s,i,"steps"),l=[];if(o>0)throw new nt("Verbose mode is not implemented yet.");if(null!=i)throw new nt("steps mode in testLoop() is not implemented yet");{const u=HN(a,s),c=Ss(mi(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],p=u[d][1],f=hc(c,h,p-h),m=GN(r,f),g=e(m);if(0===d)for(let y=0;y<g.length;++y)l.push(Je(0));for(let y=0;y<g.length;++y)l[y]=fe(l[y],L(p-h,g[y]))}for(let d=0;d<l.length;++d)l[d]=ze(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const o=e[s];let i=o;ej(e,o)>1&&(i+=`_${ej(e.slice(0,s),o)}`),r.push(i)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const p=new Gl(h),f=Jm(this.outputs,p,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let b=this.lossFunctions[g](o[g],f[g]);null!=i[g]&&(b=aEe(b,i[g]));const _=Gn(b);r.push(_),m=0===g?b:fe(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=r[g];else{const _=this.metricsTensors[g][1];y=Gn((0,this.metricsTensors[g][0])(o[_],f[_]))}qi(y),a.push(y)}return m=Gn(m),this.calculateLosses().forEach(g=>{m=fe(m,g)}),m},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>te(()=>{const r=[];let s;const o=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:o[c]});const l=new Gl(a),u=Jm(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=Gn((0,this.lossFunctions[c])(i[c],u[c]));s=0===c?h:fe(s,h),r.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],p=Gn((0,this.metricsTensors[c][0])(i[h],u[h]));r.push(p)}return r})}fit(e,r,s={}){var o=this;return $(function*(){if(o.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,a,l,u,c,d,h,p,f;o.isTraining=!0;try{const m=null==s.batchSize?32:s.batchSize;WN(m);const g=!1,y=yield o.standardizeUserData(e,r,s.sampleWeight,s.classWeight,g,m);i=y[0],a=y[1],f=y[2];let _,b=!1;if(null!=s.validationData&&s.validationData.length>0){if(b=!0,2!==s.validationData.length)throw 3===s.validationData.length?new nt("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);c=s.validationData[0],d=s.validationData[1];const F=!0,j=yield o.standardizeUserData(c,d,null,null,F,m);h=j[0],p=j[1],_=h.concat(p)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){b=!0;const F=Math.floor(i[0].shape[0]*(1-s.validationSplit)),j=i[0].shape[0];h=ng(i,F,j),l=i,i=ng(i,0,F),p=ng(a,F,j),u=a,a=ng(a,0,F),_=h.concat(p)}else null!=s.validationSteps&&(b=!0);const v=i.concat(a).concat(f);o.checkTrainableWeightsConsistency();const w=o.makeTrainFunction(),S=o.getDedupedMetricsNames();let T,I;b?(o.makeTestFunction(),T=o.testFunction,I=S.slice().concat(S.map(F=>"val_"+F))):(T=null,_=[],I=S.slice());const N=kj(s.callbacks,s.yieldEvery);return yield o.fitLoop(w,v,S,m,s.epochs,s.verbose,N,T,_,s.shuffle,I,s.initialEpoch,null,null)}finally{o.isTraining=!1,_i(i,e),_i(a,r),_i(l,e),_i(u,r),_i(h,c),_i(p,d),null!=f&&mt(f)}})()}fitLoop(e,r,s,o,i,a,l,u,c,d,h,p,f,m){var g=this;return $(function*(){null==o&&(o=32),null==i&&(i=1),null==d&&(d=!0),null==p&&(p=0);let y=!1;if(null!=u&&null!=c&&(y=!0),null!=m&&(y=!0,null==f))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=g.checkNumSamples(r,o,f,"steps_per_epoch");let _;null!=b&&(_=mi(0,b)),null==a&&(a=1);const{callbackList:v,history:w}=Nj(l,a,i,p,b,f,o,y,h);v.setModel(g),g.history=w,yield v.onTrainBegin(),g.stopTraining_=!1;for(let S=p;S<i;++S){yield v.onEpochBegin(S);const T={};if(null!=f)throw new nt("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new nt("batch shuffling is not implemneted yet");d&&dW(_);const I=Ss(_),N=HN(b,o);for(let R=0;R<N.length;++R){const F={};if(yield v.onBatchBegin(R,F),te(()=>{const j=N[R][0],q=N[R][1],X=hc(I,j,q-j);F.batch=R,F.size=q-j;const Q=GN(r,X),V=e(Q);for(let G=0;G<s.length;++G){const Y=V[G];F[s[G]]=Y,qi(Y)}if(R===N.length-1&&y){const G=g.testLoop(u,c,o);for(let W=0;W<s.length;++W){const Y=s[W],se=G[W];qi(se),T["val_"+Y]=se}}}),yield v.onBatchEnd(R,F),Ij(F),g.stopTraining_)break}I.dispose()}if(yield v.onEpochEnd(S,T),g.stopTraining_)break}return yield v.onTrainEnd(),yield g.history.syncData(),g.history})()}fitDataset(e,r){var s=this;return $(function*(){return function cEe(n,t,e){return zN.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return $(function*(){const o=yield s.standardizeUserData(e,r),i=o[0],a=o[1],u=s.makeTrainFunction()(i.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return mt(u),_i(o[0],e),_i(o[1],r),Ts(c)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<o.length;++a)s&&!o[a].trainable||r.push({name:o[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=rk().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-rk().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Pa(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Pa(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const o of r){if("string"!=typeof s[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=Pa(s[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Pa(bw(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Pa(bw(e)));{const e={};for(const r in this.metrics)e[r]=Pa(bw(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=La(PN(e.optimizer_config));let o,i;if("string"==typeof e.loss)o=uc(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>uc(a));else if(null!=e.loss){o={};for(const a in e.loss)o[a]=uc(e.loss[a])}if(Array.isArray(e.metrics))i=e.metrics.map(a=>uc(a));else if(null!=e.metrics){i={};for(const a in e.metrics)i[a]=uc(e.metrics[a])}this.compile({loss:o,metrics:i,optimizer:s})}save(e,r){var s=this;return $(function*(){if("string"==typeof e){const d=(n=>Nn.getSaveHandlers(n))(e);if(0===d.length)throw new z(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new z(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield KW(s.getNamedWeights(r)),u={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.2.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){u.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:p}=yield KW(yield s.optimizer.getWeights(),d);o.specs.push(...p),o.data=jI([o.data,h])}return null!=s.userDefinedMetadata&&(Pj(s.userDefinedMetadata,s.name,!0),u.userDefinedMetadata=s.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})()}setUserDefinedMetadata(e){Pj(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();de(hh),de((()=>{class n extends hh{}return n.className="Functional",n})()),de((()=>{class n extends hh{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:nw("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new z(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof hh;let s;if(r){if(s=e,1!==s.outputs.length)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function xCe(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new uw({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Sj(this.outputs[0])}this.inboundNodes=[],new lw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:lc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Vt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new hh({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new Bo("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return $(function*(){if(!s.built)throw new Bo("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var o=this;return $(function*(){if(!o.built)throw new Bo("The model needs to be compiled before being used.");return o.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return $(function*(){if(!s.built)throw new Bo("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return $(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},o=!1){let i,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new z("Legacy serialization format not supported yet.");i=r}else C(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof n))throw new nt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const d=La(u,void 0,o);o&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class Cs extends eh{getConfig(){return{}}}de((()=>{class n extends Cs{apply(e,r=1){return function uCe(n,t=1){if(1!==t)throw new nt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Lv(n)}(e,r)}}return n.className="elu",n})()),de((()=>{class n extends Cs{apply(e){return zG(e)}}return n.className="selu",n})()),de((()=>{class n extends Cs{apply(e){return $a(e)}}return n.className="relu",n})()),de((()=>{class n extends Cs{apply(e){return te(()=>zv(6,$a(e)))}}return n.className="relu6",n})()),de((()=>{class n extends Cs{apply(e){return e}}return n.className="linear",n})()),de((()=>{class n extends Cs{apply(e){return sh(e)}}return n.className="sigmoid",n})()),de((()=>{class n extends Cs{apply(e){return function dCe(n){return te(()=>{const t=fe(.5,L(.2,n));return ro(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),de((()=>{class n extends Cs{apply(e){return zm(e)}}return n.className="softplus",n})()),de((()=>{class n extends Cs{apply(e){return function cCe(n){return te(()=>ze(n,fe(wr(n),1)))}(e)}}return n.className="softsign",n})()),de((()=>{class n extends Cs{apply(e){return Fk(e)}}return n.className="tanh",n})());let Xj=(()=>{class n extends Cs{apply(e,r=-1){return Ok(e,r)}}return n.className="softmax",n})();function jl(n){return n.getClassName()}function YN(n,t={}){return Km(n,Oo.getMap().classNameMap,t,"activation")}function ql(n){if(null==n){return YN({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},YN(t)}return n instanceof Cs?n:YN(n)}de(Xj),de((()=>{class n extends Cs{apply(e,r=-1){return LG(e,r)}}return n.className="logSoftmax",n})()),de((()=>{class n extends Cs{apply(e,r=1){return te(()=>L(sh(L(e,r)),e))}}return n.className="swish",n})()),de((()=>{class n extends Cs{apply(e){return te(()=>L(e,Fk(zm(e))))}}return n.className="mish",n})());class Yj extends eh{}de((()=>{class n extends Yj{constructor(e){super(),function ZN(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return te(()=>{let r=Tr([1]);return this.hasL1&&(r=fe(r,Me(L(this.l1,wr(e))))),this.hasL2&&(r=fe(r,Me(L(this.l2,Zm(e))))),H(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const Zj={l1l2:"L1L2"};function Jt(n){return wN(n)}function Qj(n,t={}){return Km(n,Oo.getMap().classNameMap,t,"regularizer")}function wn(n){return null==n?null:"string"==typeof n?Qj({className:n in Zj?Zj[n]:n,config:{}}):n instanceof Yj?n:Qj(n)}function ph(n,t,e){if("number"==typeof n)return lc(n,t);if(n.length!==t)throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const s=n[r];if(!rCe(s))throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function vi(n,t,e,r,s=1){if(null==n)return n;let i;return i="same"===e?n:n-(t+(t-1)*(s-1))+1,Math.floor((i+r-1)/r)}function ta(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+Wl([e-t,0]);else{if("same"!==r)throw new z(`Unsupport padding mode: ${r}.`);n*=t}return n}function JN(n,t){return te(()=>(qn(t),"channelsFirst"===t?At(n,[0,2,3,1]):n))}function Jj(n,t){return te(()=>(qn(t),"channelsFirst"===t?At(n,[0,2,3,4,1]):n))}function eD(n,t,e,r=[1,1],s="valid",o,i,a=null){return te(()=>{if(null==o&&(o="channelsLast"),qn(o),3!==n.rank&&4!==n.rank)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=JN(n,o);if("causal"===s)throw new nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Iwe({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===o&&(l=At(l,[0,3,1,2])),l})}de((()=>{class n extends vt{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=Ze(e);let s=$a(e);return null!=this.maxValue&&(s=ro(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),de((()=>{class n extends vt{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=Ze(e);return Sk(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),de((()=>{class n extends vt{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=vn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wn(e.alphaRegularizer),this.alphaConstraint=fr(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Vt(e)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let o=1;o<e.length;++o)s[o]=e[o];this.inputSpec=[new hr({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=Ze(e),Nk(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Rn(this.alphaInitializer),alphaRegularizer:Jt(this.alphaRegularizer),alphaConstraint:pr(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),de((()=>{class n extends vt{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new nt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=Ze(e);return Lv(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),de((()=>{class n extends vt{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const s=Ze(e);return L(s,Se(so(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),de((()=>{class n extends vt{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Xj).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){const s=Ze(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class vw extends vt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",vw.verifyArgs(e),this.rank=t,Cr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new nt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ph(e.kernelSize,t,"kernelSize"),this.strides=ph(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,lo(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,qn(this.dataFormat),this.activation=ql(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=fr(e.biasConstraint),this.biasRegularizer=wn(e.biasRegularizer),this.activityRegularizer=wn(e.activityRegularizer),this.dilationRate=ph(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(ao("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!SN(t.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:jl(this.activation),useBias:this.useBias,biasInitializer:Rn(this.biasInitializer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),biasConstraint:pr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class fh extends vw{constructor(t,e){super(t,e),this.kernel=null,fh.verifyArgs(e),this.filters=e.filters,Cr(this.filters,"filters"),this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=fr(e.kernelConstraint),this.kernelRegularizer=wn(e.kernelRegularizer)}build(t){t=Vt(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new z(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return te(()=>{let r;t=Ze(t);const s=null==this.bias?null:this.bias.read(),o=nj(this.activation.getClassName());if(null!=o&&2===this.rank)r=eD(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function e6(n,t,e,r=1,s="valid",o,i=1){return te(()=>{if(null==o&&(o="channelsLast"),qn(o),3!==n.shape.length)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===o&&(n=At(n,[0,2,1])),"causal"===s)throw new nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=$G(n,t,r,"same"===s?"same":"valid","NWC",i);return null!=e&&(a=yi(a,e)),a})}(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=eD(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new nt("convolutions greater than 3D are not implemented yet.");r=function t6(n,t,e,r=[1,1,1],s="valid",o,i){return te(()=>{if(null==o&&(o="channelsLast"),qn(o),4!==n.rank&&5!==n.rank)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Jj(n,o);if("causal"===s)throw new nt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=rve(a,t,r,"same"===s?"same":"valid","NDHWC",i),null!=e&&(a=yi(a,e)),"channelsFirst"===o&&(a=At(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Vt(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<r.length;++o){const i=vi(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);e.push(i)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:Rn(this.kernelInitializer),kernelRegularizer:Jt(this.kernelRegularizer),kernelConstraint:pr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let n6=(()=>{class n extends fh{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!SN(e.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();de(n6);let r6=(()=>{class n extends fh{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();de(r6),de((()=>{class n extends n6{constructor(e){if(super(e),this.inputSpec=[new hr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Vt(e)).length)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new hr({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return te(()=>{let s=Ze(e);if(4!==s.shape.length)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=o[l],h=this.kernelSize[1],f=this.strides[1],y=[o[0],ta(o[a],this.strides[0],this.kernelSize[0],this.padding),ta(c,f,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=At(s,[0,2,3,1]));let b=OG(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=At(b,[0,3,1,2])),null!=this.bias&&(b=yi(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const r=(e=Vt(e)).slice();let s,o,i;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3):(s=3,o=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[s]=this.filters,r[o]=ta(r[o],u,a,this.padding),r[i]=ta(r[i],c,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),de((()=>{class n extends r6{constructor(e){if(super(e),this.inputSpec=[new hr({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Vt(e)).length)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new hr({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return te(()=>{let s=Ze(e);if(5!==s.shape.length)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l,u;"channelsFirst"===this.dataFormat?(u=2,a=3,l=4):(u=1,a=2,l=3);const d=o[a],h=o[l],f=this.kernelSize[1],m=this.kernelSize[2],y=this.strides[1],b=this.strides[2],S=[o[0],ta(o[u],this.strides[0],this.kernelSize[0],this.padding),ta(d,y,f,this.padding),ta(h,b,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=At(s,[0,2,3,4,1]));let T=ive(s,this.kernel.read(),S,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(T=At(T,[0,4,1,2,3])),null!==this.bias&&(T=yi(T,this.bias.read(),this.dataFormat)),null!==this.activation&&(T=this.activation.apply(T)),T})}computeOutputShape(e){const r=(e=Vt(e)).slice();let s,o,i,a;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3,a=4):(s=4,o=1,i=2,a=3);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],p=this.strides[2];return r[s]=this.filters,r[o]=ta(r[o],d,l,this.padding),r[i]=ta(r[i],h,u,this.padding),r[a]=ta(r[a],p,c,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let wEe=(()=>{class n extends fh{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=vn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wn(r.depthwiseRegularizer),this.depthwiseConstraint=fr(r.depthwiseConstraint),this.pointwiseInitializer=vn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wn(r.pointwiseRegularizer),this.pointwiseConstraint=fr(r.pointwiseConstraint)}build(e){if((e=Vt(e)).length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new hr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return te(()=>{let s;if(e=Ze(e),1===this.rank)throw new nt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=At(e,[0,2,3,1])),s=UG(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=yi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=At(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Rn(this.depthwiseInitializer),e.pointwiseInitializer=Rn(this.pointwiseInitializer),e.depthwiseRegularizer=Jt(this.depthwiseRegularizer),e.pointwiseRegularizer=Jt(this.pointwiseRegularizer),e.depthwiseConstraint=pr(this.depthwiseConstraint),e.pointwiseConstraint=pr(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function s6(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new z("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:n,initialState:t=s(t),constants:e=s(e)}}function o6(n,t,e,r=!1,s,o,i=!1,a=!1){return te(()=>{const l=t.shape.length;if(l<3)throw new z(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(mi(2,l));if(t=At(t,u),null!=o)throw new nt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=Se(Se(s,"bool"),"float32")).rank===l-1&&(s=xs(s,-1)),s=At(s,u)),r&&(t=oc(t,0),null!=s&&(s=oc(s,0)));const c=[];let d,h=e;const p=t.shape[0],f=ic(t);let m,g;null!=s&&(m=ic(s));for(let y=0;y<p;++y){const b=f[y],_=te(()=>n(b,h));if(null==s)d=_[0],h=_[1];else{const v=te(()=>{const w=m[y],S=Fe(Lo(w),w);return{output:fe(L(_[0],w),L(h[0],S)),newStates:h.map((N,R)=>fe(L(_[1][R],w),L(N,S)))}});d=v.output,h=v.newStates}a&&c.push(d)}return a&&(g=Oa(c,1)),[d,g,h]})}de((()=>{class n extends wEe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),de((()=>{class n extends fh{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!SN(e.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return te(()=>{if(e=Ze(e),"channelsLast"===this.dataFormat){const s=sw(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return sw(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=sw(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return sw(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,qn(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function eCe(n){cc(Y1e,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return te(()=>{let s=Ze(e);const o=s.shape;if("channelsFirst"===this.dataFormat){s=At(s,[0,2,3,1]);const i=this.size[0]*o[2],a=this.size[1]*o[3],l="nearest"===this.interpolation?Bl.resizeNearestNeighbor(s,[i,a]):Bl.resizeBilinear(s,[i,a]);return At(l,[0,3,1,2])}{const i=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?Bl.resizeNearestNeighbor(s,[i,a]):Bl.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),de((()=>{class n extends vw{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=vn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=fr(e.depthwiseConstraint),this.depthwiseRegularizer=wn(e.depthwiseRegularizer)}build(e){if((e=Vt(e)).length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return te(()=>{let s=function xEe(n,t,e=[1,1],r="valid",s,o){return te(()=>{null==s&&(s="channelsLast"),qn(s);let i=JN(n,s);if(4!==n.rank)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Pv(i,t,e,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===s&&(i=At(i,[0,3,1,2])),i})}(e=Ze(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=yi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Vt(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=vi("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=vi(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,i,a]:[e[0],i,a,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Rn(this.depthwiseInitializer),e.depthwiseRegularizer=Jt(this.depthwiseRegularizer),e.depthwiseConstraint=pr(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let rg=(()=>{class n extends vt{constructor(e){let r;if(super(e),null==e.cell)throw new z("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new l6({cells:e.cell}):e.cell,null==r.stateSize)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new hr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?mi(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){kN(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let o;if(o=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const i=[];for(const a of r)i.push([e[0],a]);return[o].concat(i)}return o}computeMask(e,r){return te(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new nt("Constants support is not implemented in RNN yet.");kN(e)&&(e=e[0]);const s=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new hr({shape:[s,null,...o]});const i=[e[0]].concat(e.slice(2));let a;if(this.cell.build(i),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!zt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new hr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){te(()=>{if(!this.stateful)throw new Yi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>Tr([s,o])):[Tr([s,this.cell.stateSize])];else if(null==e)mt(this.states_),null!=this.keptStates&&(mt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Tr([s,o])):this.states_[0]=Tr([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):mt(this.states_);for(let o=0;o<this.states_.length;++o){const i=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,l=[s,a];if(!zt(i.shape,l))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>qi(o.clone()))})}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=s6(e,s,o,this.numConstants);e=i.inputs,s=i.initialState,o=i.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new hr({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof ea){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,r);return this.inputSpec=h,p}return super.apply(e,r)}call(e,r){return te(()=>{const s=null==r?null:r.mask,o=null==r?null:r.training;let i=null==r?null:r.initialState;e=Ze(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new z(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:o},c=o6((m,g)=>{const y=this.cell.call([m].concat(g),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],h=c[1],p=c[2];this.stateful&&this.resetStates(p,o);const f=this.returnSequences?h:d;return this.returnState?[f].concat(p):f})}getInitialState(e){return te(()=>{let r=Tr(e.shape);return r=Me(r,[1,2]),r=Ym(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?EN(r,[1,s]):r):this.cell.stateSize>1?[EN(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const i=La(r.cell,s);return new e(Object.assign(r,{cell:i}))}}return n.className="RNN",n})();de(rg);class ww extends vt{}let i6=(()=>{class n extends ww{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Cr(this.units,"units"),this.activation=ql(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wn(e.kernelRegularizer),this.recurrentRegularizer=wn(e.recurrentRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.kernelConstraint=fr(e.kernelConstraint),this.recurrentConstraint=fr(e.recurrentConstraint),this.biasConstraint=fr(e.biasConstraint),this.dropout=ch([1,Wl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=ch([1,Wl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return te(()=>{if(2!==e.length)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const o=null!=r.training&&r.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Lo(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Lo(s),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;i=Qi(null!=a?L(e,a):e,this.kernel.read()),null!=this.bias&&(i=yi(i,this.bias.read())),null!=l&&(s=L(s,l));let u=fe(i,Qi(s,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:jl(this.activation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),recurrentInitializer:Rn(this.recurrentInitializer),biasInitializer:Rn(this.biasInitializer),kernelRegularizer:Jt(this.kernelRegularizer),recurrentRegularizer:Jt(this.recurrentRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:pr(this.kernelConstraint),recurrentConstraint:pr(this.recurrentConstraint),biasConstraint:pr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();de(i6),de((()=>{class n extends rg{constructor(e){e.cell=new i6(e),super(e)}call(e,r){return te(()=>(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let a6=(()=>{class n extends ww{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Cr(this.units,"units"),this.activation=ql(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ql(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wn(e.kernelRegularizer),this.recurrentRegularizer=wn(e.recurrentRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.kernelConstraint=fr(e.kernelConstraint),this.recurrentConstraint=fr(e.recurrentConstraint),this.biasConstraint=fr(e.biasConstraint),this.dropout=ch([1,Wl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=ch([1,Wl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return te(()=>{if(2!==e.length)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=null!=r.training&&r.training;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Lo(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Lo(o),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=L(e,this.dropoutMask[0]));let d=Qi(e,this.kernel.read());this.useBias&&(d=yi(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=L(o,a[0]));const h=this.recurrentKernel.read(),[p,f]=oo(h,[2*this.units,this.units],h.rank-1),m=Qi(o,p),[g,y,b]=oo(d,3,d.rank-1),[_,v]=oo(m,2,m.rank-1);l=this.recurrentActivation.apply(fe(g,_)),u=this.recurrentActivation.apply(fe(y,v));const w=Qi(L(u,o),f);c=this.activation.apply(fe(b,w));const S=fe(L(l,o),L(fe(1,An(l)),c));return[S,S]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:jl(this.activation),recurrentActivation:jl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),recurrentInitializer:Rn(this.recurrentInitializer),biasInitializer:Rn(this.biasInitializer),kernelRegularizer:Jt(this.kernelRegularizer),recurrentRegularizer:Jt(this.recurrentRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:pr(this.kernelConstraint),recurrentConstraint:pr(this.recurrentConstraint),biasConstraint:pr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();de(a6),de((()=>{class n extends rg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new a6(e),super(e)}call(e,r){return te(()=>(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let tD=(()=>{class n extends ww{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Cr(this.units,"units"),this.activation=ql(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ql(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wn(e.kernelRegularizer),this.recurrentRegularizer=wn(e.recurrentRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.kernelConstraint=fr(e.kernelConstraint),this.recurrentConstraint=fr(e.recurrentConstraint),this.biasConstraint=fr(e.biasConstraint),this.dropout=ch([1,Wl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=ch([1,Wl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let o;if(e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;o=new((r=class extends Uo{apply(u,c){const d=i.apply([a]),h=(new pj).apply([a]),p=i.apply([2*a]);return cj(cj(d,h),p)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return te(()=>{const s=null!=r.training&&r.training;if(3!==e.length)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Lo(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Lo(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=L(e,this.dropoutMask[0]));let p=Qi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=L(o,l[0])),p=fe(p,Qi(o,this.recurrentKernel.read())),this.useBias&&(p=yi(p,this.bias.read()));const[f,m,g,y]=oo(p,4,p.rank-1);u=this.recurrentActivation.apply(f),c=this.recurrentActivation.apply(m),d=fe(L(c,i),L(u,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const b=L(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:jl(this.activation),recurrentActivation:jl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),recurrentInitializer:Rn(this.recurrentInitializer),biasInitializer:Rn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Jt(this.kernelRegularizer),recurrentRegularizer:Jt(this.recurrentRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:pr(this.kernelConstraint),recurrentConstraint:pr(this.recurrentConstraint),biasConstraint:pr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();de(tD),de((()=>{class n extends rg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new tD(e),super(e)}call(e,r){return te(()=>(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let l6=(()=>{class n extends ww{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return te(()=>{let s=e.slice(1);const o=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?o.push(s.splice(0,l.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=o[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=u.call(a,r),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;kN(e)&&(e=e[0]),this.cells.forEach((s,o)=>{dc(`RNNCell_${o}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),o={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign(Object.assign({},e),o)}static fromConfig(e,r,s={}){const o=[];for(const i of r.cells)o.push(La(i,s));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return NN(e)}setWeights(e){const r=[];for(const s of this.cells){const i=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],i[a]])}DN(r)}}return n.className="StackedRNNCells",n})();function Kl(n){const{ones:t,rate:e,training:r=!1,count:s=1,dropoutFunc:o}=n,i=()=>null!=o?o(t(),e):hj(t(),e),a=()=>Qm(i,t,r);return!s||s<=1?qi(a().clone()):Array(s).fill(void 0).map(a).map(u=>qi(u.clone()))}de(l6);let TEe=(()=>{class n extends rg{constructor(e){if(e.unroll)throw new nt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new nt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new hr({ndim:5})]}call(e,r){return te(()=>{if(null!=this.cell.dropoutMask&&(mt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new z("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return te(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(e.shape),a=Tr([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){te(()=>{if(!this.stateful)throw new Yi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(null==s[0])throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Tr(i)):[Tr(i)];else if(null==e)mt(this.states_),null!=this.keptStates&&(mt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Tr(i)):this.states_[0]=Tr(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):mt(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=i;if(!zt(u.shape,c))throw new z(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>qi(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:o,padding:i,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===r,d=e[u?4:3],h=vi(e[u?3:2],o[0],i,a[0],l[0]),p=vi(d,o[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[s,h,p]:[h,p,s]]}}return n.className="ConvRNN2D",n})(),u6=(()=>{class n extends tD{constructor(e){const{filters:r,kernelSize:s,strides:o,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Cr(this.filters,"filters"),this.kernelSize=ph(s,2,"kernelSize"),this.kernelSize.forEach(u=>Cr(u,"kernelSize")),this.strides=ph(o||1,2,"strides"),this.strides.forEach(u=>Cr(u,"strides")),this.padding=i||"valid",lo(this.padding),this.dataFormat=a||"channelsLast",qn(this.dataFormat),this.dilationRate=ph(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Cr(u,"dilationRate"))}build(e){var r;e=Vt(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new z(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((r=class extends Uo{apply(p,f){return CN([c.apply([d]),Vl([d]),c.apply([2*d])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return te(()=>{if(3!==e.length)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,o=e[0],i=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Kl({ones:()=>Lo(o),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(le,pe,he)=>pe&&pe[he]?L(pe[he],le):le;let d=c(o,u,0),h=c(o,u,1),p=c(o,u,2),f=c(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Kl({ones:()=>Lo(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=c(i,m,0),y=c(i,m,1),b=c(i,m,2),_=c(i,m,3);const[w,S,T,I]=oo(this.kernel.read(),4,3),[N,R,F,j]=this.useBias?oo(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,N,this.padding),h=this.inputConv(h,S,R,this.padding),p=this.inputConv(p,T,F,this.padding),f=this.inputConv(f,I,j,this.padding);const[q,X,Q,V]=oo(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,q),y=this.recurrentConv(y,X),b=this.recurrentConv(b,Q),_=this.recurrentConv(_,V);const G=this.recurrentActivation.apply(fe(d,g)),W=this.recurrentActivation.apply(fe(h,y)),Y=fe(L(W,a),L(G,this.activation.apply(fe(p,b)))),se=L(this.recurrentActivation.apply(fe(f,_)),this.activation.apply(Y));return[se,se,Y]})}getConfig(){const s=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]])}return e}(super.getConfig(),["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),o)}inputConv(e,r,s,o){const i=rc(e,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?yi(i,s,this.dataFormat):i}recurrentConv(e,r){return rc(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();de(u6),de((()=>{class n extends TEe{constructor(e){const r=new u6(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let c6=(()=>{class n extends vt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(null==this.noiseShape[o]?r[o]:this.noiseShape[o]);return s}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=Ze(e);if(0<this.rate&&this.rate<1){const o=null!=r.training&&r.training,i=this.getNoiseShape(s);return Qm(()=>hj(s,this.rate,i,this.seed),()=>s,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();de(c6),de((()=>{class n extends c6{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})()),de((()=>{class n extends vt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Cr(this.units,"units"),this.activation=ql(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=fr(e.kernelConstraint),this.biasConstraint=fr(e.biasConstraint),this.kernelRegularizer=wn(e.kernelRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.activityRegularizer=wn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Vt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Vt(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=Ze(e),o=nj(this.activation.getClassName());let i;return null!=o?i=Qi(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=Qi(s,this.kernel.read()),null!=this.bias&&(i=yi(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:jl(this.activation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),biasInitializer:Rn(this.biasInitializer),kernelRegularizer:Jt(this.kernelRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:pr(this.kernelConstraint),biasConstraint:pr(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})()),de((()=>{class n extends vt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Vt(e);for(const r of e.slice(1))if(null==r)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ul(e,1)]}call(e,r){return te(()=>{this.invokeCallHook(e,r);let s=Ze(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=At(s,o)}return function lCe(n){if(n.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Ul(n.shape,1)];return H(n,t)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.activation=ql(e.activation)}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=Ze(e);return this.activation.apply(s)})}getConfig(){const e={activation:jl(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return te(()=>function iCe(n,t){return te(()=>{if(2!==n.shape.length)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return EN(Ym(n,1),[1,t,1])})}(e=Ze(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",o=r.slice();let i=1,a=null;for(let u=0;u<o.length;++u){const c=o[u];if(this.isUnknown(c)){if(null!==a)throw new z("Can only specifiy one unknown dimension.");a=u}else i*=c}const l=Ul(e);if(null!==a){if(0===i||l%i!=0)throw new z(s);o[a]=l/i}else if(l!==i)throw new z(s);return o}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=Ze(e),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return H(s,i)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),de((()=>{class n extends vt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=mi(1,e.dims.length+1);if(!zt(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new hr({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Vt(e)).slice();return this.dims.forEach((s,o)=>{r[o+1]=e[s]}),r}call(e,r){return At(Ze(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),de((()=>{class n extends vt{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=Ze(e);return yk(Vm(s,this.maskValue),-1)}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=Ze(e),a=yk(Vm(s,this.maskValue),-1,!0);return L(s,Se(a,s.dtype))})}}return n.className="Masking",n})()),de((()=>{class n extends vt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(un(e.inputLength))}this.inputDim=e.inputDim,Cr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Cr(this.outputDim,"outputDim"),this.embeddingsInitializer=vn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wn(e.embeddingsRegularizer),this.activityRegularizer=wn(e.activityRegularizer),this.embeddingsConstraint=fr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return te(()=>this.maskZero?(e=Ze(e),Vm(e,$t(e))):null)}computeOutputShape(e){if(e=Vt(e),null==this.inputLength)return[...e,this.outputDim];const r=un(this.inputLength);if(r.length!==e.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let o=0;o<r.length;++o){const i=r[o],a=e[o+1];if(null!=i&&null!=a&&i!==a)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return te(()=>{this.invokeCallHook(e,r);let s=Ze(e);"int32"!==s.dtype&&(s=Zi(s,"int32"));const o=dj(this.embeddings.read(),H(s,[s.size]));return H(o,Vt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Rn(this.embeddingsInitializer),embeddingsRegularizer:Jt(this.embeddingsRegularizer),activityRegularizer:Jt(this.activityRegularizer),embeddingsConstraint:pr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class pc extends vt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new nt}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const o=t[t.length-e.length+s],i=e[s];if(null==o||null==i||o<0||i<0)r.push(null);else if(1===o)r.push(i);else if(1===i)r.push(o);else{if(o!==i)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(o)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Vt(t)]),t.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const o of t)null!=o&&null!==o[0]&&e.push(o[0]);if(e=zl(e),e.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let o=1;o<t.length;++o){const i=null==t[o]?null:t[o].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=t.map(o=>o.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==zl(s).length}call(t,e){return te(()=>{if(this.reshapeRequired){const r=[],s=t.map(o=>o.rank);if(-1===s.indexOf(null)){const o=Wl(s);for(let i of t){const a=i.rank;for(let l=0;l<o-a;++l)i=Ym(i,1);r.push(i)}return this.mergeFunction(r)}{let o=!1;for(const l of t){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let p=H(l,[d].concat(Ul(c.slice(1))));p=At(p,[1,0]),p=H(p,h),r.push(p),o=!0}else if(u>1){const c=mi(1,u).concat([0]);r.push(At(l,c)),o=!0}else r.push(l)}let i=this.mergeFunction(r);const a=i.rank;if(o)if(null==a){const l=i.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));i=H(At(H(i,[-1,c]),[1,0]),d)}else if(a>1){const l=[a-1].concat(mi(0,a-1));i=At(i,l)}return i}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const o=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let r=[];for(const s of t)null!=s&&null!==s[0]&&r.push(s[0]);return r=zl(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return te(()=>{if(null==e)return null;if(!Array.isArray(e))throw new z("`mask` should be an Array");if(!Array.isArray(t))throw new z("`inputs` should be an Array");if(e.length!==t.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:xs(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Ra(r,e[s]);return r})}}function sg(n,t){for(;n<0;)n+=t;return n}function og(n,t,e,r,s,o=.001){let i;if(2===n.rank)i=M_e(n,t,e,r,s,o);else if(3===n.rank)i=L_e(n,t,e,r,s,o);else{if(4!==n.rank)throw new nt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);i=B_e(n,t,e,r,s,o)}return i}function xw(n,t,e,r,s,o){return te(()=>{let i;qn(s),sj(o),lo(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),n=JN(n,s);const a="same"===r?"same":"valid";return i="max"===o?Ck(n,t,e,a):vk(n,t,e,a),"channelsFirst"===s&&(i=At(i,[0,3,1,2])),i})}function d6(n,t,e,r,s,o){return te(()=>{let i;qn(s),sj(o),lo(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),n=Jj(n,s);const a="same"===r?"same":"valid";return i="max"===o?Nve(n,t,e,a):R_e(n,t,e,a),"channelsFirst"===s&&(i=At(i,[0,4,1,2,3])),i})}de((()=>{class n extends pc{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=fe(r,e[s]);return r})}}return n.className="Add",n})()),de((()=>{class n extends pc{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=L(r,e[s]);return r})}}return n.className="Multiply",n})()),de((()=>{class n extends pc{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=fe(r,e[s]);return L(1/e.length,r)})}}return n.className="Average",n})()),de((()=>{class n extends pc{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Fl(r,e[s]);return r})}}return n.className="Maximum",n})()),de((()=>{class n extends pc{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=zv(r,e[s]);return r})}}return n.className="Minimum",n})()),de((()=>{class n extends pc{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of e)if(null!=o){r=!1;break}if(r)return;const s=[];for(let o=0;o<e.length;++o){const i=e[o].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(zt(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return te(()=>CN(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new z("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of r.slice(1)){if(null==s[o]||null==i[o]){s[o]=null;break}s[o]+=i[o]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new z("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new z(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return te(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const o=[];for(let a=0;a<e.length;++a)o.push(null==r[a]?Se(Lo(e[a]),"bool"):r[a].rank<e[a].rank?xs(r[a],-1):r[a]);const i=qr(o,this.axis);return RG(i,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),de((()=>{class n extends pc{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){C(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new nt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);if(r[o[0]]!==s[o[1]])throw new z(`Dimension incompatibility: ${r[o[0]]} !== ${s[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let o,r=e[0],s=e[1];return o=Array.isArray(this.axes)?this.axes.map((i,a)=>sg(i,e[a].shape.length)):[sg(this.axes,r.shape.length),sg(this.axes,s.shape.length)],this.normalize&&(r=hw(r,o[0]),s=hw(s,o[1])),function CEe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new nt("batchDot is not implemented for tensors of 4D or higher rank yet");if(C(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),C(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new nt("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=t.shape.length;null==e&&(e=[r-1,s-2]);const o=e;return te(()=>{let i,a;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);t=H(t,t.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);n=H(n,n.shape.concat(l))}else i=0;if(a=2===n.shape.length&&2===t.shape.length?o[0]===o[1]?Me(L(n,t),o[0]):Me(L(At(n,[1,0]),t),o[1]):Ut(n,t,o[0]!==n.shape.length-1,o[1]===t.shape.length-1),i>0){let l;l=r>s?r+s-3:r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=Um(a,u)}return 1===a.shape.length&&(a=xs(a,1)),a})}(r,s,o)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[sg(this.axes,e.length),sg(this.axes,r.length)],s}computeOutputShape(e){C(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new nt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);r.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=r.concat(s);return 1===i.length&&i.push(1),i}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=Ze(e);return Qm(()=>fe(ow(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return n.className="GaussianNoise",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=Ze(e);return this.rate>0&&this.rate<1?Qm(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return L(s,ow(s.shape,1,i))},()=>s,r.training||!1):s})}}return n.className="GaussianDropout",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ze(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return te(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Qm(()=>{const i=Ze(e),u=-1.7580993408473766;let c=sc(Uv(s),this.rate);c=Zi(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,p=fe(L(i,c),L(fe(c,-1),u));return fe(L(p,d),h)},()=>Ze(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),de((()=>{class n extends vt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=vn(e.betaInitializer||"zeros"),this.gammaInitializer=vn(e.gammaInitializer||"ones"),this.movingMeanInitializer=vn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=vn(e.movingVarianceInitializer||"ones"),this.betaConstraint=fr(e.betaConstraint),this.gammaConstraint=fr(e.gammaConstraint),this.betaRegularizer=wn(e.betaRegularizer),this.gammaRegularizer=wn(e.gammaRegularizer)}build(e){e=Vt(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new z(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new hr({ndim:e.length,axes:{[r]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return te(()=>{const s=null!=r.training&&r.training,o=Ze(e),i=o.shape,a=i.length,l=mi(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=lc(1,a);c[u]=i[u];const d=l.slice();d.sort();const h=!zt(d,mi(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const _=H(this.movingMean.read(),c),v=H(this.movingVariance.read(),c),w=this.center?H(this.beta.read(),c):null,S=this.scale?H(this.gamma.read(),c):null;return og(o,_,v,w,S,this.epsilon)}return og(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[f,m,g]=function kEe(n,t,e,r,s=.001){return zt(r.slice().sort(),mi(0,n.rank-1))?function EEe(n,t,e,r,s=.001){return te(()=>{const o=Ik(n,r),i=o.mean,a=o.variance;return[og(n,i,a,e,t,s),i,a]})}(n,t,e,r,s):function IEe(n,t,e,r,s=.001){return te(()=>{const o=Ik(n,r),i=o.mean,a=o.variance,l=[];for(const f of mi(0,n.rank))-1!==r.indexOf(f)?l.push(1):l.push(n.shape[f]);const u=H(i,l),c=H(a,l),d=null==t?null:H(t,l),h=null==e?null:H(e,l);return[og(n,u,c,h,d,s),i,a]})}(n,t,e,r,s)}(o,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(_,v,w)=>{te(()=>{const S=1-w,T=_.read(),I=L(Fe(T,v),S);_.write(Fe(T,I))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Rn(this.betaInitializer),gammaInitializer:Rn(this.gammaInitializer),movingMeanInitializer:Rn(this.movingMeanInitializer),movingVarianceInitializer:Rn(this.movingVarianceInitializer),betaRegularizer:Jt(this.betaRegularizer),gammaRegularizer:Jt(this.gammaRegularizer),betaConstraint:pr(this.betaConstraint),gammaConstraint:pr(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),de((()=>{class n extends vt{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=vn(e.betaInitializer||"zeros"),this.gammaInitializer=vn(e.gammaInitializer||"ones"),this.betaRegularizer=wn(e.betaRegularizer),this.gammaRegularizer=wn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Vt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(const i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==zl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=Ze(e),o=s.shape,i=o.length;return te(()=>{let{mean:l,variance:u}=Ik(s,this.axis,!0);const c=lc(1,i);for(const g of this.axis)c[g]=o[g];const d=g=>null!=g&&g.shape.length!==i?H(g,c):g;let h=this.scale?d(this.gamma.read()):null,p=this.center?d(this.beta.read()):null;const f=[],m=[];for(let g=0;g<i;++g)-1!==this.axis.indexOf(g)?(f.push(o[g]),m.push(1)):(f.push(1),m.push(o[g]));return l=pi(l,f),u=pi(u,f),null!=h&&(h=pi(h,m)),null!=p&&(p=pi(p,m)),og(s,l,u,p,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Rn(this.betaInitializer),gammaInitializer:Rn(this.gammaInitializer),betaRegularizer:Jt(this.betaRegularizer),gammaRegularizer:Jt(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),de((()=>{class n extends vt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new hr({ndim:4})]}computeOutputShape(e){let r,s;return e=Vt(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return te(()=>function NEe(n,t,e){return te(()=>{if(4!==n.rank)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new z(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],kk(n,r)})}(Ze(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class h6 extends vt{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Cr(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Cr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,lo(this.padding),this.inputSpec=[new hr({ndim:3})]}computeOutputShape(t){const e=vi((t=Vt(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return te(()=>{this.invokeCallHook(t,e),t=Ym(Ze(t),2);const r=this.poolingFunction(Ze(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Um(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}de((()=>{class n extends h6{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return qn(i),lo(o),xw(e,r,s,o,i,"max")}}return n.className="MaxPooling1D",n})()),de((()=>{class n extends h6{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return qn(i),lo(o),xw(e,r,s,o,i,"avg")}}return n.className="AveragePooling1D",n})());class p6 extends vt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Cr(this.poolSize,"poolSize"),Cr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,qn(this.dataFormat),lo(this.padding),this.inputSpec=[new hr({ndim:4})]}computeOutputShape(t){t=Vt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=vi(e,this.poolSize[0],this.padding,this.strides[0]),r=vi(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return te(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ze(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}de((()=>{class n extends p6{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return qn(i),lo(o),xw(e,r,s,o,i,"max")}}return n.className="MaxPooling2D",n})()),de((()=>{class n extends p6{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return qn(i),lo(o),xw(e,r,s,o,i,"avg")}}return n.className="AveragePooling2D",n})());class f6 extends vt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Cr(this.poolSize,"poolSize"),Cr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,qn(this.dataFormat),lo(this.padding),this.inputSpec=[new hr({ndim:5})]}computeOutputShape(t){t=Vt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=vi(e,this.poolSize[0],this.padding,this.strides[0]),r=vi(r,this.poolSize[1],this.padding,this.strides[1]),s=vi(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return te(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ze(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}de((()=>{class n extends f6{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return qn(i),lo(o),d6(e,r,s,o,i,"max")}}return n.className="MaxPooling3D",n})()),de((()=>{class n extends f6{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return qn(i),lo(o),d6(e,r,s,o,i,"avg")}}return n.className="AveragePooling3D",n})());class m6 extends vt{constructor(t){super(t),this.inputSpec=[new hr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new nt}}de((()=>{class n extends m6{constructor(e){super(e||{})}call(e,r){return te(()=>{const s=Ze(e);return Gn(s,1)})}}return n.className="GlobalAveragePooling1D",n})()),de((()=>{class n extends m6{constructor(e){super(e||{})}call(e,r){return te(()=>{const s=Ze(e);return fi(s,1)})}}return n.className="GlobalMaxPooling1D",n})());class g6 extends vt{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,qn(this.dataFormat),this.inputSpec=[new hr({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new nt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}de((()=>{class n extends g6{call(e,r){return te(()=>{const s=Ze(e);return Gn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),de((()=>{class n extends g6{call(e,r){return te(()=>{const s=Ze(e);return fi(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class y6 extends vt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const o=La(e.layer,r);delete e.layer;const i={layer:o};return Object.assign(i,e),new t(i)}}de((()=>{class n extends y6{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Vt(e)).length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Vt(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return te(()=>o6((a,l)=>[Ze(this.layer.call(a,r)),[]],e=Ze(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),de((()=>{class n extends y6{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=La(s),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=e.layer.getClassName(),o.config=r,this.backwardLayer=La(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function DEe(n){cc(J1e,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new nt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,o,i,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(i=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,o=[s]):o=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Ts(o)}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=s6(e,s,o,this.numConstants);if(e=i.inputs,s=i.initialState,o=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==o)return super.apply(e,r);const a=[],l=[];if(null!=s){const c=s.length;if(c%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new hr({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=o)throw new nt("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof ea;for(const c of a)if(c instanceof ea!==u)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,r);return this.inputSpec=h,p}return super.apply(e,r)}call(e,r){return te(()=>{const s=r.initialState;let o,i,a,l;if(null==s)o=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);o=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=oc(i,1)),"concat"===this.mergeMode?l=CN([o,i]):"sum"===this.mergeMode?l=fe(o,i):"ave"===this.mergeMode?l=L(.5,fe(o,i)):"mul"===this.mergeMode?l=L(o,i):null==this.mergeMode&&(l=[o,i]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){dc(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),dc(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=La(r.layer);if(delete r.layer,null!=r.numConstants)throw new nt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=s,new e(o)}}return n.className="Bidirectional",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return te(()=>("float32"!==(e=Ze(e)).dtype&&(e=Zi(e,"float32")),fe(L(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:REe,cropAndResize:$Ee}=Bl;de((()=>{class n extends vt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,o,i,a,l,u){return te(()=>{let c,d=!1;const g=[r/a,s/l,(o+r)/a,(i+s)/l],y=[];3===e.rank?(d=!0,c=Oa([e])):c=e;for(let S=0;S<c.shape[0];S++)y.push(g);const b=Zu(y,[y.length,4]),_=Bm(0,y.length,1,"int32"),w=$Ee(c,b,_,[o,i],"nearest");return Zi(d?Ze(ic(w)):w,u)})}upsize(e,r,s,o){return te(()=>Zi(REe(e,[r,s]),o))}call(e,r){return te(()=>{const s=Ze(e),o=s.dtype,i=s.shape,a=i[i.length-3],l=i[i.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),0===c&&(c=1)),u>=0&&c>=0?this.centerCrop(s,u,c,this.height,this.width,a,l,o):this.upsize(e,this.height,this.width,o)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=Vt(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return n.className="CenterCrop",n})()),de((()=>{class n extends vt{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=Vt(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return te(()=>{let s;if("int32"!==(e=Ze(e)).dtype&&(e=Zi(e,"int32")),void 0!==r.countWeights){if("count"!==this.outputMode)throw new z(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=Ze(r.countWeights)}const o=fi(e),i=Bv(e),a=so(this.numTokens,o).bufferSync().get(0),l=sc(i,0).bufferSync().get(0);if(!a||!l)throw new z(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function OEe(n,t,e,r){let s=Ze(n);if("int32"!==s.dtype&&(s=Zi(s,"int32")),"int"===t)return s;const o=s.shape;if(0===s.rank&&(s=xs(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=xs(s,-1)),s.rank>2)throw new z(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${o} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t);let l;if(l=MG(s,void 0!==r&&"count"===t?r:[],e,i),"tfIdf"!==t)return l;if(r)return L(l,r);throw new z("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return n.className="CategoryEncoding",n})());const b6=new Set(["bilinear","nearest"]);var S6;function Cw(n,t,e=new Map,r=new Set){if(null==n)return null;if("function"==typeof Blob&&n instanceof Blob)return n.slice();if(r.has(n))throw new Error("Circular references are not supported.");if(e.has(n))return e.get(n);const s=t(n);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(mh(n)){const o=Array.isArray(n)?[]:{};r.add(n);for(const i in n){const l=Cw(n[i],t,e,r);o[i]=l}return r.delete(n),n.__proto__&&(o.__proto__=n.__proto__),o}throw new Error(`Can't recurse into non-iterable type: ${n}`)}return e.set(n,s.value),s.value}function ZEe(n,t=H6){return G6(n,t)}function G6(n,t,e=new Set){const r=n[0];if(e.has(r))throw new Error("Circular references are not supported.");const s=t(n);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(mh(r)){const o=Array.isArray(r)?[]:{};e.add(r);for(const i in r){const l=G6(n.map(u=>u[i]),t,e);o[i]=l}return e.delete(r),o}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function H6(n){return null===n?null:mh(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}function mh(n){let t=!1;if(ee().get("IS_BROWSER"))t=n instanceof TextDecoder;else{const{StringDecoder:e}=K(401);t=n instanceof e}return null!=n&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||"object"==typeof n&&!(n instanceof yn)&&!(n instanceof Promise)&&!t)}function eIe(n){return function YEe(n,t){return Cw(n,t)}(n,tIe)}function tIe(n){return n instanceof yn?{value:n.clone(),recurse:!1}:mh(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}de((()=>{class n extends vt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!b6.has(e.interpolation))throw new z(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=Vt(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return te(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return Bl.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Bl.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...b6]} are supported`)})}}return n.className="Resizing",n})()),ee().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(S6||(S6={}));class q6{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),r=this.get(e);return this.set(e,this.pop()),r}}let nIe=(()=>{class n extends q6{constructor(){super(n.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,r=new Array(e),s=this.length();for(let o=0;o<s;o++)r[o]=this.get(this.wrap(this.begin+o));this.data=r,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}return n.INITIAL_CAPACITY=32,n})();class Er{toArray(){var t=this;return $(function*(){const e=[];let r=yield t.next();for(;!r.done;)e.push(r.value),r=yield t.next();return e})()}toArrayForTest(){var t=this;return $(function*(){const e=t.prefetch(100),r=[];let s=yield e.next();for(;!s.done;)r.push(s.value),s=yield e.next();return r})()}resolveFully(){var t=this;return $(function*(){let e=yield t.next();for(;!e.done;)e=yield t.next()})()}resolveWhile(t){var e=this;return $(function*(){let r=yield e.next(),s=t(r.value);for(;!r.done&&s;)r=yield e.next(),s=t(r.value)})()}handleErrors(t){return new hIe(this,t)}filter(t){return new cIe(this,t)}map(t){return new dIe(this,t)}mapAsync(t){return new Y6(this,t)}serialMapAsync(t){return new Y6(this,t).serial()}flatmap(t){return new pIe(this,t)}forEachAsync(t){var e=this;return $(function*(){return e.map(t).resolveFully()})()}serialForEach(t){var e=this;return $(function*(){return e.serialMapAsync(t).resolveWhile(r=>!0===r)})()}rowMajorBatch(t,e=!0){return new uIe(this,t,e)}columnMajorBatch(t,e=!0,r=H6){return this.rowMajorBatch(t,e).map(o=>ZEe(o,r))}concatenate(t,e){return new Z6(function K6(n){return new sIe(n)}([this,t]),e)}take(t){return t<0||null==t?this:new lIe(this,t)}skip(t){return t<0||null==t?this:new aIe(this,t)}prefetch(t){return new Q6(this,t)}shuffle(t,e){return new mIe(this,t,e)}serial(){return new iIe(this)}}class sIe extends Er{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var t=this;return $(function*(){if(t.trav>=t.items.length)return{value:null,done:!0};const e=t.items[t.trav];return t.trav++,{value:eIe(e),done:!1}})()}}class iIe extends Er{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var t=this;return $(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return $(function*(){return t.upstream.next()})()}}class aIe extends Er{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var t=this;return $(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return $(function*(){for(;t.count++<t.maxCount;){const e=yield t.upstream.next();if(e.done)return e;mt(e.value)}return t.upstream.next()})()}}class lIe extends Er{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var t=this;return $(function*(){return t.count++>=t.maxCount?{value:null,done:!0}:t.upstream.next()})()}}class uIe extends Er{constructor(t,e,r=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var t=this;return $(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return $(function*(){const e=[];for(;e.length<t.batchSize;){const r=yield t.upstream.next();if(r.done)return t.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(r.value)}return{value:e,done:!1}})()}}class cIe extends Er{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var t=this;return $(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return $(function*(){for(;;){const e=yield t.upstream.next();if(e.done||t.predicate(e.value))return e;mt(e.value)}})()}}class dIe extends Er{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}next(){var t=this;return $(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const r=Rl(e.value),s=t.transform(e.value),o=Rl(s);for(const i of r)BI(i,o)||i.dispose();return{value:s,done:!1}})()}}class hIe extends Er{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var t=this;return $(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return $(function*(){for(;;)try{return yield t.upstream.next()}catch(e){if(!t.handler(e))return{value:null,done:!0}}})()}}class Y6 extends Er{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var t=this;return $(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const r=Rl(e.value),s=yield t.transform(e.value),o=Rl(s);for(const i of r)BI(i,o)||i.dispose();return{value:s,done:!1}})()}}class pD extends Er{constructor(){super(),this.outputQueue=new nIe,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return $(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return $(function*(){for(;0===t.outputQueue.length();)if(!(yield t.pump()))return{value:null,done:!0};return{value:t.outputQueue.shift(),done:!1}})()}}class pIe extends pD{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var t=this;return $(function*(){const e=yield t.upstream.next();if(e.done)return!1;const r=Rl(e.value),s=t.transform(e.value),o=Rl(s);t.outputQueue.pushAll(s);for(const i of r)BI(i,o)||i.dispose();return!0})()}}class Z6 extends Er{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var t=this;return $(function*(){return t.lastRead=t.readFromChain(t.lastRead),t.lastRead})()}readFromChain(t){var e=this;return $(function*(){if(yield t,null==e.iterator){const s=yield e.moreIterators.next();if(s.done)return{value:null,done:!0};e.iterator=s.value,null!=e.baseErrorHandler&&(e.iterator=e.iterator.handleErrors(e.baseErrorHandler))}const r=yield e.iterator.next();return r.done?(e.iterator=null,e.readFromChain(t)):r})()}}class Q6 extends Er{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new q6(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class mIe extends Q6{constructor(t,e,r){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=xl.alea(r||Hr().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return $(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var t=this;return $(function*(){for(t.upstreamExhausted||t.refill();!t.buffer.isEmpty();){const e=t.chooseIndex(),r=yield t.buffer.shuffleExcise(e);if(!r.done)return t.refill(),r;t.upstreamExhausted=!0}return{value:null,done:!0}})()}}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");class gD extends Er{constructor(t,e){if(super(),this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ss([0],"int32"),this.webcamConfig.centerCrop){const r=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,s=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,o=(1-r)/2,i=(1-s)/2;this.cropBox=oh([i,o,s+i,o+r],[1,4])}else this.cropBox=oh([0,0,1,1],[1,4])}summary(){return"webcam"}static create(t,e={}){return $(function*(){if(!ee().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}const r=new gD(t,e);return yield r.start(),r})()}start(){var t=this;return $(function*(){t.webcamConfig.facingMode&&C("user"===t.webcamConfig.facingMode||"environment"===t.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${t.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{t.stream=yield navigator.mediaDevices.getUserMedia({video:{deviceId:t.webcamConfig.deviceId,facingMode:t.webcamConfig.facingMode?t.webcamConfig.facingMode:"user",width:t.webcamVideoElement.width,height:t.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!t.stream)throw new Error("Could not obtain video from webcam.");try{t.webcamVideoElement.srcObject=t.stream}catch(e){console.log(e),t.webcamVideoElement.src=window.URL.createObjectURL(t.stream)}return t.webcamVideoElement.play(),t.isClosed=!1,new Promise(e=>{t.webcamVideoElement.onloadedmetadata=()=>{e()}})})()}next(){var t=this;return $(function*(){if(t.isClosed)return{value:null,done:!0};let e;try{e=g_e(t.webcamVideoElement)}catch(r){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(r)}`)}if(!t.resize)return{value:e,done:!1};try{return{value:t.cropAndResizeFrame(e),done:!1}}catch(r){throw new Error(`Error thrown cropping the video: ${r.message}`)}finally{e.dispose()}})()}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(t){return te(()=>{const e=xs(Se(t,"float32"),0);let r;return r=Bl.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear"),H(r,r.shape.slice(1))})}capture(){var t=this;return $(function*(){return(yield t.next()).value})()}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}function bD(){return(bD=$(function*(n,t){return gD.create(n,t)})).apply(this,arguments)}function Re(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&C("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const AIe=FH;let RIe=(()=>{class n extends NE{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new cW(this,ji())}nextDataId(){return n.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,ee().get("IS_NODE")&&to("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&Df(s[0])){const i=s.map(a=>Dl(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return $(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?Ma(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):function Iye(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>Al(o));return _t(e.shape,e.dtype,s)}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return _t(e.shape,e.dtype,r)}makeOutput(e,r,s){return ji().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return $(function*(){const r=Hr();return e(),{kernelMs:Hr()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Re([e],"where");const r=this.readSync(e.dataId);return AIe(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function Ht(n,t,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(Re(i,n),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,l=a.data.get(i.dataId).values,u=ne(i.shape),c=e||i.dtype,d=Jn(c,u);for(let h=0;h<u;++h)d[h]=t(l[h],s);return a.makeTensorInfo(i.shape,c,d)}}function gh(n,t,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(Re(i,n),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,l=a.data.get(i.dataId).values,u=e||i.dtype,c=t(l,u,s);return a.makeTensorInfo(i.shape,u,c)}}iG("cpu",()=>new RIe,1);const o8=Ht(Hf,n=>n>=0?n:Math.exp(n)-1),OIe={kernelName:Hf,backendName:"cpu",kernelFunc:o8};function na(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const FIe={kernelName:Qf,backendName:"cpu",kernelFunc:na};function i8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r;Re([s],"leakyRelu");const i=ne(s.shape),a=e.data.get(s.dataId).values,l=Ar("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(s.shape,"float32",l)}const MIe={kernelName:V_,backendName:"cpu",kernelFunc:i8};function er(n){return(t,e,r,s,o)=>{const i=tt(t,e),a=i.length,l=Be(i),c=Ar(o,ne(i)),d=t.length,h=e.length,p=Be(t),f=Be(e),m=nh(t,i),g=nh(e,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const b=Hd(y,a,l),_=b.slice(-d);m.forEach(T=>_[T]=0);const v=Gi(_,d,p),w=b.slice(-h);g.forEach(T=>w[T]=0);const S=Gi(w,h,f);c[y]=n(r[v],s[S])}return[c,i]}}const PIe=er((n,t)=>n<0?t*n:n);function a8(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;Re([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,l]=PIe(r.shape,s.shape,o,i,"float32");return e.makeTensorInfo(l,"float32",a)}const LIe={kernelName:sv,backendName:"cpu",kernelFunc:a8},l8=Ht(cm,n=>Math.max(0,n)),VIe={kernelName:cm,backendName:"cpu",kernelFunc:l8},u8=Ht(dm,n=>Math.min(Math.max(0,n),6)),BIe={kernelName:dm,backendName:"cpu",kernelFunc:u8};function Xl(n){return(t,e,r)=>{const s=Ar(e,t.length);for(let o=0;o<t.length;++o)s[o]=n(t[o],r);return s}}const zIe=Xl(n=>1/(1+Math.exp(-n))),c8=Ht(bm,n=>1/(1+Math.exp(-n))),UIe={kernelName:bm,backendName:"cpu",kernelFunc:c8};function Nw(n,t,e,r,s){if("linear"===e)return na({inputs:{x:t},backend:n});if("relu"===e)return l8({inputs:{x:t},backend:n});if("elu"===e)return o8({inputs:{x:t},backend:n});if("relu6"===e)return u8({inputs:{x:t},backend:n});if("prelu"===e)return a8({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return i8({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return c8({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Ls(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const WIe={kernelName:HE,backendName:"cpu",kernelFunc:Ls};function Dw(n,t,e="float32"){if("complex64"===e)return Ls({inputs:{real:Dw(n,t,"float32"),imag:Dw(n,t,"float32")},backend:n});const r=Gr(ne(t),e);return n.makeTensorInfo(t,e,r)}function mc(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const GIe={kernelName:gI,backendName:"cpu",kernelFunc:mc};function d8(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=Ku([0],e),[o,i]=er((a,l)=>a!==l?1:0)(t,[],n,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Yl(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return na({inputs:{x:s},backend:e});const c=Dw(e,s.shape,s.dtype),d=Yl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),h=Ls({inputs:{real:d,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const c=mc({inputs:{input:s},backend:e}),d=Yl({inputs:{x:c},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(c),d}if(!fW(s.dtype,o)){const c=na({inputs:{x:s},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=e.data.get(s.dataId).values,[a,l,u]=d8(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}const HIe={kernelName:Vf,backendName:"cpu",kernelFunc:Yl};function Ir(n,t,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;Re([i,a],n);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d="string"===i.dtype?ac(u):u,h="string"===i.dtype?ac(c):c,p=r||i.dtype,[f,m]=t(i.shape,a.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const u=Yl({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,p=l.data.get(c.complexTensorInfos.real.dataId).values,f=l.data.get(h.dataId).values,m=Yl({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),b=g.complexTensorInfos.imag,_=l.data.get(g.complexTensorInfos.real.dataId).values,v=l.data.get(b.dataId).values,[w,S,T]=e(i.shape,a.shape,p,f,_,v),I=l.makeTensorInfo(T,"float32",w),N=l.makeTensorInfo(T,"float32",S),R=Ls({inputs:{real:I,imag:N},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(N),R}{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,p]=t(i.shape,a.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function vD(n){return(t,e,r,s,o,i)=>{const a=tt(t,e),l=ne(a),u=a.length,c=Be(a),d=Ar("float32",l),h=Ar("float32",l),p=nh(t,a),f=nh(e,a),m=Ma(r,s),g=Ma(o,i),y=t.length,b=Be(t),_=e.length,v=Be(e);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const S=w%m.length,T=w%g.length,I=n(m[2*S],m[2*S+1],g[2*T],g[2*T+1]);d[w]=I.real,h[w]=I.imag}else for(let w=0;w<d.length;w++){const S=Hd(w,u,c),T=S.slice(-y);p.forEach(j=>T[j]=0);const I=Gi(T,y,b),N=S.slice(-_);f.forEach(j=>N[j]=0);const R=Gi(N,_,v),F=n(m[2*I],m[2*I+1],g[2*R],g[2*R+1]);d[w]=F.real,h[w]=F.imag}return[d,h,a]}}const h8=er((n,t)=>n+t),jIe=vD((n,t,e,r)=>({real:n+e,imag:t+r})),yh=Ir(jd,h8,jIe),qIe={kernelName:jd,backendName:"cpu",kernelFunc:yh};function cn(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,i=ne(s.shape),a=pW(o,i),l=ne(a);C(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const u=e.data.get(s.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const KIe={kernelName:iv,backendName:"cpu",kernelFunc:cn};function p8(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;Re([s,o],"matMul");const l=s.shape.length,u=o.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[u-1]:o.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=a?o.shape[u-2]:o.shape[u-1],f=s.shape.slice(0,-2),m=o.shape.slice(0,-2),g=ne(f),y=ne(m),_=tt(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);C(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const w=a?[y,p,d]:[y,d,p],S=cn({inputs:{x:s},backend:e,attrs:{shape:i?[g,c,h]:[g,h,c]}}),T=cn({inputs:{x:o},backend:e,attrs:{shape:w}}),I=i?S.shape[1]:S.shape[2],N=i?S.shape[2]:S.shape[1],R=a?T.shape[1]:T.shape[2],F=Math.max(g,y),j=e.data.get(S.dataId).values,q=e.data.get(T.dataId).values,X=Be(S.shape),Q=Be(T.shape),[V,G,W]=i?[X[0],1,X[1]]:[X[0],X[1],1],[Y,se,le]=a?[1,Q[1],Q[0]]:[Q[1],1,Q[0]],pe=N*R,he=_t([F,N,R],S.dtype),me=he.values,be=e.blockSize;for(let Ne=0;Ne<F;Ne++){const Ee=Ne%g,Ue=Ne%y;for(let Ve=0;Ve<N;Ve+=be){const Ke=Math.min(Ve+be,N);for(let rt=0;rt<R;rt+=be){const jt=Math.min(rt+be,R);for(let hn=0;hn<I;hn+=be){const Vn=Math.min(hn+be,I);for(let pn=Ve;pn<Ke;pn++)for(let Zt=rt;Zt<jt;Zt++){let $n=0;for(let xn=hn;xn<Vn;xn++)$n+=j[Ee*V+pn*G+xn*W]*q[xn*Y+Zt*se+Ue*le];me[Ne*pe+(pn*R+Zt)]+=$n}}}}}return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),e.makeTensorInfo(_,he.dtype,he.values)}const XIe={kernelName:T_,backendName:"cpu",kernelFunc:p8},ZIe={kernelName:_v,backendName:"cpu",kernelFunc:function YIe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=p8({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(p=yh({inputs:{a:h,b:i},backend:e}),m.push(h),h=p),c&&(f=Nw(e,h,c,a,d),m.push(h),h=f);for(const y of m)e.disposeIntermediateTensorInfo(y);return h}};function f8(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const QIe={kernelName:__,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Re(t,"abs");let r=new Float32Array(ne(t.shape));return r=f8(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},JIe=Ht(Rf,n=>Math.acos(n)),eke={kernelName:Rf,backendName:"cpu",kernelFunc:JIe},tke=Ht($f,n=>Math.acosh(n)),nke={kernelName:$f,backendName:"cpu",kernelFunc:tke},ske={kernelName:VE,backendName:"cpu",kernelFunc:function rke(n){const{inputs:t,backend:e}=n,r=t;Re(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=_t(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function wD(n,t,e,r,s){const o=t.length,i=ne(t),a=Be(t),l=Be(s),u=Ar(e,ne(s));for(let c=0;c<i;++c){const d=Hd(c,o,a),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];u[Gi(h,o,l)]=n[c]}return u}function Es(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:o}=e;Re(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const u=wD(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const oke={kernelName:qd,backendName:"cpu",kernelFunc:Es},ake={kernelName:"All",backendName:"cpu",kernelFunc:function ike(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Re(s,"all");const a=bt(o,s.shape);let l=a;const u=Dn(l,s.shape.length);let c=s;null!=u&&(c=Es({inputs:{x:s},backend:e,attrs:{perm:u}}),l=jn(l.length,s.shape.length)),$r("all",l,c.shape.length);const[d,h]=Sr(c.shape,l),p=ne(h),f=Gr(ne(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let _=m[b];for(let v=0;v<p;++v){const w=m[b+v];_=_&&w}f[y]=_}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,f);if(i){const b=cn({inputs:{x:g},backend:e,attrs:{shape:Hn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},uke={kernelName:"Any",backendName:"cpu",kernelFunc:function lke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Re(s,"any");const a=bt(o,s.shape);let l=a;const u=Dn(l,s.shape.length);let c=s;null!=u&&(c=Es({inputs:{x:s},backend:e,attrs:{perm:u}}),l=jn(l.length,s.shape.length)),$r("any",l,c.shape.length);const[d,h]=Sr(c.shape,l),p=ne(h),f=Gr(ne(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let _=m[b];for(let v=0;v<p;++v){const w=m[b+v];_=_||w}f[y]=_}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,f);if(i){const b=cn({inputs:{x:g},backend:e,attrs:{shape:Hn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},dke={kernelName:v_,backendName:"cpu",kernelFunc:function cke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;Re(s,"argMax");let i=bt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Es({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=jn(i.length,l.shape.length)),i=[i[0]],$r("argMax",i,l.shape.length);const[c,d]=Sr(l.shape,i),p=Gr(ne(c),"int32"),f=ne(d),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],_=0;for(let v=0;v<f;++v){const w=m[y+v];w>b&&(b=w,_=v)}p[g]=_}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",p)}},pke={kernelName:w_,backendName:"cpu",kernelFunc:function hke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;Re(s,"argMin");let i=bt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Es({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=jn(i.length,l.shape.length)),i=[i[0]],$r("argMin",i,l.shape.length);const[c,d]=Sr(l.shape,i),p=Gr(ne(c),"int32"),f=ne(d),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],_=0;for(let v=0;v<f;++v){const w=m[y+v];w<b&&(b=w,_=v)}p[g]=_}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",p)}},fke=Ht(Of,n=>Math.asin(n)),mke={kernelName:Of,backendName:"cpu",kernelFunc:fke},gke=Ht(Ff,n=>Math.asinh(n)),yke={kernelName:Ff,backendName:"cpu",kernelFunc:gke},bke=Ht(Mf,n=>Math.atan(n)),_ke={kernelName:Mf,backendName:"cpu",kernelFunc:bke},vke=er((n,t)=>Math.atan2(n,t)),wke=Ir(Lf,vke),xke={kernelName:Lf,backendName:"cpu",kernelFunc:wke},Ske=Ht(Pf,n=>Math.atanh(n)),Tke={kernelName:Pf,backendName:"cpu",kernelFunc:Ske};function xD(n,t,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=_t(s.outShape,e),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],_=s.outShape[3];for(let v=0;v<s.batchSize;++v){const w=v*y,S=v*r[0];for(let T=0;T<s.inChannels;++T)for(let I=0;I<s.outHeight;++I){const N=I*i-h,R=Math.max(0,N),F=Math.min(s.inHeight,c+N),j=w+I*b;for(let q=0;q<s.outWidth;++q){const X=q*a-p,Q=Math.max(0,X),V=Math.min(s.inWidth,d+X);let G=f,W=0,Y=0;for(let le=R;le<F;le+=l){const pe=S+le*r[1];for(let he=Q;he<V;he+=u){const be=n[pe+he*r[2]+T];"max"===o&&be>G?G=be:"avg"===o&&(W+=be,Y++)}if(isNaN(G))break}g[j+q*_+T]="avg"===o?W/Y:G}}}return m}function m8(n,t,e,r,s=!1,o=!1){const i=_t(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=_t(t,e,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const _=b*a-p;let v=_;for(;v<0;)v+=u;const w=Math.min(r.inHeight,d+_);for(let S=0;S<r.outWidth;++S){const T=S*l-f;let I=T;for(;I<0;)I+=c;const N=Math.min(r.inWidth,h+T);let R=Number.NEGATIVE_INFINITY,F=-1;for(let j=v;j<w;j+=u){const q=j-_;for(let X=I;X<N;X+=c){const Q=X-T,V=m.get(g,j,X,y);V>R&&(R=V,F=s?o?((g*r.inHeight+j)*r.inWidth+X)*r.inChannels+y:(j*r.inWidth+X)*r.inChannels+y:q*h+Q)}}i.set(F,g,b,S,y)}}return i}function g8(n,t,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=_t(s.outShape,e),v=_.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[2]*s.outShape[3]*s.outShape[4],T=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let N=0;N<s.batchSize;++N){const R=N*w,F=N*r[0];for(let j=0;j<s.inChannels;++j)for(let q=0;q<s.outDepth;++q){const X=q*i-m;let Q=X;for(;Q<0;)Q+=u;const V=Math.min(s.inDepth,h+X),G=R+q*S;for(let W=0;W<s.outHeight;++W){const Y=W*a-g;let se=Y;for(;se<0;)se+=c;const le=Math.min(s.inHeight,p+Y),pe=G+W*T;for(let he=0;he<s.outWidth;++he){const me=he*l-y;let be=me;for(;be<0;)be+=d;const Ne=Math.min(s.inWidth,f+me),Ee=pe+he*I;let Ue=b,Ve=0,Ke=0;for(let jt=Q;jt<V;jt+=u){const hn=F+jt*r[1];for(let Vn=se;Vn<le;Vn+=c){const pn=hn+Vn*r[2];for(let Zt=be;Zt<Ne;Zt+=d){const xn=n[pn+Zt*r[3]+j];if("max"===o&&xn>Ue?Ue=xn:"avg"===o&&(Ve+=xn,Ke++),isNaN(Ue))break}if(isNaN(Ue))break}if(isNaN(Ue))break}v[Ee+j]="avg"===o?Ve/Math.max(Ke,1):Ue}}}}return _}const Ike={kernelName:x_,backendName:"cpu",kernelFunc:function Eke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Re(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;C(Rr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fo(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))d=na({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,p=Be(s.shape),f=xD(h,0,s.dtype,p,c,"avg");d=e.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}},Nke={kernelName:S_,backendName:"cpu",kernelFunc:function kke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Re(s,"avgPool3d");const c=Da(s.shape,o,i,1,a,l,u),h=g8(e.data.get(s.dataId).values,0,s.dtype,Be(s.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},Ake={kernelName:WE,backendName:"cpu",kernelFunc:function Dke(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Re([s,o],"avgPool3DGrad");const c=Da(o.shape,i,a,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,_=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,S=c.effectiveFilterWidth,T=v-1-c.padInfo.front,I=S-1-c.padInfo.left,N=w-1-c.padInfo.top,R=_t(o.shape,"float32"),F=1/(f*m*g),j=e.bufferSync(s);for(let q=0;q<c.batchSize;++q)for(let X=0;X<c.inChannels;++X)for(let Q=0;Q<c.inDepth;++Q)for(let V=0;V<c.inHeight;++V)for(let G=0;G<c.inWidth;++G){const W=Q-T,Y=V-N,se=G-I;let le=0;for(let pe=0;pe<v;pe+=y){const he=(W+pe)/d;if(!(he<0||he>=c.outDepth||Math.floor(he)!==he))for(let me=0;me<w;me+=b){const be=(Y+me)/h;if(!(be<0||be>=c.outHeight||Math.floor(be)!==be))for(let Ne=0;Ne<S;Ne+=_){const Ee=(se+Ne)/p;Ee<0||Ee>=c.outWidth||Math.floor(Ee)!==Ee||(le+=j.get(q,he,be,Ee,X))}}}R.set(le*F,q,Q,V,G,X)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}},$ke={kernelName:UE,backendName:"cpu",kernelFunc:function Rke(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o;Re([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Fo(i.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,_=b-1-c.padInfo.left,v=y-1-c.padInfo.top,w=_t(i.shape,"float32"),S=1/(p*f),T=e.data.get(s.dataId).values,I=_t(s.shape,"float32",T);for(let N=0;N<c.batchSize;++N)for(let R=0;R<c.inChannels;++R)for(let F=0;F<c.inHeight;++F)for(let j=0;j<c.inWidth;++j){const q=F-v,X=j-_;let Q=0;for(let V=0;V<y;V+=m){const G=(q+V)/d;if(!(G<0||G>=c.outHeight||Math.floor(G)!==G))for(let W=0;W<b;W+=g){const Y=(X+W)/h;Y<0||Y>=c.outWidth||Math.floor(Y)!==Y||(Q+=I.get(N,G,Y,R))}}w.set(Q*S,N,F,j,R)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},Fke={kernelName:M_,backendName:"cpu",kernelFunc:function Oke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:o,offset:i,mean:a,variance:l}=t;C(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Re([s,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,p=o?e.data.get(o.dataId).values:new Float32Array([1]),f=i?e.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,_=d.length;let v=0,w=0,S=0,T=0;for(let I=0;I<c.length;++I)m[I]=f[v++]+(c[I]-d[w++])*p[S++]/Math.sqrt(h[T++]+u),v>=g&&(v=0),w>=_&&(w=0),S>=y&&(S=0),T>=b&&(T=0);return e.makeTensorInfo(s.shape,s.dtype,m)}};function y8(n,t,e,r,s){const o=fk(r,t,e),i=ne(e),a=Be(r);if(o){const d=mk(t,a);return"string"===s?n.slice(d,d+i):n.subarray(d,d+i)}const u=_t(r,s,"string"===s?ac(n):n),c=_t(e,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,m)=>f+t[m]);c.set(u.get(...p),...h)}return"string"===s?OH(c.values):c.values}function gc(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:i}=r;Re(s,"slice");const[a,l]=Fv(s,o,i);hk(s,a,l);const c=y8(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,c)}const Mke={kernelName:dv,backendName:"cpu",kernelFunc:gc},Lke={kernelName:C_,backendName:"cpu",kernelFunc:function Pke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:i}=r;Re([s],"batchToSpaceND");const a=o.reduce((y,b)=>y*b),l=Gm(s.shape,o,a),u=Hm(l.length,o.length),c=jm(s.shape,o,a),d=Yk(i,o.length),h=Zk(c,i,o.length),p=cn({inputs:{x:s},backend:e,attrs:{shape:l}}),f=Es({inputs:{x:p},backend:e,attrs:{perm:u}}),m=cn({inputs:{x:f},backend:e,attrs:{shape:c}}),g=gc({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}};function SD(n,t,e,r,s){const o=ne(r),i=Gr(s,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?t[a]:1)}return i}function b8(n,t,e,r=!1){const s=n.shape[0],o=n.shape[1],i=_t([s,e],t.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||i.set(r?1:t.size>0?i.get(a,u)+t.get(a,l):i.get(a,u)+1,a,u)}return i}const Bke={kernelName:GE,backendName:"cpu",kernelFunc:function Vke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i}=r,u=SD(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},Uke={kernelName:vW,backendName:"cpu",kernelFunc:function zke(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=tt(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},_8=Xl(n=>Math.ceil(n)),Wke=gh(Bf,_8),Gke={kernelName:Bf,backendName:"cpu",kernelFunc:Wke},Hke=Ht(zf,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),jke={kernelName:zf,backendName:"cpu",kernelFunc:Hke},qke={kernelName:E_,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(ne(t.shape)),s=e.data.get(t.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],l[u]);return e.makeOutput(r,t.shape,"float32")}};function v8(n,t,e,r){const s=Jn(e,ne(t));if(r&&"string"!==e){let o=0;n.forEach(i=>{const a=ne(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a="string"===e?ac(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*t[1]+o;for(let d=0;d<i.shape[1];++d)s[c+d]=a[l++]}o+=i.shape[1]})}return s}function bh(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const Kke={kernelName:lI,backendName:"cpu",kernelFunc:bh};function _h(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=bt(s,t[0].shape)[0];qk(t.map(m=>m.shape),o);let a=Xi(t.map(m=>m.shape),o);if(0===ne(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(m=>ne(m.shape)>0);if(1===l.length)return na({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const m=l.map(v=>mc({inputs:{input:v},backend:e})),g=l.map(v=>bh({inputs:{input:v},backend:e})),y=_h({inputs:m,backend:e,attrs:{axis:o}}),b=_h({inputs:g,backend:e,attrs:{axis:o}}),_=Ls({inputs:{real:y,imag:b},backend:e});return m.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),_}const u=l.map(m=>{const g=ne(m.shape.slice(o));return cn({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}})}),c=u.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=Xi(u.map(m=>m.shape),1);const h=v8(c,a,t[0].dtype,1===u[0].shape[0]),p=Xi(l.map(m=>m.shape),o),f=e.makeTensorInfo(p,t[0].dtype,h);return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}const Xke={kernelName:I_,backendName:"cpu",kernelFunc:_h};function w8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Re([s,o],"conv2d");const d=Aa(l),h=xr(s.shape,o.shape,i,u,a,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,_="channelsLast"===h.dataFormat,v=new jr(h.outShape,s.dtype),w=Be(s.shape),S=Be(o.shape),T=w[0],I=_?w[1]:w[2],N=_?w[2]:1,R=_?1:w[1],F=v.strides[0],j=_?v.strides[1]:v.strides[2],q=_?v.strides[2]:1,X=_?1:v.strides[1],Q=e.data.get(s.dataId).values,V=e.data.get(o.dataId).values,G=v.values;for(let W=0;W<h.batchSize;++W){const Y=W*T,se=W*F;for(let le=0;le<h.outHeight;++le){const pe=se+le*j,he=le*h.strideHeight-b;for(let me=0;me<p;++me){const be=he+me*m;if(be<0||be>=h.inHeight)continue;const Ne=me*S[0],Ee=Y+be*I;for(let Ue=0;Ue<h.outWidth;++Ue){const Ve=pe+Ue*q,Ke=Ue*h.strideWidth-y;for(let rt=0;rt<f;++rt){const jt=Ke+rt*g;if(jt<0||jt>=h.inWidth)continue;const Vn=Ee+jt*N;let pn=Ne+rt*S[1];for(let Zt=0;Zt<h.inChannels;++Zt){const $n=Q[Vn+Zt*R];for(let xn=0;xn<h.outChannels;++xn)G[Ve+xn*X]+=$n*V[pn+xn];pn+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,G)}const Yke={kernelName:k_,backendName:"cpu",kernelFunc:w8},Qke={kernelName:jE,backendName:"cpu",kernelFunc:function Zke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Re([s,o],"conv2dBackpropFilter");const d=Aa(l),h=xr(s.shape,c,i,1,a,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new jr(h.filterShape,"float32"),_=h.padInfo.left,v=h.padInfo.top,w=e.data.get(s.dataId).values,S=e.data.get(o.dataId).values,T=new jr(s.shape,s.dtype,w),I=new jr(o.shape,o.dtype,S);for(let N=0;N<m;++N){const R=Math.max(0,Math.ceil((v-N)/p)),F=Math.min(h.outHeight,(h.inHeight+v-N)/p);for(let j=0;j<g;++j){const q=Math.max(0,Math.ceil((_-j)/f)),X=Math.min(h.outWidth,(h.inWidth+_-j)/f);for(let Q=0;Q<h.inChannels;++Q)for(let V=0;V<h.outChannels;++V){let G=0;for(let W=0;W<h.batchSize;++W)for(let Y=R;Y<F;++Y){const se=N+Y*p-v;for(let le=q;le<X;++le){const pe=j+le*f-_;G+=y?T.get(W,se,pe,Q)*I.get(W,Y,le,V):T.get(W,Q,se,pe)*I.get(W,V,Y,le)}}b.set(G,N,j,Q,V)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},eNe={kernelName:N_,backendName:"cpu",kernelFunc:function Jke(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Re([s,o],"conv2dBackpropInput");const d=Be(o.shape),h=Be(s.shape);let p=Aa(u);const f=xr(i,o.shape,a,1,l,c,!1,p),m=new jr(f.inShape,"float32"),g=m.values,y=e.data.get(s.dataId).values,b=e.data.get(o.dataId).values,[_,v,w]=d,{batchSize:S,filterHeight:T,filterWidth:I,inChannels:N,inHeight:R,inWidth:F,outChannels:j,outHeight:q,outWidth:X,strideHeight:Q,strideWidth:V}=f;p=f.dataFormat;const G=T-1-f.padInfo.top,W=I-1-f.padInfo.left,Y="channelsLast"===p,se=m.strides[0],le=Y?m.strides[1]:m.strides[2],pe=Y?m.strides[2]:1,he=Y?1:m.strides[1],me=h[0],be=Y?h[1]:h[2],Ne=Y?h[2]:1,Ee=Y?1:h[1];for(let Ue=0;Ue<S;++Ue)for(let Ve=0;Ve<N;++Ve)for(let Ke=0;Ke<R;++Ke){const rt=Ke-G,jt=Math.max(0,Math.ceil(rt/Q)),hn=Math.min(q,(T+rt)/Q);for(let Vn=0;Vn<F;++Vn){const pn=Vn-W,Zt=Math.max(0,Math.ceil(pn/V)),$n=Math.min(X,(I+pn)/V);let xn=0;for(let Fr=jt;Fr<hn;++Fr){const ru=Fr*Q-rt;for(let fo=Zt;fo<$n;++fo){const xi=me*Ue+be*Fr+Ne*fo,Ga=_*(T-1-ru)+v*(I-1-(fo*V-pn))+w*Ve;for(let su=0;su<j;++su)xn+=y[xi+Ee*su]*b[Ga+su]}}g[se*Ue+le*Ke+pe*Vn+he*Ve]=xn}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},nNe={kernelName:D_,backendName:"cpu",kernelFunc:function tNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r;Re([s,o],"conv3d");const u=Ml(s.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,_=g.top,v=new jr(u.outShape,s.dtype),w=e.data.get(s.dataId).values,S=e.data.get(o.dataId).values,T=v.values,I=Be(s.shape),N=Be(o.shape);for(let R=0;R<u.batchSize;++R){const F=R*I[0],j=R*v.strides[0];for(let q=0;q<u.outDepth;++q){const X=j+q*v.strides[1],Q=q*u.strideDepth-y;for(let V=0;V<c;++V){const G=Q+V*p;if(G<0||G>=u.inDepth)continue;const W=V*N[0],Y=F+G*I[1];for(let se=0;se<u.outHeight;++se){const le=X+se*v.strides[2],pe=se*u.strideHeight-_;for(let he=0;he<d;++he){const me=pe+he*f;if(me<0||me>=u.inHeight)continue;const be=W+he*N[1],Ne=Y+me*I[2];for(let Ee=0;Ee<u.outWidth;++Ee){const Ue=le+Ee*u.outChannels,Ve=Ee*u.strideWidth-b;for(let Ke=0;Ke<h;++Ke){const rt=Ve+Ke*m;if(rt<0||rt>=u.inWidth)continue;const hn=Ne+rt*u.inChannels;let Vn=be+Ke*N[2];for(let pn=0;pn<u.inChannels;++pn){const Zt=w[hn+pn];for(let $n=0;$n<u.outChannels;++$n)T[Ue+$n]+=Zt*S[Vn+$n];Vn+=u.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},sNe={kernelName:qE,backendName:"cpu",kernelFunc:function rNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:l}=r;Re([s,o],"conv3dBackpropFilterV2");const u=Be(s.shape),c=Be(o.shape),d=Ml(s.shape,l,i,1,a),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new jr(d.filterShape,"float32"),_=b.values,[v,w,S,T]=b.strides,I=e.data.get(o.dataId).values,[N,R,F,j]=c,q=e.data.get(s.dataId).values,[X,Q,V,G]=u,W=d.padInfo.front,Y=d.padInfo.left,se=d.padInfo.top;for(let le=0;le<m;++le){const pe=Math.max(0,Math.ceil((W-le)/h)),he=Math.min(d.outDepth,(d.inDepth+W-le)/h),me=le*v;for(let be=0;be<g;++be){const Ne=Math.max(0,Math.ceil((se-be)/p)),Ee=Math.min(d.outHeight,(d.inHeight+se-be)/p),Ue=be*w+me;for(let Ve=0;Ve<y;++Ve){const Ke=Math.max(0,Math.ceil((Y-Ve)/f)),rt=Math.min(d.outWidth,(d.inWidth+Y-Ve)/f),jt=Ve*S+Ue;for(let hn=0;hn<d.inChannels;++hn){const Vn=hn*T+jt;for(let pn=0;pn<d.outChannels;++pn){let Zt=0;for(let $n=0;$n<d.batchSize;++$n){const xn=$n*X,Wa=$n*N;for(let Fr=pe;Fr<he;++Fr){const fo=(le+Fr*h-W)*Q+xn,Ec=Fr*R+Wa;for(let xi=Ne;xi<Ee;++xi){const su=(be+xi*p-se)*V+fo,ou=xi*F+Ec;for(let iu=Ke;iu<rt;++iu)Zt+=q[(Ve+iu*f-Y)*G+su+hn]*I[iu*j+ou+pn]}}}_[Vn+pn]=Zt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},iNe={kernelName:KE,backendName:"cpu",kernelFunc:function oNe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:l}=r;Re([s],"conv3dBackpropInputV2");const u=Be(s.shape),c=Be(o.shape),d=Ml(l,o.shape,a,1,i),h=new jr(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=e.data.get(s.dataId).values,[_,v,w,S]=u,T=e.data.get(o.dataId).values,[I,N,R,F]=c,{batchSize:j,filterDepth:q,filterHeight:X,filterWidth:Q,inChannels:V,inDepth:G,inHeight:W,inWidth:Y,outChannels:se,outDepth:le,outHeight:pe,outWidth:he,strideDepth:me,strideHeight:be,strideWidth:Ne}=d,Ee=q-1-d.padInfo.front,Ue=X-1-d.padInfo.top,Ve=Q-1-d.padInfo.left;for(let Ke=0;Ke<j;++Ke)for(let rt=0;rt<V;++rt)for(let jt=0;jt<G;++jt){const hn=jt-Ee,Vn=Math.max(0,Math.ceil(hn/me)),pn=Math.min(le,(q+hn)/me);for(let Zt=0;Zt<W;++Zt){const $n=Zt-Ue,xn=Math.max(0,Math.ceil($n/be)),Wa=Math.min(pe,(X+$n)/be);for(let Fr=0;Fr<Y;++Fr){const ru=Fr-Ve,fo=Math.max(0,Math.ceil(ru/Ne)),Ec=Math.min(he,(Q+ru)/Ne);let xi=0;for(let Ga=Vn;Ga<pn;++Ga){const su=Ga*me-hn;for(let ou=xn;ou<Wa;++ou){const iu=ou*be-$n;for(let Ag=fo;Ag<Ec;++Ag){const NA=_*Ke+v*Ga+w*ou+S*Ag,aHe=I*(q-1-su)+N*(X-1-iu)+R*(Q-1-(Ag*Ne-ru))+F*rt;for(let E0=0;E0<se;++E0)xi+=b[NA+E0]*T[aHe+E0]}}}p[f*Ke+m*jt+g*Zt+y*Fr+rt]=xi}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},aNe=Ht(Uf,n=>Math.cos(n)),lNe={kernelName:Uf,backendName:"cpu",kernelFunc:aNe},uNe=Ht(Wf,n=>Math.cosh(n)),cNe={kernelName:Wf,backendName:"cpu",kernelFunc:uNe},hNe={kernelName:YE,backendName:"cpu",kernelFunc:function dNe(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=o.shape[0],[m,g]=a,y=_t([f,m,g,p],"float32"),b=e.data.get(o.dataId).values,_=e.data.get(i.dataId).values,v=e.data.get(s.dataId).values,w=Be(s.shape),S=Be(y.shape);for(let T=0;T<f;T++){const I=4*T,N=b[I],R=b[I+1],F=b[I+2],j=b[I+3],q=_[T];if(q>=c)continue;const X=m>1?(F-N)*(d-1)/(m-1):0,Q=g>1?(j-R)*(h-1)/(g-1):0;for(let V=0;V<m;V++){const G=m>1?N*(d-1)+V*X:.5*(N+F)*(d-1);if(G<0||G>d-1)for(let W=0;W<g;W++)for(let Y=0;Y<p;Y++)y.values[Y+W*S[2]+V*S[1]+T*S[0]]=u;else if("bilinear"===l){const W=Math.floor(G),Y=Math.ceil(G),se=G-W;for(let le=0;le<g;le++){const pe=g>1?R*(h-1)+le*Q:.5*(R+j)*(h-1);if(pe<0||pe>h-1){for(let Ne=0;Ne<p;Ne++)y.values[Ne+le*S[2]+V*S[1]+T*S[0]]=u;continue}const he=Math.floor(pe),me=Math.ceil(pe),be=pe-he;for(let Ne=0;Ne<p;Ne++){let Ee=Ne+he*w[2]+W*w[1]+q*w[0];const Ue=v[Ee];Ee=Ne+me*w[2]+W*w[1]+q*w[0];const Ve=v[Ee];Ee=Ne+he*w[2]+Y*w[1]+q*w[0];const Ke=v[Ee];Ee=Ne+me*w[2]+Y*w[1]+q*w[0];const rt=v[Ee],jt=Ue+(Ve-Ue)*be;Ee=Ne+le*S[2]+V*S[1]+T*S[0],y.values[Ee]=jt+(Ke+(rt-Ke)*be-jt)*se}}}else for(let W=0;W<g;++W){const Y=g>1?R*(h-1)+W*Q:.5*(R+j)*(h-1);if(Y<0||Y>h-1){for(let pe=0;pe<p;pe++)y.values[pe+W*S[2]+V*S[1]+T*S[0]]=u;continue}const se=Math.round(Y),le=Math.round(G);for(let pe=0;pe<p;pe++)y.values[pe+W*S[2]+V*S[1]+T*S[0]]=v[pe+se*w[2]+le*w[1]+q*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},fNe={kernelName:XE,backendName:"cpu",kernelFunc:function pNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;Re(s,"cumprod");const l=Dn([o],s.shape.length);let u=s;null!=l&&(u=Es({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=jn(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Fs(u.dtype,"int32"),h=ME(ne(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const _=m(y,b);if(0===b)h[_]=i?1:p[_];else{const v=m(y,b-1);h[_]=i?p[v]*h[v]:p[_]*h[v]}}const g=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=Es({inputs:{x:g},backend:e,attrs:{perm:Ll(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(u),b}return g}},gNe={kernelName:A_,backendName:"cpu",kernelFunc:function mNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;Re(s,"cumsum");const l=Dn([o],s.shape.length);let u=s;null!=l&&(u=Es({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=jn(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Fs(u.dtype,"int32"),h=Gr(ne(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const _=m(y,b);if(0===b)h[_]=i?0:p[_];else{const v=m(y,b-1);h[_]=i?p[v]+h[v]:p[_]+h[v]}}const g=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=Es({inputs:{x:g},backend:e,attrs:{perm:Ll(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(u),b}return g}},bNe={kernelName:ZE,backendName:"cpu",kernelFunc:function yNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const c=SD(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const c=b8(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},vNe={kernelName:QE,backendName:"cpu",kernelFunc:function _Ne(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:i}=r;C("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*o,h=u*o,p=c/(o*o),f=e.data.get(s.dataId).values,m=new Float32Array(a*d*h*p);let g=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const _=Math.floor(b/o),v=b%o;for(let w=0;w<h;++w){const S=Math.floor(w/o),I=(v*o+w%o)*p;for(let N=0;N<p;++N)m[g++]=f[N+I+c*(S+u*(_+l*y))]}}return e.makeTensorInfo([a,d,h,p],s.dtype,m)}};function x8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Re([s,o],"depthwiseConv2DNative");const c=Be(s.shape),d=Be(o.shape);let h=l;null==h&&(h=[1,1]),C(Rr(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=xr(s.shape,o.shape,i,h,a,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,_=b.left,v=b.top,w=p.outChannels/p.inChannels,S=new jr(p.outShape,s.dtype),T=e.data.get(s.dataId).values,I=e.data.get(o.dataId).values,N=S.values;for(let R=0;R<p.batchSize;++R){const F=R*c[0],j=R*S.strides[0];for(let q=0;q<p.outHeight;++q){const X=j+q*S.strides[1],Q=q*p.strideHeight-v;for(let V=0;V<f;++V){const G=Q+V*g;if(G<0||G>=p.inHeight)continue;const W=V*d[0],Y=F+G*c[1];for(let se=0;se<p.outWidth;++se){const le=X+se*S.strides[2],pe=se*p.strideWidth-_;for(let he=0;he<m;++he){const me=pe+he*y;if(me<0||me>=p.inWidth)continue;const Ne=Y+me*p.inChannels;let Ee=le,Ue=W+he*d[1];for(let Ve=0;Ve<p.inChannels;++Ve){const Ke=T[Ne+Ve];for(let rt=0;rt<w;++rt)N[Ee+rt]+=Ke*I[Ue+rt];Ee+=w,Ue+=w}}}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const wNe={kernelName:R_,backendName:"cpu",kernelFunc:x8},SNe={kernelName:JE,backendName:"cpu",kernelFunc:function xNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Re([s,o],"depthwiseConv2dNativeBackpropFilter");const d=xr(s.shape,c,i,a,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new jr(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,_=d.outChannels/d.inChannels,v=e.data.get(s.dataId).values,w=new jr(s.shape,s.dtype,v),S=e.data.get(o.dataId).values,T=new jr(o.shape,o.dtype,S);for(let I=0;I<f;++I){const N=Math.max(0,Math.ceil((b-I)/h)),R=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let F=0;F<m;++F){const j=Math.max(0,Math.ceil((y-F)/p)),q=Math.min(d.outWidth,(d.inWidth+y-F)/p);for(let X=0;X<d.outChannels;++X){const Q=Math.trunc(X/_),V=X%_;let G=0;for(let W=0;W<d.batchSize;++W)for(let Y=N;Y<R;++Y){const se=I+Y*h-b;for(let le=j;le<q;++le)G+=w.get(W,se,F+le*p-y,Q)*T.get(W,Y,le,X)}g.set(G,I,F,Q,V)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},CNe={kernelName:eI,backendName:"cpu",kernelFunc:function TNe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Re([s,o],"depthwiseConv2DNativeBackpropInput");const d=Be(s.shape),h=Be(o.shape),p=xr(c,o.shape,i,a,l,u,!0),f=new jr(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,_=e.data.get(s.dataId).values,[v,w,S]=d,T=e.data.get(o.dataId).values,[I,N,R]=h,{batchSize:F,filterHeight:j,filterWidth:q,inChannels:X,inHeight:Q,inWidth:V,outChannels:G,outHeight:W,outWidth:Y,strideHeight:se,strideWidth:le}=p,pe=j-1-p.padInfo.top,he=q-1-p.padInfo.left,me=G/X;for(let be=0;be<F;++be)for(let Ne=0;Ne<X;++Ne)for(let Ee=0;Ee<Q;++Ee){const Ue=Ee-pe,Ve=Math.max(0,Math.ceil(Ue/se)),Ke=Math.min(W,(j+Ue)/se);for(let rt=0;rt<V;++rt){const jt=rt-he,hn=Math.max(0,Math.ceil(jt/le)),Vn=Math.min(Y,(q+jt)/le);let pn=0;for(let Zt=Ve;Zt<Ke;++Zt){const $n=Zt*se-Ue;for(let xn=hn;xn<Vn;++xn){const Fr=v*be+w*Zt+S*xn,ru=I*(j-1-$n)+N*(q-1-(xn*le-jt))+R*Ne;for(let fo=0;fo<me;++fo)pn+=_[Fr+(Ne*me+fo)]*T[ru+fo]}}m[g*be+y*Ee+b*rt+Ne]=pn}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}},INe={kernelName:"Diag",backendName:"cpu",kernelFunc:function ENe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=ne(r.shape),o=e.data.get(r.dataId).values,i=_t([s,s],r.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*s+u]=o[u];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}},kNe={kernelName:$_,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:o,pad:i,dilations:a}=e,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:_,strideHeight:v,strideWidth:w,filterHeight:S,filterWidth:T,dilationHeight:I,dilationWidth:N,outShape:R}=Fm(r.shape,s.shape,o,i,"NHWC",a),F=ne(R),j=R.length,q=Jn(r.dtype,F);for(let Q=0;Q<p;++Q)for(let V=0;V<y;++V){const G=V*v-_.top;for(let W=0;W<b;++W){const Y=W*w-_.left;for(let se=0;se<g;++se){let le=Number.MIN_SAFE_INTEGER;for(let he=0;he<S;++he){const me=G+he*I;if(me>=0&&me<f)for(let be=0;be<T;++be){const Ne=Y+be*N;if(Ne>=0&&Ne<m){const Ee=Gi([Q,me,Ne,se],c,Be(r.shape)),Ue=Gi([he,be,se],h,Be(s.shape)),Ve=u[Ee]+d[Ue];Ve>le&&(le=Ve)}}}q[Gi([Q,V,W,se],j,Be(R))]=le}}}return{dataId:l.write(Ku(q,r.dtype),R,r.dtype),shape:R,dtype:r.dtype}}},NNe={kernelName:nI,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:i,pad:a,dilations:l}=e,u=t,c=di(r.shape,u.data.get(r.dataId).values),d=di(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:S,dilationHeight:T,dilationWidth:I,outShape:N}=Fm(r.shape,s.shape,i,a,"NHWC",l);C(o.rank===N.length,()=>`Error in ${nI}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);const R=di(N,u.data.get(o.dataId).values),F=gW(s.shape,s.dtype);for(let q=0;q<h;++q)for(let X=0;X<g;++X){const Q=X*_-b.top;for(let V=0;V<y;++V){const G=V*v-b.left;for(let W=0;W<m;++W){let Y=Number.MIN_SAFE_INTEGER,se=0,le=0;for(let pe=0;pe<w;++pe){const he=Q+pe*T;if(he>=0&&he<p)for(let me=0;me<S;++me){const be=G+me*I;if(be>=0&&be<f){const Ne=c[q][he][be][W]+d[pe][me][W];Ne>Y&&(Y=Ne,se=pe,le=me)}}}F[se][le][W]+=R[q][X][V][W]}}}return{dataId:u.write(Ku(F,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},DNe={kernelName:tI,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:i,pad:a,dilations:l}=e,u=t,c=di(r.shape,u.data.get(r.dataId).values),d=di(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:S,dilationHeight:T,dilationWidth:I,outShape:N}=Fm(r.shape,s.shape,i,a,"NHWC",l);C(o.rank===N.length,()=>`Error in ${tI}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);const R=di(N,u.data.get(o.dataId).values),F=gW(r.shape,r.dtype);for(let q=0;q<h;++q)for(let X=0;X<g;++X){const Q=X*_-b.top;for(let V=0;V<y;++V){const G=V*v-b.left;for(let W=0;W<m;++W){let Y=Number.MIN_SAFE_INTEGER,se=Q<0?0:Q,le=G<0?0:G;for(let pe=0;pe<w;++pe){const he=Q+pe*T;if(he>=0&&he<p)for(let me=0;me<S;++me){const be=G+me*I;if(be>=0&&be<f){const Ne=c[q][he][be][W]+d[pe][me][W];Ne>Y&&(Y=Ne,se=he,le=be)}}}F[q][se][le][W]+=R[q][X][V][W]}}}return{dataId:u.write(Ku(F,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},TD=er((n,t)=>n*t),ANe=vD((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),Aw=Ir(am,TD,ANe),RNe={kernelName:am,backendName:"cpu",kernelFunc:Aw};function lg(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;let a;Re(s,"sum"),a="bool"===s.dtype?Yl({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):na({inputs:{x:s},backend:e});const l=a.shape.length,u=bt(o,a.shape),c=Dn(u,l);let d=u,h=a;null!=c&&(h=Es({inputs:{x:a},backend:e,attrs:{perm:c}}),d=jn(d.length,l)),$r("sum",d,h.shape.length);const[p,f]=Sr(h.shape,d);let g=Dw(e,p,Fs(h.dtype,"int32"));const y=ne(f),b=e.data.get(g.dataId).values,_=e.data.get(h.dataId).values;for(let v=0;v<b.length;++v){const w=v*y;let S=0;for(let T=0;T<y;++T)S+=_[w+T];b[v]=S}if(i){const w=g;g=cn({inputs:{x:g},backend:e,attrs:{shape:Hn(g.shape,u)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=c&&e.disposeIntermediateTensorInfo(h),g}const $Ne={kernelName:hv,backendName:"cpu",kernelFunc:lg},FNe={kernelName:"Einsum",backendName:"cpu",kernelFunc:function ONe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:l}=aN(s,o.length);uN(i.length,l,o);const{path:u,steps:c}=cN(a,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=lN(p,l[g]);let _;dN(y)?_=o[g]:(_=Es({inputs:{x:o[g]},backend:e,attrs:{perm:y}}),f.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);zt(_.shape,v)||(_=cn({inputs:{x:_},backend:e,attrs:{shape:v}}),f.push(_)),null===h?h=_:(h=Aw({inputs:{a:_,b:h},backend:e}),f.push(h))}m<d-1&&(u[m]>=0&&(h=lg({inputs:{x:h},backend:e,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},PNe={kernelName:rI,backendName:"cpu",kernelFunc:function MNe(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;Re([r,s],"eluGrad");const o=new Float32Array(ne(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];o[l]=u>=1?a[l]:a[l]*(u+1)}return e.makeTensorInfo(s.shape,"float32",o)}},S8=er((n,t)=>n===t?1:0),T8=Ir(O_,S8,null,"bool"),LNe={kernelName:O_,backendName:"cpu",kernelFunc:T8},VNe=Jk,BNe=eN,zNe=tN,UNe=nN,WNe=rN,GNe=sN,HNe=Ht(jf,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+VNe*e);return t*(1-((((GNe*r+WNe)*r+UNe)*r+zNe)*r+BNe)*r*Math.exp(-e*e))}),jNe={kernelName:jf,backendName:"cpu",kernelFunc:HNe},C8=Xl(n=>Math.exp(n)),E8=gh(qf,C8,"float32"),qNe={kernelName:qf,backendName:"cpu",kernelFunc:E8};function Rw(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(C(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),cn({inputs:{x:s},backend:e,attrs:{shape:a}})}const KNe={kernelName:F_,backendName:"cpu",kernelFunc:Rw},I8=Xl(n=>Math.expm1(n)),XNe=gh(Kf,I8),YNe={kernelName:Kf,backendName:"cpu",kernelFunc:XNe},ZNe=er((n,t)=>n/t),CD=Ir(Gf,ZNe),ED={kernelName:Gf,backendName:"cpu",kernelFunc:CD},k8=er((n,t)=>n-t),QNe=vD((n,t,e,r)=>({real:n-e,imag:t-r})),ID=Ir(xm,k8,QNe),JNe={kernelName:xm,backendName:"cpu",kernelFunc:ID};function N8(n,t,e){const r=n.shape,s=r[0],o=r[1],i=e.data.get(n.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,o],c=ne(u),d=Ar("float32",c),h=Ar("float32",c);for(let g=0;g<s;g++){const y=gc({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,o]}}),b=gc({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,o]}}),_=Ls({inputs:{real:y,imag:b},backend:e}),{real:v,imag:w}=eDe(_,t,e),S=Ma(v,w);for(let T=0;T<o;T++){const I=oN(S,T);d[g*o+T]=I.real,h[g*o+T]=I.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_)}const p=e.makeTensorInfo(u,"float32",d),f=e.makeTensorInfo(u,"float32",h),m=Ls({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),m}function eDe(n,t,e){const r=ne(n.shape),s=e.data.get(n.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function tDe(n){return 0==(n&n-1)}(r)){const a=kD(o,i,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",Nl(r,"float32")),h=na({inputs:{x:d},backend:e}),p=ED.kernelFunc({inputs:{a:u,b:d},backend:e}),f=ED.kernelFunc({inputs:{a:c,b:h},backend:e}),m=e.data.get(p.dataId).values,g=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return a}{const l=function nDe(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let o=0,i=0;for(let a=0;a<t;a++){const l=bH(s*a,t,e),u=oN(n,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(o/=t,i/=t),gH(r,o,i,s)}return r}(Ma(o,i),r,t);return pH(l)}}function kD(n,t,e,r,s){if(1===e)return{real:n,imag:t};const o=Ma(n,t),i=e/2,a=fH(o),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=Ls({inputs:{real:d,imag:h},backend:s}),f=mH(o),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),_=s.makeTensorInfo(y,"float32",g),v=Ls({inputs:{real:b,imag:_},backend:s}),w=kD(l,u,i,r,s),S=w.real,T=w.imag,I=[S.length],N=s.makeTensorInfo(I,"float32",S),R=s.makeTensorInfo(I,"float32",T),F=Ls({inputs:{real:N,imag:R},backend:s}),j=kD(m,g,i,r,s),q=j.real,X=j.imag,Q=[q.length],V=s.makeTensorInfo(Q,"float32",q),G=s.makeTensorInfo(Q,"float32",X),W=Ls({inputs:{real:V,imag:G},backend:s}),Y=yH(e,r),se=[Y.real.length],le=s.makeTensorInfo(se,"float32",Y.real),pe=s.makeTensorInfo(se,"float32",Y.imag),he=Ls({inputs:{real:le,imag:pe},backend:s}),me=Aw({inputs:{a:he,b:W},backend:s}),be=yh({inputs:{a:F,b:me},backend:s}),Ne=ID({inputs:{a:F,b:me},backend:s}),Ee=mc({inputs:{input:be},backend:s}),Ue=mc({inputs:{input:Ne},backend:s}),Ve=bh({inputs:{input:be},backend:s}),Ke=bh({inputs:{input:Ne},backend:s}),rt=_h({inputs:[Ee,Ue],backend:s,attrs:{axis:0}}),jt=_h({inputs:[Ve,Ke],backend:s,attrs:{axis:0}}),hn=s.data.get(rt.dataId).values,Vn=s.data.get(jt.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(le),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(he),s.disposeIntermediateTensorInfo(me),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(Ee),s.disposeIntermediateTensorInfo(Ve),s.disposeIntermediateTensorInfo(Ue),s.disposeIntermediateTensorInfo(Ke),s.disposeIntermediateTensorInfo(rt),s.disposeIntermediateTensorInfo(jt),{real:hn,imag:Vn}}const sDe={kernelName:"FFT",backendName:"cpu",kernelFunc:function rDe(n){const{inputs:t,backend:e}=n,{input:r}=t,s=ne(r.shape),o=r.shape[r.shape.length-1],a=cn({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=N8(a,!1,e),u=cn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}};function ND(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:o}=e,i=o||Af(s),a=Jn(i,ne(r));return function iDe(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,i,a)}const oDe={kernelName:oI,backendName:"cpu",kernelFunc:ND},aDe={kernelName:iI,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,o=Ar(r.dtype,ne(r.shape)),[i,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const p=h*l*a*u;for(let f=0;f<a;f++){const m=f*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let b=0;b<u;b++){const _=Math.round(l-g-1),v=p+m+y+b;let w=c[v];_>=0&&_<l&&(w=c[p+m+_*u+b]),o[v]=w}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},D8=Xl(n=>Math.floor(n)),lDe=gh(Xf,D8),uDe={kernelName:Xf,backendName:"cpu",kernelFunc:lDe},cDe=er((n,t)=>Math.floor(n/t)),dDe=Ir(Yf,cDe,null,"int32"),hDe={kernelName:Yf,backendName:"cpu",kernelFunc:dDe},fDe={kernelName:vv,backendName:"cpu",kernelFunc:function pDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=w8({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const y=cn({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});m=yh({inputs:{a:m,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else m=yh({inputs:{a:m,b:i},backend:e});e.disposeIntermediateTensorInfo(g)}if(p){const g=m;if("NCHW"===c&&"prelu"===p&&1===a.shape.length&&1!==a.shape[0]){const y=cn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});m=Nw(e,m,p,y,f),e.disposeIntermediateTensorInfo(y)}else m=Nw(e,m,p,a,f);e.disposeIntermediateTensorInfo(g)}return m}},gDe={kernelName:wv,backendName:"cpu",kernelFunc:function mDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=x8({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=yh({inputs:{a:m,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=Nw(e,m,p,a,f),e.disposeIntermediateTensorInfo(g)}return m}};function A8(n,t,e,r,s,o,i,a,l){const u=_t([r,o],e);for(let c=0;c<r;c++){const d=[];let h=0;for(let p=0;p<s;p++){const f=n[c*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let p=0;p<o;p++)u.values[c*o+p]=t.get(...t.indexToLoc(h*o+p))}return u}const bDe={kernelName:SW,backendName:"cpu",kernelFunc:function yDe(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=ne(r.shape),i=s.shape,a=i[i.length-1],[l,u,c,d]=Qk(r,s);if(0===u)return e.makeTensorInfo(l,r.dtype,[]);const f=A8(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,u,a,c,d,r.shape,o);return e.makeTensorInfo(l,r.dtype,f.values)}};function R8(n,t,e){const r=_t(e,n.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),u=t.locToIndex([i[0],i[2]]);i[2]=t.values[u];const c=n.locToIndex(i);0<=c&&c<n.values.length&&(r.values[s]=n.values[c])}return r}const vDe={kernelName:P_,backendName:"cpu",kernelFunc:function _De(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:i,batchDims:a}=r;Re([s,o],"gatherV2");const l=bt(i,s.shape)[0],u=e.data.get(o.dataId).values,c=s.shape[l];for(let v=0;v<u.length;++v){const w=u[v];C(w<=c-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${c-1}]`)}let d=a;null==a&&(d=0);const h=ne(o.shape),p=fN(s,o,l,d),f=cn({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=cn({inputs:{x:o},backend:e,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=e.bufferSync(m),_=R8(e.bufferSync(f),y,g);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(p.outputShape,_.dtype,_.values)}},$8=er((n,t)=>n>t?1:0),wDe=Ir(L_,$8,null,"bool"),xDe={kernelName:L_,backendName:"cpu",kernelFunc:wDe},O8=er((n,t)=>n>=t?1:0),SDe=Ir(Zf,O8,null,"bool"),TDe={kernelName:Zf,backendName:"cpu",kernelFunc:SDe},EDe={kernelName:aI,backendName:"cpu",kernelFunc:function CDe(n){const{inputs:t,backend:e}=n,{input:r}=t,s=ne(r.shape),o=r.shape[r.shape.length-1],a=cn({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=N8(a,!0,e),u=cn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}},IDe=Ht(Jf,n=>Number.isFinite(n)?1:0,"bool"),kDe={kernelName:Jf,backendName:"cpu",kernelFunc:IDe},NDe=Ht(em,n=>Math.abs(n)===1/0?1:0,"bool"),DDe={kernelName:em,backendName:"cpu",kernelFunc:NDe},ADe=Ht(tm,n=>Number.isNaN(n)?1:0,"bool"),RDe={kernelName:tm,backendName:"cpu",kernelFunc:ADe},F8=er((n,t)=>n<t?1:0),$De=Ir(B_,F8,null,"bool"),ODe={kernelName:B_,backendName:"cpu",kernelFunc:$De},M8=er((n,t)=>n<=t?1:0),FDe=Ir(z_,M8,null,"bool"),MDe={kernelName:z_,backendName:"cpu",kernelFunc:FDe};function P8(n,t,e){const r=(t-n)/(e-1),s=Gr(e,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const LDe={kernelName:TW,backendName:"cpu",kernelFunc:function PDe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,i=P8(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},L8=Xl(n=>Math.log(n)),VDe=gh(nm,L8),BDe={kernelName:nm,backendName:"cpu",kernelFunc:VDe},zDe=Ht(rm,n=>Math.log1p(n)),UDe={kernelName:rm,backendName:"cpu",kernelFunc:zDe},WDe=er((n,t)=>n&&t),GDe=Ir(U_,WDe,null,"bool"),HDe={kernelName:U_,backendName:"cpu",kernelFunc:GDe},jDe=Ht(W_,n=>n?0:1,"bool"),qDe={kernelName:W_,backendName:"cpu",kernelFunc:jDe},KDe=er((n,t)=>n||t),XDe=Ir(G_,KDe,null,"bool"),YDe={kernelName:G_,backendName:"cpu",kernelFunc:XDe},QDe={kernelName:H_,backendName:"cpu",kernelFunc:function ZDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:l}=r;Re(s,"LRN");const u=s.shape[3],c=u-1,d=e.data.get(s.dataId).values,h=ne(s.shape),p=new Float32Array(h);function f(m){const g=m%u;let y=m-g+Math.max(0,g-o);const b=m-g+Math.min(g+o,c);let _=0;for(;y<=b;y++){const v=d[y];_+=v*v}return _}for(let m=0;m<h;m++){const g=f(m),y=d[m]*Math.pow(i+a*g,-l);p[m]=y}return e.makeTensorInfo(s.shape,s.dtype,p)}},eAe={kernelName:uI,backendName:"cpu",kernelFunc:function JDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Re(i,"LRNGrad");const d=ne(i.shape),h=i.shape[3],p=e.data.get(i.dataId).values,f=e.data.get(s.dataId).values,m=e.data.get(o.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const _=b%h,v=b-_+Math.max(0,_-a),w=b-_+Math.min(h,_+a+1);let S=0;for(let T=v;T<w;T++)S+=Math.pow(f[T],2);S=u*S+l;for(let T=v;T<w;T++){let I=-2*u*c*f[T]*m[b]/S;b===T&&(I+=Math.pow(S,-c)),I*=p[b],g[T]+=I}}return e.makeTensorInfo(i.shape,s.dtype,g)}};function V8(n,t,e,r){const s=Ar(r,ne(e));for(let o=0;o<s.length;++o){const i=o*t;let a=n[i];for(let l=0;l<t;++l){const u=n[i+l];(Number.isNaN(u)||u>a)&&(a=u)}s[o]=a}return s}function B8(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=e;let l=s.shape;const u=l.length,c=bt(o,l);let d=c;const h=Dn(d,u);let p=a.data.get(s.dataId).values;if(null!=h){const v=new Array(u);for(let w=0;w<v.length;w++)v[w]=l[h[w]];p=wD(p,l,s.dtype,h,v),d=jn(d.length,u),l=v}Re(s,"max"),$r("max",d,u);const[f,m]=Sr(l,d),y=V8(p,ne(m),f,s.dtype),b=a.write(y,f,s.dtype);let _=f;return i&&(_=Hn(f,c)),{dataId:b,shape:_,dtype:s.dtype}}const tAe={kernelName:j_,backendName:"cpu",kernelFunc:B8},z8=er((n,t)=>Math.max(n,t)),nAe=Ir(sm,z8),rAe={kernelName:sm,backendName:"cpu",kernelFunc:nAe},oAe={kernelName:q_,backendName:"cpu",kernelFunc:function sAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Re(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;C(Rr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fo(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))d=na({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,p=Be(s.shape),f=xD(h,0,s.dtype,p,c,"max");d=e.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}},aAe={kernelName:K_,backendName:"cpu",kernelFunc:function iAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Re(s,"maxPool3d");const c=Da(s.shape,o,i,1,a,l,u),h=g8(e.data.get(s.dataId).values,0,s.dtype,Be(s.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},uAe={kernelName:dI,backendName:"cpu",kernelFunc:function lAe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Re([s,o],"maxPool3DGrad");const c=Da(o.shape,i,a,1,l,u),h=function Cke(n,t){const e=_t(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let _=b;for(;_<0;)_+=i;const v=Math.min(t.inDepth,u+b);for(let w=0;w<t.outHeight;++w){const S=w*s-p;let T=S;for(;T<0;)T+=a;const I=Math.min(t.inHeight,c+S);for(let N=0;N<t.outWidth;++N){const R=N*o-f;let F=R;for(;F<0;)F+=l;const j=Math.min(t.inWidth,d+R);let q=Number.NEGATIVE_INFINITY,X=-1;for(let Q=_;Q<v;Q+=i){const V=Q-b;for(let G=T;G<I;G+=a){const W=G-S;for(let Y=F;Y<j;Y+=l){const se=Y-R,le=n.get(m,Q,G,Y,g);le>=q&&(q=le,X=V*c*d+W*c+se)}}}e.set(X,m,y,w,N,g)}}}return e}(e.bufferSync(o),c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,_=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,S=_-1-c.padInfo.front,T=w-1-c.padInfo.left,I=v-1-c.padInfo.top,N=_t(o.shape,"float32"),R=e.bufferSync(s);for(let F=0;F<c.batchSize;++F)for(let j=0;j<c.inChannels;++j)for(let q=0;q<c.inDepth;++q)for(let X=0;X<c.inHeight;++X)for(let Q=0;Q<c.inWidth;++Q){const V=q-S,G=X-I,W=Q-T;let Y=0;for(let se=0;se<_;se+=g){const le=(V+se)/p;if(!(le<0||le>=c.outDepth||Math.floor(le)!==le))for(let pe=0;pe<v;pe+=y){const he=(G+pe)/f;if(!(he<0||he>=c.outHeight||Math.floor(he)!==he))for(let me=0;me<w;me+=b){const be=(W+me)/m;if(be<0||be>=c.outWidth||Math.floor(be)!==be)continue;const Ue=_*v*w-1-h.get(F,le,he,be,j)===se*v*w+pe*w+me?1:0;0!==Ue&&(Y+=R.get(F,le,he,be,j)*Ue)}}}N.set(Y,F,q,X,Q,j)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},dAe={kernelName:cI,backendName:"cpu",kernelFunc:function cAe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:i}=t,a=o;Re([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Fo(a.shape,l,u,1,c,d),p=e.data.get(a.dataId).values,f=_t(h.outShape,a.dtype,m8(p,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,_=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,S=_-1-h.padInfo.top,T=_t(a.shape,"float32"),I=e.data.get(s.dataId).values,N=_t(s.shape,"float32",I);for(let R=0;R<h.batchSize;++R)for(let F=0;F<h.inChannels;++F)for(let j=0;j<h.inHeight;++j)for(let q=0;q<h.inWidth;++q){const X=j-S,Q=q-w;let V=0;for(let G=0;G<_;G+=y){const W=(X+G)/m;if(!(W<0||W>=h.outHeight||Math.floor(W)!==W))for(let Y=0;Y<v;Y+=b){const se=(Q+Y)/g;if(se<0||se>=h.outWidth||Math.floor(se)!==se)continue;const he=_*v-1-f.get(R,W,se,F)===G*v+Y?1:0;0!==he&&(V+=N.get(R,W,se,F)*he)}}T.set(V,R,j,q,F)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},pAe={kernelName:CW,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,l=e;Re(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=Fo(r.shape,s,o,[1,1],i),[d,h]=function hAe(n,t,e,r,s){const i=xD(n,0,e,Be(t),s,"max"),a=m8(n,t,e,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,a,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},mAe={kernelName:X_,backendName:"cpu",kernelFunc:function fAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=bt(o,s.shape),c=ne(Sr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=Yl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(p);const f=CD({inputs:{a:p,b:h},backend:e});d.push(f);const m=lg({inputs:{x:f},backend:e,attrs:{axis:o,keepDims:i}});return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},yAe={kernelName:Y_,backendName:"cpu",kernelFunc:function gAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Re(s,"min");const a=bt(o,s.shape);let l=a;const u=Dn(l,s.shape.length);let c=s;null!=u&&(c=Es({inputs:{x:s},backend:e,attrs:{perm:u}}),l=jn(l.length,s.shape.length)),$r("min",l,c.shape.length);const[d,h]=Sr(c.shape,l),p=ne(h),f=Gr(ne(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let _=m[b];for(let v=0;v<p;++v){const w=m[b+v];(Number.isNaN(w)||w<_)&&(_=w)}f[y]=_}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,f);if(i){const b=cn({inputs:{x:g},backend:e,attrs:{shape:Hn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},U8=er((n,t)=>Math.min(n,t)),bAe=Ir(om,U8),_Ae={kernelName:om,backendName:"cpu",kernelFunc:bAe},wAe={kernelName:Z_,backendName:"cpu",kernelFunc:function vAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,mode:i}=r;Re(s,"mirrorPad");const a=o.map((_,v)=>_[0]+s.shape[v]+_[1]),l=o.map(_=>_[0]),u=o.map((_,v)=>_[0]+s.shape[v]),c="reflect"===i?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,p=Be(s.shape),f=ne(a),m=a.length,g=Be(a),y=Ar(s.dtype,f);for(let _=0;_<f;_++){let v=Hd(_,m,g);for(let S=0;S<m;S++)v[S]<l[S]?v[S]=2*l[S]-v[S]-c:v[S]>=u[S]&&(v[S]=2*(u[S]-1)-v[S]+c);v=v.map((S,T)=>S-l[T]);const w=Gi(v,h,p);y[_]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},xAe=er((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),SAe=Ir(im,xAe),TAe={kernelName:im,backendName:"cpu",kernelFunc:SAe};function W8(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=bt([a],s.shape),u=B8({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=Hn(u.shape,l),d=cn({inputs:{x:u},backend:e,attrs:{shape:c}}),h=ID({inputs:{a:s,b:d},backend:e}),p=E8({inputs:{x:h},backend:e}),f=lg({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),m=cn({inputs:{x:f},backend:e,attrs:{shape:c}}),g=CD({inputs:{a:p,b:m},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}const CAe={kernelName:mv,backendName:"cpu",kernelFunc:W8},IAe={kernelName:EW,backendName:"cpu",kernelFunc:function EAe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r;Re(s,"multinomial");const l=a?s:W8({inputs:{logits:s},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,o],p=Gr(ne(h),"int32");for(let f=0;f<u;++f){const m=f*c,g=new Float32Array(c-1);g[0]=d[m];for(let _=1;_<g.length;++_)g[_]=g[_-1]+d[m+_];const y=xl.alea(i.toString()),b=f*o;for(let _=0;_<o;++_){const v=y();p[b+_]=g.length;for(let w=0;w<g.length;w++)if(v<g[w]){p[b+_]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",p)}};function G8(n,t,e){const r=Nl(-1,e);return TD([],t,r,n,e)}const NAe={kernelName:Q_,backendName:"cpu",kernelFunc:function kAe(n){const{inputs:t,backend:e}=n,{x:r}=t;Re(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=G8(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},DAe=Bk,RAe={kernelName:hI,backendName:"cpu",kernelFunc:function AAe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Re(s,"NonMaxSuppression");const u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:d}=DAe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},$Ae=zk,FAe={kernelName:pI,backendName:"cpu",kernelFunc:function OAe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Re(s,"NonMaxSuppressionPadded");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=$Ae(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},MAe=Uk,LAe={kernelName:fI,backendName:"cpu",kernelFunc:function PAe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Re(s,"NonMaxSuppressionWithScore");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,h=i,p=a,f=l,m=u,{selectedIndices:g,selectedScores:y}=MAe(c,d,h,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},H8=er((n,t)=>n!==t?1:0),VAe=Ir(J_,H8,null,"bool"),BAe={kernelName:J_,backendName:"cpu",kernelFunc:VAe},UAe={kernelName:tv,backendName:"cpu",kernelFunc:function zAe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:i,onValue:a,offValue:l}=r;Re(s,"oneHot");const u=ne(s.shape),c=new Float32Array(u*i);c.fill(l);const d=e.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=a);return e.makeTensorInfo([...s.shape,i],o,c)}};function $w(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=mc({inputs:{input:r},backend:e}),o=$w({inputs:{x:s},backend:e}),i=bh({inputs:{input:r},backend:e}),a=$w({inputs:{x:i},backend:e}),l=Ls({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return ND({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const WAe={kernelName:bv,backendName:"cpu",kernelFunc:$w},GAe={kernelName:ev,backendName:"cpu",kernelFunc:function j8(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=mc({inputs:{input:r},backend:e}),o=j8({inputs:{x:s},backend:e}),i=bh({inputs:{input:r},backend:e}),a=$w({inputs:{x:i},backend:e}),l=Ls({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return ND({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function q8(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return Rw({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(c=>{Ro(o,c.shape,"All tensors passed to stack must have matching shapes"),C(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=_h({inputs:t.map(c=>{const d=Rw({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const HAe={kernelName:nv,backendName:"cpu",kernelFunc:q8},K8={kernelName:rv,backendName:"cpu",kernelFunc:function jAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:i}=r;Re(s,"pad");const a=o.map((b,_)=>b[0]+s.shape[_]+b[1]),l=o.map(b=>b[0]),u=e.data.get(s.dataId).values,c=ne(s.shape),d=s.shape.length,h=Be(s.shape),p=ne(a),f=a.length,m=Be(a),g=Ar(s.dtype,p);0!==i&&g.fill(i);for(let b=0;b<c;b++)g[Gi(Hd(b,d,h).map((S,T)=>S+l[T]),f,m)]=u[b];return{dataId:e.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},qAe=er((n,t)=>Math.pow(n,t)),KAe=Ir(lm,qAe),XAe={kernelName:lm,backendName:"cpu",kernelFunc:KAe};function X8(n,t,e,r){const[s,o]=Sr(n,r),i=Fs(t,"int32"),a=Gr(ne(s),i),l=ne(o);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];a[u]=d}return{outVals:a,outShape:s,outDtype:i}}const ZAe={kernelName:ov,backendName:"cpu",kernelFunc:function YAe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;Re(s,"prod");const a=s.shape.length,l=bt(o,s.shape),u=Dn(l,a);let c=l,d=s;const h=[];null!=u&&(d=Es({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),c=jn(c.length,a));const p=e.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=X8(d.shape,d.dtype,p,c);let y=m;return i&&(y=Hn(m,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,f)}};function Y8(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function Z8(n,t,e,r,s,o,i,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function QAe(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const o=Hd(s,t.length,Be(t)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:h}=function e2e(n,t,e,r){const s=[];let o=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function JAe(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let d=1;d<l+1;++d)a[u].push(d*c)}for(let u=0;u<n.length;++u){let c=n[u],d=n[u]+1;for(let h=0;h<e.length;++h){const p=e[h],f=h+t.length-1;if(f>=0){const m=a[f],g=m[m.length-1]-p[c];for(let y=c;y<d;++y)a[f].push(p[y+1]+g)}c=p[c],d=p[d]}d!==c&&(s.push([c,d]),o+=d-c)}return{outSplits:a,valueSlices:s,numValues:o}}(o,i,n,u),p=function t2e(n){const t=[];for(let e=0;e<n.length;++e){const s=Jn("int32",n[e].length);t.push(s),n[e].forEach((o,i)=>s[i]=o)}return t}(c),f=function r2e(n,t,e,r,s){const o=t.slice();o[0]=s;const i=Jn(e,ne(o)),a=n.length;return function n2e(n,t,e,r,s,o){const i=Y8(t,2)[1],a=Y8(o,2)[1];let l=0;for(const u of e)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*a+d]=n[c*i+d];++l}}(n,t,r,0===a?0:a/t[0],i,o),[i,o]}(e,r,s,d,h);return[p,f[0],f[1]]}const o2e={kernelName:IW,backendName:"cpu",kernelFunc:function s2e(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=t,l=s.map(y=>e.data.get(y.dataId).values),u=s.map(y=>y.shape),c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,[h,p,f]=Z8(l,u,c,o.shape,o.dtype,d,i.shape),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(f,o.dtype,p);return m.concat([g])}},Q8=2147483647;function J8(n,t,e,r,s,o,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===s.length,u=0===i.length,c=[];a||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=Jn("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],_=u?o[0]:o[g];if(0===_)throw new Error("Requires delta != 0");let v;if(_>0&&b<y||_<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/_)),v>Q8)throw new Error(`Requires ((limit - start) / delta) <= ${Q8}`);h[g+1]=h[g]+v}const f=Jn(e,h[d]);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let b=a?n[0]:n[g];const _=u?o[0]:o[g];for(let v=0;v<y;++v)f[m++]=b,b+=_}return[h,f]}const a2e={kernelName:kW,backendName:"cpu",kernelFunc:function i2e(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=J8(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}};var Wo=Vo;class Ow{constructor(t,e,r,s,o,i,a,l,u,c){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=uH(c),this.raggedRank=cH(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Wo.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Wo.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Wo.VALUE_ROWIDS:return Ow.getMaxWidthValueRowID(e);case Wo.ROW_SPLITS:return Ow.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Wo[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const o=t[s+1]-t[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],o=0;for(let i=1;i<e;++i){const a=t[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(e-r,o)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return t5(t,r)}calculateOutputSize(t){const e=this.valuesShape;dH(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=lH(this.raggedRank,s,e);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),o=[];let i=0;for(let a=0;a<s;++a,i+=e)o.push(i);for(let a=s;a<t;++a)o.push(-1);return C(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,e,r,s){const o=t.length,i=[];for(let a=0;a<o-1;++a){const l=t[a+1]-t[a];let u=Math.min(s,l),c=e[a];-1===c&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(o>0&&i.length!==t[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,r,s){const o=t.length,i=[];if(0===o)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];i.push(u);for(let c=1;c<o;++c){const d=t[c];if(d===l)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);u=e[d]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,r,s){const o=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Wo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,s);case Wo.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,s);default:throw new Error(`Unsupported partition type: ${Wo[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Wo.FIRST_DIM_SIZE:return t[0];case Wo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Wo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Wo[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=t5(r,!1),i=Jn(this.valuesDType,ne(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(t,e,r,s){if(0===r.length)return;const o=this.values,i=r;let a=s.slice();a=a.slice(t+1);const l=ne(a),u=e.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const f=this.defaultValueShape;te(()=>{const m=H(c,f);c=Lm(m,a).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let m=f<u?e[f]:-1;if(m!==p){if(h<p){const g=o.subarray(d*l);e5(i.subarray(h*l),g,(p-h)*l)}if(f>=u&&(m=Math.floor(r.length/l)),m>p)if(1===this.defaultValue.length)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;)e5(i.slice(p*l),c,l),++p;m<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}else++p}}}function e5(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function t5(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function n5(n,t,e,r,s,o,i,a,l,u){return new Ow(n,t,e,r,s,o,i,a,l,u).compute()}const u2e={kernelName:NW,backendName:"cpu",kernelFunc:function l2e(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,h=a.map(g=>e.data.get(g.dataId).values),p=a.map(g=>g.shape),[f,m]=n5(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,p,l);return e.makeTensorInfo(f,o.dtype,m)}};function r5(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return Gr(0,r);const l=Gr(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const d2e={kernelName:mI,backendName:"cpu",kernelFunc:function c2e(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:o,step:i}=e,a=r5(r,s,i,o);return t.makeTensorInfo([a.length],o,a)}},h2e=Ht(um,n=>1/n),p2e={kernelName:um,backendName:"cpu",kernelFunc:h2e},m2e={kernelName:lv,backendName:"cpu",kernelFunc:function f2e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r;Re(s,"resizeBilinear");const l=Be(s.shape),[u,c]=a,[d,h,p,f]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(ne([d,u,c,f])),y=[o&&u>1?h-1:h,o&&c>1?p-1:p],b=[o&&u>1?u-1:u,o&&c>1?c-1:c];let _=0;const v=y[0]/b[0],w=y[1]/b[1];for(let S=0;S<d;S++)for(let T=0;T<u;T++){let I;I=i?v*(T+.5)-.5:v*T;const N=Math.max(0,Math.floor(I)),R=I-N,F=Math.min(h-1,Math.ceil(I)),j=S*l[0]+N*l[1],q=S*l[0]+F*l[1];for(let X=0;X<c;X++){let Q;Q=i?w*(X+.5)-.5:w*X;const V=Math.max(0,Math.floor(Q)),G=Q-V,W=Math.min(p-1,Math.ceil(Q)),Y=j+V*l[2],se=q+V*l[2],le=j+W*l[2],pe=q+W*l[2];for(let he=0;he<f;he++){const me=m[Y+he],be=m[se+he],Ue=me+(m[le+he]-me)*G;g[_++]=Ue+(be+(m[pe+he]-be)*G-Ue)*R}}}return e.makeTensorInfo([d,u,c,f],"float32",g)}},y2e={kernelName:bI,backendName:"cpu",kernelFunc:function g2e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r;Re([o,s],"resizeBilinearGrad");const a=Be(s.shape),[l,u,c,d]=s.shape,[,h,p]=o.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],_=e.data.get(o.dataId).values;let v=0;for(let w=0;w<l;w++){const S=w*a[0];for(let T=0;T<h;T++){const I=T*y,N=Math.floor(I),R=Math.min(Math.ceil(I),u-1),F=S+N*a[1],j=S+R*a[1],q=I-N,X=1-q;for(let Q=0;Q<p;Q++){const V=Q*b,G=Math.floor(V),W=Math.min(Math.ceil(V),c-1),Y=V-G,se=1-Y,le=F+G*a[2],pe=F+W*a[2],he=j+G*a[2],me=j+W*a[2],be=X*se,Ne=X*Y,Ee=q*se,Ue=q*Y;for(let Ve=0;Ve<d;Ve++){const Ke=_[v++];f[le+Ve]+=Ke*be,f[pe+Ve]+=Ke*Ne,f[he+Ve]+=Ke*Ee,f[me+Ve]+=Ke*Ue}}}}return e.makeTensorInfo([l,c,u,d],"float32",f)}},_2e={kernelName:av,backendName:"cpu",kernelFunc:function b2e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r;Re(s,"resizeNearestNeighbor");const l=Be(s.shape),[u,c]=a,[d,h,p,f]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[o&&u>1?h-1:h,o&&c>1?p-1:p],b=[o&&u>1?u-1:u,o&&c>1?c-1:c],_=y[0]/b[0],v=y[1]/b[1];let w=0;for(let S=0;S<d;S++){const T=S*l[0];for(let I=0;I<u;I++){const N=i?_*(I+.5):_*I;let R=Math.min(h-1,o?Math.round(N):Math.floor(N));i&&(R=Math.max(0,R));const F=T+R*l[1];for(let j=0;j<c;j++){const q=i?v*(j+.5):v*j;let X=Math.min(p-1,o?Math.round(q):Math.floor(q));i&&(X=Math.max(0,X));const Q=F+X*l[2];for(let V=0;V<f;V++)g[w++]=m[Q+V]}}}return e.makeTensorInfo([d,u,c,f],s.dtype,g)}},w2e={kernelName:yI,backendName:"cpu",kernelFunc:function v2e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r;Re([o,s],"resizeNearestNeighborGrad");const a=Be(s.shape),l=Be(o.shape),[u,c,d,h]=s.shape,[,p,f]=o.shape,m=new Float32Array(u*c*d*h),g=e.data.get(o.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],_=y[0]/b[0],v=y[1]/b[1],w=1/_,S=1/v,T=2*Math.ceil(w)+2,I=2*Math.ceil(S)+2;for(let N=0;N<u;N++){const R=N*a[0];for(let F=0;F<c;F++){const j=R+F*a[1],q=Math.floor(F*w),X=Math.floor(q-T/2);for(let Q=0;Q<d;Q++){const V=j+Q*a[2],G=Math.floor(Q*S),W=Math.floor(G-I/2);for(let Y=0;Y<h;Y++){let se=0;for(let le=0;le<T;le++){const pe=le+X;if(pe<0||pe>=p)continue;const he=R+pe*l[1],me=pe*_;if(F===Math.min(c-1,i?Math.round(me):Math.floor(me)))for(let Ne=0;Ne<I;Ne++){const Ee=Ne+W;if(Ee<0||Ee>=f)continue;const Ue=he+Ee*l[2],Ve=Ee*v;Q===Math.min(d-1,i?Math.round(Ve):Math.floor(Ve))&&(se+=g[Ue+Y])}}m[V+Y]=se}}}}return e.makeTensorInfo(s.shape,s.dtype,m)}},S2e={kernelName:uv,backendName:"cpu",kernelFunc:function x2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r;Re(s,"reverse");const i=s.shape.length,a=bt(o,s.shape);if(0===i)return na({inputs:{x:s},backend:e});const l=new jr(s.shape,s.dtype),u=e.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(p=>h[p]=s.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},T2e={kernelName:RI,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=t,a=e,l=Ar(r.dtype,ne(r.shape)),[u,c,d,h]=r.shape,[p,f]=Xk(i,c,d),g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let v=0;v<u;v++){const w=v*d*c*h;for(let S=0;S<c;S++){const T=S*(d*h);for(let I=0;I<d;I++){const N=I*h;for(let R=0;R<h;R++){const F=[u,S,I,R],j=F[2],q=F[1];let X=(j-p)*y-(q-f)*g,Q=(j-p)*g+(q-f)*y;X=Math.round(X+p),Q=Math.round(Q+f);let V=o;"number"!=typeof o&&(V=3===R?255:o[R]),X>=0&&X<d&&Q>=0&&Q<c&&(V=b[w+Q*(d*h)+X*h+R]),l[w+T+N+R]=V}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},C2e=Ht(hm,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),E2e={kernelName:hm,backendName:"cpu",kernelFunc:C2e},s5=Xl(n=>1/Math.sqrt(n)),I2e=gh(pm,s5),k2e={kernelName:pm,backendName:"cpu",kernelFunc:I2e};function vh(n,t,e,r,s,o,i,a,l,u){const c=[r/s,s],d=n.values,h=t.values;if(0===r)return _t(e,t.dtype);const p=_t(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<o;f++){const m=[];let g=0;for(let y=0;y<i;y++){const b=d[f*i+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<s;y++)u?p.values[g*s+y]+=h[f*s+y]:p.values[g*s+y]=0===t.rank?h[0]:h[f*s+y]}return p}const D2e={kernelName:DW,backendName:"cpu",kernelFunc:function N2e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=qm(0,s,i),m=vh(e.bufferSync(s),e.bufferSync(o),i,d,u,l,a,c,0,!0);return e.makeTensorInfo(i,m.dtype,m.values)}};function A2e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function R2e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const F2e={kernelName:AW,backendName:"cpu",kernelFunc:function O2e(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:i}=r,u=function $2e(n,t,e,r,s,o){const i=Jn("int32",e*s);for(let a=0;a<e;++a){const l=n.slice(a*r,(a+1)*r),u=a*s;for(let c=0;c<s;++c)i[u+c]="left"===o?A2e(l,t[c+u]):R2e(l,t[c+u])}return i}(e.data.get(s.dataId).values,e.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],i);return e.makeTensorInfo(o.shape,"int32",u)}},P2e={kernelName:cv,backendName:"cpu",kernelFunc:function M2e(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t;Re([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=Fs(s.dtype,o.dtype),d=Gr(ne(s.shape),c);let h=0;const p=0===i||i>1||1===s.shape.length?1:ne(s.shape.slice(1));for(let f=0;f<a.length;f++)for(let m=0;m<p;m++)d[h++]=1===a[f]?l[f]:u[f];return e.makeTensorInfo(s.shape,c,d)}},L2e=Qv,V2e=Jv,B2e=Ht(fm,n=>n>=0?V2e*n:L2e*(Math.exp(n)-1)),z2e={kernelName:fm,backendName:"cpu",kernelFunc:B2e},U2e=Ht(ym,n=>n<0?-1:n>0?1:0),W2e={kernelName:ym,backendName:"cpu",kernelFunc:U2e},G2e=Ht(mm,n=>Math.sin(n)),H2e={kernelName:mm,backendName:"cpu",kernelFunc:G2e},j2e=Ht(gm,n=>Math.sinh(n)),q2e={kernelName:gm,backendName:"cpu",kernelFunc:j2e},o5=Math.log(1.1920928955078125e-7)+2,K2e=Ht(_m,n=>{const t=n>-o5,e=n<o5,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),X2e={kernelName:_m,backendName:"cpu",kernelFunc:K2e},Z2e={kernelName:pv,backendName:"cpu",kernelFunc:function Y2e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:i}=r;Re([s],"spaceToBatchND");const a=ne(o),l=[[0,0]];l.push(...i);for(let S=1+o.length;S<s.shape.length;++S)l.push([0,0]);const u=K8.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),c=Gm(u.shape,o,a,!1),d=Hm(c.length,o.length,!1),h=jm(u.shape,o,a,!1),m=cn({inputs:{x:u},backend:e,attrs:{shape:c}}),b=Es({inputs:{x:m},backend:e,attrs:{perm:d}}),w=cn({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),w}};function i5(n,t,e,r,s,o,i){const a=t[0],l=o[0],u=new Array(l),c=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(wH(a));return[Jn(e,0),[0,d],Jn(s,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*d];if(y<0)throw new Error(xH(g,y));if(y>=l)throw new Error(SH(g,y,l));++f[y],h=h&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){const y=0===f[g];u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const g=n,y=r;for(let b=0;b<a;++b)c[b]=b;return[g,[a,d],y,u,c]}{const g=f[l-1],y=Jn(e,g*d),b=Jn(s,g),_=new Array(l).fill(0);for(let v=0;v<a;++v){const w=n[v*d],T=(0===w?0:f[w-1])+_[w];_[w]++;for(let I=0;I<d;++I)y[T*d+I]=n[v*d+I];b[T]=r[v],c[v]=T}for(let v=0;v<l;++v)if(0===_[v]){const S=0===v?0:f[v-1];y[S*d+0]=v;for(let T=1;T<d;++T)y[S*d+T]=0;b[S]=i}return[y,[g,d],b,u,c]}}const J2e={kernelName:_I,backendName:"cpu",kernelFunc:function Q2e(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values[0],[d,h,p,f,m]=i5(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function a5(n,t,e,r,s){const o=ne(r),i=t[0],a=s.length,l=[];let u=1,c=-1;for(let g=0;g<a;++g){const y=s[g];if(-1===y){if(-1!==c)throw new Error(TH(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(CH(g,y));u*=y,l.push(y)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(o/u);if(u*g!==o)throw new Error(IH(r,l));l[c]=g}if(ne(l)!==o)throw new Error(kH(r,l));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let g=h-2;g>=0;--g)p[g]=p[g+1]*r[g+1]}const f=[];if(a>0){f[a-1]=1;for(let g=a-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}const m=Jn(e,i*a);for(let g=0;g<i;++g){let y=0;for(let b=0;b<h;++b)y+=n[g*h+b]*p[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/f[b]),y%=f[b]}return[m,[i,a],l]}const tRe={kernelName:vI,backendName:"cpu",kernelFunc:function eRe(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(o.dataId).values),[u,c,d]=a5(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function DD(n,t,e,r,s,o=!1,i=0){const a=r.length,l=[t[0],n.length/t[0]],u=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const f=Jn(e,h.reduce((_,v)=>_*v,1));if(0===a)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,y=0,b=s[m];for(;;){let _=0;if(g<a){if(_=s[g],b===_){++g;continue}if(b>=_)throw new Error("segment ids are not increasing")}if(b<0||b>=d)throw new Error(DH(b,d));b>y&&f.fill(i,y*u,b*u);for(let v=m;v<g;++v){const w=r[v];if(w<0||w>=l[0])throw new Error(AH(v,r[v],l[0]));for(let S=0;S<u;S++)f[b*u+S]+=n[w*u+S]}if(o)for(let v=0;v<u;v++)f[b*u+v]/=g-m;if(m=g,++g,y=b+1,b=_,g>a)break}return y<d&&f.fill(i,y*u,d*u),[f,h]}const rRe={kernelName:wI,backendName:"cpu",kernelFunc:function nRe(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=DD(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},oRe={kernelName:xI,backendName:"cpu",kernelFunc:function sRe(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=DD(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},aRe={kernelName:RW,backendName:"cpu",kernelFunc:function iRe(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=qm(0,s,a),p=!1,f=e.bufferSync(s);let m;switch(o.dtype){case"bool":m=vh(f,e.bufferSync(o),a,h,c,u,l,d,Boolean(e.data.get(i.dataId).values[0]),p);break;case"float32":case"int32":m=vh(f,e.bufferSync(o),a,h,c,u,l,d,e.data.get(i.dataId).values[0],p);break;case"string":m=vh(f,e.bufferSync(o),a,h,c,u,l,d,Al(e.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,m.dtype,m.values)}},uRe={kernelName:fv,backendName:"cpu",kernelFunc:function lRe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=bt(i,s.shape)[0],l=hN(s,o,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const p=gc({inputs:{x:s},backend:e,attrs:{begin:u,size:h}});return u[a]+=d,p})}},cRe=Xl(n=>Math.sqrt(n)),dRe=Ht(vm,n=>Math.sqrt(n)),hRe={kernelName:vm,backendName:"cpu",kernelFunc:dRe},pRe={kernelName:SI,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Re(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},l5=er((n,t)=>{const e=n-t;return e*e}),fRe=Ir(wm,l5),mRe={kernelName:wm,backendName:"cpu",kernelFunc:fRe},gRe=Ht(Em,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),yRe={kernelName:Em,backendName:"cpu",kernelFunc:gRe};function u5(n,t,e,r){const s=_t(n,t.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];s.set(t.get(...a),...i)}return s}const _Re={kernelName:TI,backendName:"cpu",kernelFunc:function bRe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;Re(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=gk(s.shape,o,i,a,l,u,c,d,h);let w;if(m)w=cn({inputs:{x:s},backend:e,attrs:{shape:f}});else if(g||y){C(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const S=pk(b,_,v),T=gc({inputs:{x:s},backend:e,attrs:{begin:b,size:S}});w=cn({inputs:{x:T},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(T)}else{const T=u5(p,e.bufferSync(s),v,b);w=e.makeTensorInfo(f,T.dtype,T.values)}return w}};class vRe{constructor(t,e,r,s,o,i){this.separator=Dl(t),this.nGramWidths=e,this.leftPad=Dl(r),this.rightPad=Dl(s),this.padWidth=o,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(o-(a+1))),d=i-(u+c),h=e+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let b=0;b<d;++b)p+=t[h+b].length;p+=c*this.rightPad.length,p+=(u+c+d-1)*this.separator.length,r[s+a]=new Uint8Array(p);const m=r[s+a];let g=0;const y=b=>b.forEach(_=>m[g++]=_);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(t[h+b]),y(this.separator);if(d>0){y(t[h+d-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=e[u]>=l;if(c=c&&e[u]<=r,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${r}]`);l=e[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=Jn("int32",s);if(0===r||0===s){const l=new Array(r);for(let u=0;u<=o;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const u=e[l]-e[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&0===c&&(c=1),i[l]=i[l-1]+c}const a=new Array(i[o]);for(let l=0;l<o;++l){const u=e[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const p=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,u,a,c,p,d),c+=p}),this.preserveShort&&c===i[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,u,a,c,1,d+2*this.padWidth)}}return[a,i]}}function c5(n,t,e,r,s,o,i,a){return new vRe(e,r,s,o,i,a).compute(n,t)}const xRe={kernelName:CI,backendName:"cpu",kernelFunc:function wRe(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=e.data.get(c.dataId).values,p=e.data.get(d.dataId).values,[f,m]=c5(h,p,s,o,i,a,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",m)]}};function SRe(n,t,e,r){if(!n.length)return;if(0===t.length){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(1===t.length){const o=t[0];let i=n.indexOf(o);for(;-1!==i;){const a=n.subarray(0,i);(!e||0!==a.length)&&r.push(a),i=(n=n.subarray(i+1)).indexOf(o)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||-1!==t.indexOf(n[o])){const i=n.subarray(s,o);(!e||0!==i.length)&&r.push(i),s=o+1}}function d5(n,t,e){const r=n.length,s=[];let o=0,i=0;const a=new Array(r);for(let h=0;h<r;++h){const p=s.length;SRe(n[h],t,e,s);const f=s.length-p;a[h]=f,o+=f,i=Math.max(i,f)}const l=Jn("int32",2*o),u=new Array(o),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let p=0;p<a[h];++p)l[2*d]=h,l[2*d+1]=p,u[d]=s[d],++d;return[l,u,c]}const CRe={kernelName:EI,backendName:"cpu",kernelFunc:function TRe(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.data.get(o.dataId).values,l=e.data.get(i.dataId).values[0],[u,c,d]=d5(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function h5(n,t){const e=Jn("int32",n.length);for(let r=0;r<n.length;++r)e[r]=Uye(n[r]).modulo(t).getLowBitsUnsigned();return e}const IRe={kernelName:II,backendName:"cpu",kernelFunc:function ERe(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=h5(e.data.get(o.dataId).values,s);return e.makeTensorInfo(o.shape,"int32",a)}},kRe=Ht(Sm,n=>Math.tan(n)),NRe={kernelName:Sm,backendName:"cpu",kernelFunc:kRe},DRe=Ht(Tm,n=>Math.tanh(n));function p5(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=_t(e,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(n.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%n.shape[l];const a=n.locToIndex(i);r.values[s]=n.values[a]}return r}const ug=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function f5(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=t-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2);f5(n,t,Math.max(e,Math.floor(t-l*c/a+d)),Math.min(r,Math.floor(t+(a-l)*c/a+d)))}const s=n[t];let o=e,i=r;for(El(n,e,t),ug(n[r],s)>0&&El(n,e,r);o<i;){for(El(n,o,i),o++,i--;ug(n[o],s)<0;)o+=1;for(;ug(n[i],s)>0;)i-=1}0===ug(n[e],s)?El(n,e,i):(i+=1,El(n,i,r)),i<=t&&(e=i+1),t<=i&&(r=i-1)}}function m5(n,t,e,r,s){const o=t[t.length-1],[i,a]=[n.length/o,o],l=Ar(e,i*r),u=Ar("int32",i*r);for(let d=0;d<i;d++){const h=d*a,p=n.subarray(h,h+a);let f=new Array(p.length);p.forEach((b,_)=>f[_]={value:b,index:_}),r<f.length&&(f5(f,r),f=f.slice(0,r)),s&&f.sort(ug);const m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}const c=t.slice();return c[c.length-1]=r,[_t(c,e,l),_t(c,"int32",u)]}function g5(n,t,e){switch(e){case"reflect":return function LRe(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return Hu(0,e,t-1)}(n,t);case"wrap":return function VRe(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),Hu(0,e,t-1)}(n,t);case"nearest":return function zRe(n,t){return Hu(0,n,t-1)}(n,t);default:return function BRe(n,t){return n}(n)}}function cg(n,t,e,r,s,o,i,a,l,u,c){return 0<=a&&a<t&&0<=l&&l<e?n[i*r+a*s+l*o+u]:c}function URe(n,t,e,r,s,o,i,a,l,u,c){return cg(n,t,e,r,s,o,i,Math.round(a),Math.round(l),u,c)}function WRe(n,t,e,r,s,o,i,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),p=d+1,f=h+1;return(p-a)*((f-l)*cg(n,t,e,r,s,o,i,d,h,u,c)+(l-h)*cg(n,t,e,r,s,o,i,d,f,u,c))+(a-d)*((f-l)*cg(n,t,e,r,s,o,i,p,h,u,c)+(l-h)*cg(n,t,e,r,s,o,i,p,f,u,c))}function y5(n,t,e,r){const s=bt(t,e)[0],o=[1,e[0],1];for(let f=0;f<s;f++)o[0]*=e[f];o[1]=e[s];for(let f=s+1;f<e.length;f++)o[2]*=e[f];const i={},a=new Int32Array(e[s]),l=new jr(o,r,n),u=[],c=1===o[0]&&1===o[2];for(let f=0;f<e[s];f++){let m;if(c)m=n[f].toString();else{const g=[];for(let y=0;y<o[0];y++)for(let b=0;b<o[2];b++)g.push(l.get(y,f,b));m=g.join(",")}if(void 0!==i[m])a[f]=i[m];else{const g=Object.keys(i).length;i[m]=g,a[f]=g,u.push(f)}}const d=o.slice();d[1]=Object.keys(i).length;const h=new jr(d,r);u.forEach((f,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)h.set(l.get(g,f,y),g,m,y)});const p=e.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:a}}const YRe=[ZIe,QIe,eke,nke,qIe,ske,ake,uke,dke,pke,mke,yke,_ke,xke,Tke,Ike,Nke,Ake,$ke,XIe,Fke,Lke,Bke,Uke,HIe,Gke,jke,WIe,qke,Xke,Yke,Qke,eNe,nNe,sNe,iNe,lNe,cNe,hNe,fNe,gNe,bNe,vNe,wNe,SNe,CNe,INe,kNe,NNe,DNe,FNe,OIe,PNe,LNe,jNe,qNe,KNe,YNe,sDe,oDe,aDe,uDe,hDe,fDe,gDe,bDe,vDe,xDe,TDe,FIe,EDe,Kke,kDe,DDe,RDe,MIe,ODe,MDe,LDe,BDe,UDe,HDe,qDe,YDe,QDe,eAe,tAe,rAe,oAe,aAe,uAe,dAe,pAe,mAe,yAe,_Ae,wAe,TAe,IAe,RNe,NAe,RAe,FAe,LAe,BAe,UAe,GAe,HAe,K8,XAe,LIe,ZAe,o2e,a2e,u2e,d2e,GIe,ED,p2e,VIe,BIe,KIe,m2e,y2e,_2e,w2e,S2e,T2e,E2e,k2e,D2e,F2e,P2e,z2e,UIe,W2e,H2e,q2e,Mke,CAe,X2e,Z2e,J2e,tRe,rRe,oRe,aRe,uRe,hRe,pRe,mRe,yRe,_Re,xRe,CRe,IRe,JNe,$Ne,NRe,{kernelName:Tm,backendName:"cpu",kernelFunc:DRe},{kernelName:Cm,backendName:"cpu",kernelFunc:function RRe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;Re(s,"tile");const i=p5(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:kI,backendName:"cpu",kernelFunc:function ORe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:i}=r;Re(s,"topk");const a=e.data.get(s.dataId).values,[l,u]=m5(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:NI,backendName:"cpu",kernelFunc:function MRe(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=Be(s.shape),b=y[0],_=y[1],v=y[2],w=Be(g),S=w[0],T=w[1],I=w[2],N=Ar(s.dtype,ne(g));N.fill(l);const R=r.data.get(s.dataId).values,F=r.data.get(o.dataId).values;for(let q=0;q<c;++q){const X=1===o.shape[0]?F:F.subarray(8*q,8*q+8);for(let Q=0;Q<f;++Q)for(let V=0;V<m;++V)for(let G=0;G<p;++G){let W;const Y=X[6]*V+X[7]*Q+1;if(0===Y)continue;const le=(X[3]*V+X[4]*Q+X[5])/Y,pe=g5((X[0]*V+X[1]*Q+X[2])/Y,h,a),he=g5(le,d,a);switch(i){case"nearest":W=URe(R,d,h,b,_,v,q,he,pe,G,l);break;case"bilinear":W=WRe(R,d,h,b,_,v,q,he,pe,G,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}N[q*S+Q*T+V*I+G]=W}return r.makeTensorInfo(g,s.dtype,N)}return{dataId:r.write(N,g,s.dtype),shape:s.shape,dtype:s.dtype}}},oke,{kernelName:DI,backendName:"cpu",kernelFunc:function GRe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;Re(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=y5(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:gv,backendName:"cpu",kernelFunc:function jRe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==o&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const h=new Array(a);for(let p=0;p<h.length;p++){c[o]=p;const f=gc({inputs:{x:s},backend:e,attrs:{begin:c,size:d}});h[p]=cn({inputs:{x:f},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(f)}return h}},{kernelName:yv,backendName:"cpu",kernelFunc:function KRe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:i}=r;Re(s,"unsortedSegmentSum");const u=[],c=[],d=s.shape.length-o.shape.length;let h=o;for(let f=0;f<d;++f){const m=Rw({inputs:{input:h},backend:e,attrs:{dim:f+1}});h=m,c.push(m)}for(let f=0;f<i;++f){const m=Nl(f,"int32"),g=e.makeTensorInfo([],"int32",m),y=T8({inputs:{a:g,b:h},backend:e}),b=Yl({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),_=Aw({inputs:{a:b,b:s},backend:e}),v=lg({inputs:{x:_},backend:e,attrs:{axis:0,keepDims:!1}});u.push(v),c.push(g),c.push(y),c.push(b),c.push(_),c.push(v)}const p=q8({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},WAe];for(const n of YRe)FI(n);const Zl={},Fw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function wi(n,t){if(!(n in Zl)||null!=t){const r=function JRe(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=null==t?function QRe(n){if("undefined"!=typeof OffscreenCanvas&&2===n)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n):t;return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Zl[n]},!1),ee().getBool("SOFTWARE_WEBGL_ENABLED")&&(Fw.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",Fw)||e.getContext("experimental-webgl",Fw):e.getContext("webgl2",Fw)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;Zl[n]=r}const e=Zl[n];return null==e||e.isContextLost()?(delete Zl[n],wi(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Zl[n])}var wh=(()=>{return(n=wh||(wh={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",wh;var n})(),Vs=(()=>{return(n=Vs||(Vs={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",Vs;var n})(),kr=(()=>{return(n=kr||(kr={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",kr;var n})();function dg(n,t){return[t,n]}function Mw(n){const t=ne(n);return RE(Math.ceil(t/4))}function xh(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function AD(n,t){const e=n;let r,s,o,i,a,l,u,c,d,h;return 2===ee().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=n.RGBA,s=n.RGBA,o=n.RGBA,i=e.RGBA,a=n.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function _e(n,t){const e=t();return ee().getBool("DEBUG")&&function n$e(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function i$e(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function o$e(n){return!!(ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function Pw(n,t){return Ba(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const u$e=/ERROR: [0-9]+:([0-9]+):/g;function b5(n,t){const e=u$e.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),o=s.length.toString().length+2,i=s.map((d,h)=>Gd((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Gd(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function RD(n,t){if(_e(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function _5(n,t,e,r,s,o,i){const a=n.getAttribLocation(t,e);return-1!==a&&(_e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),_e(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,o,i)),_e(n,()=>n.enableVertexAttribArray(a)),!0)}function v$e(n,t,e,r){_e(n,()=>function y$e(n,t,e){(function w5(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),_e(n,()=>n.activeTexture(n.TEXTURE0+e)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),_e(n,()=>n.uniform1i(e,r))}function $D(n,t,e){_e(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),_e(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function v5(n,t){_e(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),_e(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Lw(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function w$e(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Ba(n,t,e){const r=_e(n,()=>t());if(null==r)throw new Error(e);return r}function Sh(n,t=2){return ne(n.slice(0,n.length-t))}function Th(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Vw(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Sh(n),...Th(n)]),t}function Bw(n){return n%2==0}function zw(n,t){if(zt(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r||Bw(e)&&Bw(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&Bw(n[0])&&Bw(t[0])}let Uw,Ww;function Go(n,t){return null!=n.getExtension(t)}function x5(n){try{if(null!=wi(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function OD(n){const t=AD(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(o),i}function hg(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&C("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Pe=ee();function ls(){let n,t,e,r,s,o,i,a,l,u;return 2===ee().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=ee().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function yc(n,t,e="index"){const r=Be(t);return r.map((s,o)=>`int ${n[o]} = ${e} / ${s}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`};`).join("")}function Gw(n,t,e="index"){const r=Be(t);return r.map((s,o)=>`int ${n[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`};`).join("")}function FD(n){const t=Be(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Pe.registerFlag("HAS_WEBGL",()=>Pe.getNumber("WEBGL_VERSION")>0),Pe.registerFlag("WEBGL_VERSION",()=>x5(2)?2:x5(1)?1:0),Pe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Pe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Pe.get("WEBGL_VERSION")),Pe.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Pe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Pe.registerFlag("WEBGL_PACK",()=>Pe.getBool("HAS_WEBGL")),Pe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_PACK_CLIP",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_PACK_REDUCE",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_CONV_IM2COL",()=>Pe.getBool("WEBGL_PACK")),Pe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function S$e(n){if(null==Uw){const t=wi(n);Uw=t.getParameter(t.MAX_TEXTURE_SIZE)}return Uw}(Pe.getNumber("WEBGL_VERSION"))),Pe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function T$e(n){if(null==Ww){const t=wi(n);Ww=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ww)}(Pe.getNumber("WEBGL_VERSION"))),Pe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Pe.getNumber("WEBGL_VERSION");return 0===n?0:function C$e(n){if(0===n)return 0;let t;const e=wi(n);return t=Go(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Go(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Pe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Pe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!WW()),Pe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function E$e(n){if(0===n)return!1;const t=wi(n);if(1===n){if(!Go(t,"OES_texture_float"))return!1}else if(!Go(t,"EXT_color_buffer_float"))return!1;return OD(t)}(Pe.getNumber("WEBGL_VERSION"))),Pe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Pe.getBool("WEBGL_FORCE_F16_TEXTURES")&&Pe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Pe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function I$e(n){if(0===n)return!1;const t=wi(n);if(1!==n){if(Go(t,"EXT_color_buffer_float"))return OD(t);const r="EXT_color_buffer_half_float";if(Go(t,r)){const s=t.getExtension(r);return function k$e(n,t){const e=AD(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}(t,s)}return!1}return!(!Go(t,"OES_texture_float")||!Go(t,"WEBGL_color_buffer_float"))&&OD(t)}(Pe.getNumber("WEBGL_VERSION"))),Pe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function N$e(n){return 2===n&&null!=wi(n).fenceSync}(Pe.getNumber("WEBGL_VERSION"))),Pe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Pe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Pe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Pe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>WW()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Pe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Pe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Pe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Pe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Pe.registerFlag("WEBGL_EXP_CONV",()=>!1),Pe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Pe.getBool("IS_TEST")),Pe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Pe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Pe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Pe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const S5="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:T5}=I0;function R$e(n,t,e){const r=[];if(n.forEach(p=>{const f=ne(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),e.enableShapeUniforms){const{uniformShape:m}=PD(e.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`)}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join("\n"),o=n.map(p=>function $$e(n,t,e=!1,r){let s="";return s+=e?C5(n,r):Ch(n,r),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function hOe(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=T5(n.shapeInfo.logicalShape,t.logicalShape),l=dn(i),u=i-o;let c;const d=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+u]} = 0;`).join("\n");let h="";h=i<2&&o>0?"coords":n.shapeInfo.logicalShape.map((b,_)=>`coords.${d[_+u]}`).join(", ");let p="return outputValue;";const m=1===ne(n.shapeInfo.logicalShape),y=1===ne(t.logicalShape);if(1!==o||m||y){if(m&&!y)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=o-2,_=o-1;a.indexOf(b)>-1&&a.indexOf(_)>-1?p="return vec4(outputValue.x);":a.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(_)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(n,t):function pOe(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&zt(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=dn(l),c=T5(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let h;const p=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(m=>`coords.${p[m+d]} = 0;`).join("\n");let f="";return f=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(n,t)),s}(p,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),i=t.texShape,a=ls(),l=function M$e(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let u,c,d=function V$e(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${B$e}\n    ${z$e}\n    ${U$e}\n  `}(a);return t.isPacked?(u=function O$e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function G$e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function Q$e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(zt(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function j$e(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),o=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function K$e(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),o=s*Math.ceil(n[n.length-2]/2);let i=o,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)i*=n[n.length-u-1],a=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+a,l=`b${u}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,i,e.enableShapeUniforms),c=function L$e(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(u=function F$e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function H$e(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function J$e(n,t,e){return zt(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function q$e(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Gw(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=yc(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function X$e(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Gw(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=yc(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function Y$e(n,t){const e=yc(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function Z$e(n,t){const e=yc(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,e.enableShapeUniforms),c=function P$e(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=W$e),[d,l,c,s,u,o,e.userCode].join("\n")}function Ch(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function tOe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,o]=n.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=bc(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function rOe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Eh(n)}\n      }\n    `;const s=n.shapeInfo.texShape,o=s[0],i=s[1];if(1===i&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=bc(e);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function oOe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(null!=o&&zt(e,o))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=Il(e);if(i.length<e.length){const p=["row","col"];return`\n      ${Ch(Ih(n,i),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${kh(p,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Eh(n)}\n      }\n    `;const u=o[0],c=o[1],d=bc(r);return 1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function aOe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=Il(e);if(a.length<e.length){const g=["row","col","depth"];return`\n        ${Ch(Ih(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${kh(g,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1)));\n        ${Eh(n)}\n      }\n    `;const c=n.shapeInfo.texShape,d=c[0],h=c[1],p=n.shapeInfo.flatOffset;if(h===o&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=bc(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function uOe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:u}=Il(e);if(l.length<e.length){const _=["row","col","depth","depth2"];return`\n      ${Ch(Ih(n,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${kh(_,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1)));\n        ${Eh(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=bc(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function cOe(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],o=t[3]*s,i=t[2]*o,a=t[1]*i,{newShape:l,keptDims:u}=Il(t);if(l.length<t.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${Ch(Ih(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${kh(g,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${Eh(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1];if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${bc(e)};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function dOe(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=Il(t);if(s.length<t.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ch(Ih(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${kh(y,o)});\n      }\n    `}const i=t[5],a=t[4]*i,l=t[3]*a,u=t[2]*l,c=t[1]*u;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Eh(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${bc(e)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function C5(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function eOe(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${ls().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function nOe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,o=ls();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function sOe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],l=ls();if(null!=o&&zt(e,o))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function iOe(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const p=[1,2],m=["b","row","col"];return`\n        ${C5(Ih(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${kh(m,p)});\n        }\n      `}const a=ls();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(e[1]/2)}, ${c}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function lOe(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=ls();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],d=Math.ceil(o[i-1]/2);let h=d*Math.ceil(o[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=o[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const B$e="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",z$e="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",U$e="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",W$e="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function bc(n){return`offset${n}`}function Eh(n){const t=n.name,e=ne(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function dn(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function PD(n,t,e){const{newShape:r,keptDims:s}=Il(t),o=t.length,i=n&&3===o&&1===t[0],a=i?t.slice(1):r,l=!n&&o>1&&!zt(t,e)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:s}}function Ih(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function kh(n,t){return t.map(e=>n[e]).join(", ")}function I5(n,t,e){const r={},s={},o={},i=[];let a,l,u,c=null,d=null;d=n.getUniformLocation(e,"NAN",!1),1===ee().getNumber("WEBGL_VERSION")&&(c=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(let p=0;p<t.variableNames.length;p++){const f=t.variableNames[p];r[f]=n.getUniformLocation(e,f,h),r[`offset${f}`]=n.getUniformLocation(e,`offset${f}`,h),t.enableShapeUniforms&&(s[`${f}Shape`]=n.getUniformLocation(e,`${f}Shape`,h),o[`${f}TexShape`]=n.getUniformLocation(e,`${f}TexShape`,h))}return t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",h),u=n.getUniformLocation(e,"outShapeStrides",h),l=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms&&t.customUniforms.forEach((p,f)=>{i[f]=n.getUniformLocation(e,p.name,h)}),{uniformLocations:r,customUniformLocations:i,infLoc:c,nanLoc:d,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:l}}function k5(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,o=t[r],i=o.shape;if(!zt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!zt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function us(n){return ee().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class yOe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=wh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ls();this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Gw(["r","c","d"],t):yc(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class bOe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=wh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ls();this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Gw(["r","c","d"],t):yc(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class _Oe{constructor(t){this.variableNames=["A"],this.outTexUsage=Vs.DOWNLOAD;const e=ls();this.outputShape=t,this.userCode=`\n      ${S5}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class vOe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Vs.DOWNLOAD;const e=ls();this.outputShape=t,this.userCode=`\n      ${S5}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const wOe={R:0,G:1,B:2,A:3};class N5{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ls();this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++)i+=`\n          if(offset == ${a}) {\n            result = values[${wOe[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":FD(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${i}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class xOe{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ls();this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length);let s="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=2*i+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":FD(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function pg(n,t,e,r,s,o){!function m$e(n,t){const e=ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const i=function f$e(n){return Ba(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return _e(n,()=>n.bindTexture(a,i)),_e(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),_e(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),_e(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),_e(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===ee().getNumber("WEBGL_VERSION")?_e(n,()=>n.texImage2D(a,0,r,t,e,0,s,o,null)):_e(n,()=>n.texStorage2D(a,1,r,t,e)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function D5(n){return n.internalFormatFloat}function A5(n){return n.internalFormatHalfFloat}function R5(n){return n.downloadTextureFormat}function $5(n){return n.internalFormatPackedFloat}function O5(n){return n.internalFormatPackedHalfFloat}class LD{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=ee().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function ZRe(n,t){Zl[n]=t}(e,t)):this.gl=wi(e),t=this.gl,2===ee().getNumber("WEBGL_VERSION")){const o=t;this.createVertexArray=()=>_e(o,()=>o.createVertexArray()),this.bindVertexArray=i=>_e(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>_e(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>_e(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=t){const o=t.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>_e(t,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>_e(t,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>_e(t,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>_e(t,()=>t.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===ee().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=Pw(this.gl,"OES_texture_float"),Go(this.gl,i))this.textureHalfFloatExtension=Pw(this.gl,i);else if(ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Go(this.gl,s))this.colorBufferHalfFloatExtension=Pw(this.gl,s);else if(ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Go(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Go(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function TOe(n){return function h$e(n,t){const e=Ba(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return _e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),_e(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function COe(n){return function p$e(n,t){const e=Ba(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return _e(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),_e(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function g$e(n){return Ba(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=AD(this.gl,this.textureHalfFloatExtension)}get debug(){return ee().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;_e(t,()=>t.finish()),_e(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),_e(t,()=>t.deleteFramebuffer(this.framebuffer)),_e(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),_e(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),_e(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function EOe(n,t,e,r){const[s,o]=dg(t,e);return pg(n,s,o,D5(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function IOe(n,t,e,r){const[s,o]=dg(t,e);return pg(n,s,o,A5(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function kOe(n,t,e,r){const[s,o]=dg(t,e);return pg(n,s,o,R5(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function $Oe(n,t,e){_e(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===ee().getNumber("WEBGL_VERSION")?_e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):_e(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===ee().getNumber("WEBGL_VERSION")?_e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):_e(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function ROe(n,t,e,r,s,o){let i,a,l;_e(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(e*r*4),a=n.FLOAT,l=o.internalFormatPackedFloat),i.set(s),2===ee().getNumber("WEBGL_VERSION")?_e(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,i)):_e(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,i)),_e(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function DOe(n,t,e,r){const[s,o]=xh(t,e);return pg(n,s,o,O5(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function NOe(n,t,e,r){const[s,o]=xh(t,e);return pg(n,s,o,$5(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(v5(this.gl,this.framebuffer),this.outputTexture=null),_e(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function MOe(n,t,e,r){const[s,o]=dg(t,e),a=new Uint8Array(function e$e(n,t){return n*t}(t*e,4));return _e(n,()=>n.readPixels(0,0,s,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,o,i){return function POe(n,t,e,r,s,o,i,a){const l=n,u=new Float32Array(function t$e(n,t){const[e,r]=xh(n,t);return e*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(t,e){return function FOe(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function OOe(n,t,e,r){const s=n.createBuffer();_e(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return _e(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),_e(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),_e(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(ee().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function LOe(n,t,e){const r=new Float32Array(t*e*4);return _e(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function SOe(n){const t=ls();return function a$e(n,t){const e=Ba(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(_e(n,()=>n.shaderSource(e,t)),_e(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function c$e(n){return Ba(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);let s;return _e(e,()=>e.attachShader(r,this.vertexShader)),_e(e,()=>e.attachShader(r,t)),function d$e(n,t){if(_e(n,()=>n.linkProgram(t)),!ee().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r),s=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(s.vao),_e(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(function AOe(n,t,e){return _e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),_5(n,t,"clipSpacePos",e,3,20,0)&&_5(n,t,"uv",e,2,20,12)}(e,s,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&RD(e,s),this.setProgram(s),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(_e(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&RD(this.gl,this.program)),_e(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function b$e(n,t,e){return Ba(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function _$e(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),_e(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),v$e(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,o]=xh(e,r);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&RD(this.gl,this.program),Lw(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}_e(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),_e(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Pw(this.gl,2===ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return $(function*(){return yield hW(()=>e.disposed||e.isQueryAvailable(t,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function VOe(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in ee().platform&&(r=ee().platform.setTimeoutCustom.bind(ee().platform)),hW(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),$D(this.gl,t,this.framebuffer),this.debug&&Lw(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?($D(this.gl,this.outputTexture,this.framebuffer),this.debug&&Lw(this.gl)):v5(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;$D(s,t,this.framebuffer),this.debug&&Lw(s),this.outputTexture=t,_e(s,()=>s.viewport(0,0,e,r)),_e(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),_e(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:BOe,bincountImpl:F5,bincountReduceImpl:zOe,castImpl:UOe,ceilImpl:WOe,concatImpl:GOe,equalImpl:HOe,expImpl:jOe,expm1Impl:qOe,floorImpl:KOe,gatherNdImpl:XOe,gatherV2Impl:YOe,greaterImpl:ZOe,greaterEqualImpl:QOe,lessImpl:JOe,lessEqualImpl:eFe,linSpaceImpl:tFe,logImpl:nFe,maxImpl:rFe,maximumImpl:sFe,minimumImpl:oFe,multiplyImpl:iFe,negImpl:aFe,notEqualImpl:lFe,prodImpl:uFe,raggedGatherImpl:cFe,raggedRangeImpl:dFe,raggedTensorToTensorImpl:hFe,rangeImpl:pFe,rsqrtImpl:fFe,scatterImpl:mFe,sigmoidImpl:gFe,simpleAbsImpl:M5,sliceImpl:yFe,sparseFillEmptyRowsImpl:bFe,sparseReshapeImpl:_Fe,sparseSegmentReductionImpl:P5,sqrtImpl:vFe,stridedSliceImpl:wFe,stringNGramsImpl:xFe,stringSplitImpl:SFe,stringToHashBucketFastImpl:TFe,subImpl:CFe,tileImpl:EFe,topKImpl:IFe,transposeImpl:VD,uniqueImpl:kFe}=k0;function L5(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function cs(n,t){return 1===t?[n]:L5(n,t)}class DFe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=us(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=cs("rc",this.rank),r=dn(this.rank),s=this.getOutOfBoundsCondition(e),o=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${t[t.length-1-i]},`+o;e.push(o)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class V5{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function AFe(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function A$e(n,t,e="index"){const s=function D$e(n,t){const e=n.length,r=n.map(o=>`${t}[${o}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let o=e-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(n.map((o,i)=>i),t);return s.map((o,i)=>`int ${n[i]} = ${e} / ${s[i]}; ${i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s[i]}`:`index -= ${n[i]} * ${s[i]}`};`).join("")}(["r","c","d"],"inputShape"):yc(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":FD(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class RFe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,r){const s=z5(e,r),o=U5(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=B5(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].shift();return this.usedTextures[o].push(l),l}let a;return s===kr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===kr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===kr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===kr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===kr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const o=z5(r,s),i=U5(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=B5(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=ee().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function B5(n,t,e,r,s){const o=function OFe(n,t){switch(n){case kr.PACKED_2X2_FLOAT32:return $5(t);case kr.PACKED_2X2_FLOAT16:return O5(t);case kr.UNPACKED_FLOAT32:return D5(t);case kr.UNPACKED_FLOAT16:return A5(t);case kr.PACKED_4X1_UNSIGNED_BYTE:return R5(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let i;if(s){const[l,u]=xh(n[0],n[1]);i=l*u}else{const[l,u]=dg(n[0],n[1]);i=l*u}const a=function $Fe(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,o);return i*a}function z5(n,t){if(n===Vs.UPLOAD)return kr.PACKED_2X2_FLOAT32;if(n===Vs.RENDER||null==n)return function FFe(n){return ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?kr.PACKED_2X2_FLOAT32:kr.UNPACKED_FLOAT32:n?kr.PACKED_2X2_FLOAT16:kr.UNPACKED_FLOAT16}(t);if(n===Vs.DOWNLOAD||n===Vs.PIXELS)return kr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function U5(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class ra{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const W5="return abs(x);",Ql="return x;";class Jl{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class jFe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length);const e=t.length,r=cs("rc",e),s=dn(e),o=function NFe(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const qFe=FH,jw={},ZFe=ee().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let eMe=(()=>{class n extends NE{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ee().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof LD)r=e;else{const s=wi(ee().getNumber("WEBGL_VERSION"),e);r=new LD(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=wi(ee().getNumber("WEBGL_VERSION"));r=new LD(s),this.binaryCache=function YFe(n){return n in jw||(jw[n]={}),jw[n]}(ee().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new RFe(this.gpgpu),this.numMBBeforeWarning=function JFe(){return null==ee().global.screen?1024:ee().global.screen.height*ee().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new cW(this,ji())}nextDataId(){return n.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,o,i,a){const l=this.makeTensorInfo(r,s),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[o,i]},u.texShape=[o,i];const c=Vw(r),d=new N5(c,!1,a),h=this.runWebGLProgram(d,[l],s,[[o,i]]);return h.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,r,s){if((ee().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ee().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:Vs.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if(ee().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:Vs.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(null!=a){let p;p=u?new Jl(l,Ql):new ra(l,Ql);const f=this.runWebGLProgram(p,[{dataId:e,shape:l,dtype:o}],o),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const c=null!=this.activeTimers;let d,h;return c&&(d=Hr()),h="complex64"===o?Ma(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=Hr()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return $(function*(){if(r.pendingRead.has(e)){const g=r.pendingRead.get(e);return new Promise(y=>g.push(y))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=s;if(null!=a){let g;g=c?new Jl(i,Ql):new ra(i,Ql);const y=r.runWebGLProgram(g,[{dataId:e,shape:i,dtype:l}],l),b=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),b}if(null!=o)return r.convertAndCacheOnCPU(e);if(ee().getBool("DEBUG")&&!ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ee().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,p,d=null;if("complex64"!==l&&ee().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture.texture,...Mw(i))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);p=Ma(g[0],g[1])}else if(null==d)p=r.getValuesFromTexture(e);else{const g=ne(i);p=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const g=r.gpgpu.gl;_e(g,()=>g.deleteBuffer(d))}const f=r.convertAndCacheOnCPU(e,p),m=r.pendingRead.get(e);return r.pendingRead.delete(e),m.forEach(g=>g(f)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&ji().removeDataId(e,r),r.pendingDeletes--),f})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:o,shape:i,slice:a,dtype:l,isPacked:u,texture:c}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let f;f=u?new Jl(i,Ql):new ra(i,Ql);const m=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:l}],l),g=this.readToGPU(m,r);return this.disposeIntermediateTensorInfo(m),g}if(null==c)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=ji().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>Al(o));return _t(e.shape,e.dtype,s)}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return _t(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!o$e(s))throw ee().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=ne(r);if(ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),f=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...Mw(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(p),m}const a=ee().getBool("WEBGL_PACK")&&!0===o,l=a?Vw(r):r,u=a?new vOe(l):new _Oe(l),c=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,o=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=o,i=!0):this.activeTimers.push(o),this.activeTimers=o,e();const a=Xu(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=Xu(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=s,i&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return $(function*(){if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=function xye(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Hr(),endMs:null}}endTimer(e){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Hr(),e)}getQueryTime(e){var r=this;return $(function*(){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=ZFe){return ee().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&ne(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){to("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return qFe(e.shape,r)}packedUnaryOp(e,r,s){const o=new Jl(e.shape,r),i=this.compileAndRun(o,[e],s);return ji().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=M5(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(ee().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,W5,e.dtype);const r=new ra(e.shape,W5),s=this.compileAndRun(r,[e]);return ji().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&Df(s[0])){const i=s.map(a=>Dl(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){return ji().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new jFe(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new DFe(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Sh(e.shape),...Th(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Sh(r),...Th(r)],a=new V5(i,s),c=this.runWebGLProgram(a,[o],e.dtype,[s],!0);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:o,shape:i,dtype:a}=s;null!=r&&C(ne(i)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=Vw(i);let u;u=o?new bOe(l):new yOe(l);const d=[null!=r?r:Mw(l)];return{dtype:a,shape:i,dataId:this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,o,i=!1,a){const l=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===wh.DENSE){const b=null!=a?a:Mw(e.outputShape);u.texShape=b.map(_=>2*_)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===ne(l.shape))return u.values=Ar(l.dtype,0),l;const c=[],d=r.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let _=this.texData.get(b.dataId);if(null==_.texture){if(!e.packedInputs&&ne(b.shape)<=ee().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:_.values};e.packedInputs&&(_.isPacked=!0,_.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!_.isPacked!=!!e.packedInputs)b=_.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),_=this.texData.get(b.dataId);else if(_.isPacked&&!zw(_.shape,b.shape)){const v=b,w=b.shape;b.shape=_.shape,b=this.packedReshape(b,w),c.push(b),_=this.texData.get(b.dataId),v.shape=w}return{shape:b.shape,texData:_,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:u,isUniform:!1},p=function gOe(n,t,e){let r="";t.concat(e).forEach(i=>{const a=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=PD(n.packedInputs,i.shape,l);let h="",p="",f="";if(1===c.length&&n.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(2!==c.length||n.packedInputs){if(c.length>2&&!n.packedInputs){const w=Be(c);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}}else p=`${c[0]>1}_${c[1]>1}`;const m=i.shape.length,g=2===c.length&&zt(i.shape,l),y=1===ne(i.shape),b=nh(i.shape,e.shape),_=!n.packedInputs&&m===e.shape.length&&zt(l,e.texData.texShape);r+=`${m}_${_}_${u?d:""}_${c.length}_${y}_${b}_${g}_${h}_${p}_${f}_${n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${a}`});let o=n.constructor.name;return o+="_"+r+"_"+n.userCode+`${ee().getNumber("WEBGL_VERSION")}`,o}(e,d,h),f=this.getAndSaveBinary(p,()=>function fOe(n,t,e,r){const s=e.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),o=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=R$e(s,i,t),l=function l$e(n,t){const e=Ba(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(_e(n,()=>n.shaderSource(e,t)),_e(n,()=>n.compileShader(e)),ee().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw b5(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),u=n.createProgram(l);return ee().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},I5(n,t,u))}(this.gpgpu,e,d,h)),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),ee().get("ENGINE_COMPILE_ONLY")||function mOe(n,t,e,r,s){t.program.enableShapeUniforms||(k5(t.inShapeInfos,e),k5([t.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(t.webGLProgram),1===ee().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,u)=>{const c=t.program.variableNames[u],d=t.uniformLocations[c],h=t.uniformLocations[`offset${c}`],p=t.inShapesLocations[`${c}Shape`],f=t.inTexShapesLocations[`${c}TexShape`];if(p){const{uniformShape:m}=PD(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(p,new Int32Array(m));break;case 2:n.gl.uniform2iv(p,new Int32Array(m));break;case 3:n.gl.uniform3iv(p,new Int32Array(m));break;case 4:n.gl.uniform4iv(p,new Int32Array(m))}}if(f&&n.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),null!=d){if(l.isUniform){if(ne(l.shape)<2)n.gl.uniform1f(d,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}return}null!=l.texData.slice&&null!=h&&n.gl.uniform1i(h,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,d,u)}});const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=Be(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((l,u)=>{const c=t.customUniformLocations[u],d=s[u];if("float"===l.type)n.gl.uniform1fv(c,d);else if("vec2"===l.type)n.gl.uniform2fv(c,d);else if("vec3"===l.type)n.gl.uniform3fv(c,d);else if("vec4"===l.type)n.gl.uniform4fv(c,d);else if("int"===l.type)n.gl.uniform1iv(c,d);else if("ivec2"===l.type)n.gl.uniform2iv(c,d);else if("ivec3"===l.type)n.gl.uniform3iv(c,d);else{if("ivec4"!==l.type)throw Error(`uniform type ${l.type} is not supported yet.`);n.gl.uniform4iv(c,d)}}),n.executeProgram()}(this.gpgpu,f,d,h,o),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=ee().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=Hr();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!ee().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===i){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ee().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=te(()=>{if(!ee().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ee().getBool("DEBUG");ee().set("DEBUG",!1);const r=this.abs(Je(1e-8)).dataSync()[0];if(ee().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:u}=r;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=Hr());let h=r.texShape;if(null==h&&(h=function x$e(n,t=!1){let e=ee().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ee().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&ee().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,l)=>l>=n.length-2?DE(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=Il(n).newShape);let s=ne(n),o=null;n.length<=1&&s<=e?o=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?o=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?o=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?o=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?o=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(o=[n[0],n[1]*n[2]*n[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||i)if(t){const a=Sh(n);let l=2,u=2;n.length&&([l,u]=Th(n)),s=a*(l/2)*(u/2),o=RE(s).map(c=>2*c)}else o=RE(s);return o}(s,u),r.texShape=h),null!=i){const p=Vw(s);let f,m=h[1],g=h[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!y)&&([m,g]=xh(h[0],h[1])),f=u?new xOe(p,y):new N5(p,y);const b=y?[g,m]:h,_=this.makeTensorInfo(b,o),v=this.texData.get(_.dataId);v.usage=y?Vs.PIXELS:Vs.UPLOAD,v.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_.dataId),m,g,i);const T=this.runWebGLProgram(f,[_],o,[[g,m]],!0),I=this.texData.get(T.dataId);r.texShape=I.texShape,r.isPacked=I.isPacked,r.usage=I.usage,ee().get("ENGINE_COMPILE_ONLY")?this.disposeData(T.dataId):(r.texture=I.texture,r.values=null,this.texData.delete(T.dataId)),this.disposeIntermediateTensorInfo(_),c&&(this.uploadWaitMs+=Hr()-d)}else{const p=this.acquireTexture(h,l,o,u);r.texture=p}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return null!=r&&(s.values=function tMe(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*y_(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return $(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const o=new Promise(i=>{try{e.checkCompletion_(s),i(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return $(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield aH(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(b5(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:r,customUniformLocations:s,infLoc:o,nanLoc:i,inShapesLocations:a,inTexShapesLocations:l,outShapeLocation:u,outShapeStridesLocation:c,outTexShapeLocation:d}=I5(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=r,e.customUniformLocations=s,e.infLoc=o,e.nanLoc=i,e.inShapesLocations=a,e.inTexShapesLocations=l,e.outShapeLocation=u,e.outShapeStridesLocation=c,e.outTexShapeLocation=d}}createTensorFromGPUData(e,r,s){e.channels=e.channels||"RGBA";const{texture:o,height:i,width:a,channels:l}=e,u=ji().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(o,r,s,i,a,l);return ji().makeTensorFromDataId(c,r,s,u)}}return n.nextDataId=0,n})();GW()&&iG("webgl",()=>new eMe,2);class Nh{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=tt(e,r),this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class mg{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=tt(e,r);const o=this.outputShape.length;this.enableShapeUniforms=us(o);let i="";if(s)if(0===o||1===ne(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${dn(o)} coords = getOutputCoords();\n        `,1===o)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=cs("coords",o);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function Bs(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const sMe={kernelName:Qf,backendName:"webgl",kernelFunc:Bs};function eu(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=Bs({inputs:{x:r},backend:e}),l=Bs({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:l},o}const oMe={kernelName:HE,backendName:"webgl",kernelFunc:eu},G5="return (a < 0.) ? b * a : a;",H5="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",aMe={kernelName:V_,backendName:"webgl",kernelFunc:function iMe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r,i=e.makeTensorInfo([],"float32",Nl(o,"float32")),a=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mg(H5,s.shape,i.shape):new Nh(G5,s.shape,i.shape),l=e.runWebGLProgram(a,[s,i],"float32");return e.disposeIntermediateTensorInfo(i),l}},j5="return (a < 0.) ? b * a : a;",q5="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",uMe={kernelName:sv,backendName:"webgl",kernelFunc:function lMe(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,o=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mg(q5,r.shape,s.shape):new Nh(j5,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],"float32")}};function Ot({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const d=a.texData.get(i.dataId),h=e(d.values,l);return a.makeTensorInfo(i.shape,l,h)}let c;return c=ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Jl(i.shape,t):new ra(i.shape,n),a.runWebGLProgram(c,[i],l)}}function Or({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(r&&"complex64"===l.dtype){const f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(_=>{const[v,w]=_,S={dataId:v.dataId,dtype:v.dtype,shape:l.shape},T={dataId:w.dataId,dtype:w.dtype,shape:u.shape},I=new Nh(n,l.shape,u.shape);return c.runWebGLProgram(I,[S,T],Fs(v.dtype,w.dtype))}),b=eu({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}const d=o||Fs(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g="string"===l.dtype?ac(f):f,y="string"===l.dtype?ac(m):m,[b,_]=s(l.shape,u.shape,g,y,d),v=c.makeTensorInfo(_,d);return c.texData.get(v.dataId).values=b,v}let p;return p=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new mg(t,l.shape,u.shape,e):new Nh(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function gg(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?q5:j5;if("leakyrelu"===n)return t?H5:G5;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class K5{constructor(t,e,r,s=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=us(this.outputShape.length);const d=Math.ceil((s?t[1]:t[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let _="rc.x",v="rc.x";t[0]<e[0]?_=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(v=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${_};\n        int batchB = ${v};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${f[0]} * ${m[0]});\n          result += (${f[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class Y5{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=tt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Z5="return a * b;";function zD(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,o=Fs(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),u=new Y5("return areal * breal - aimag * bimag;",r.shape,s.shape),c=new Y5("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=eu({inputs:{real:h,imag:p},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[u,c]=iFe(r.shape,s.shape,a.values,l.values,o),d=e.makeTensorInfo(c,o);return e.texData.get(d.dataId).values=u,d}let i;return i=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mg(Z5,r.shape,s.shape):new Nh(Z5,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const cMe={kernelName:am,backendName:"webgl",kernelFunc:zD};function Te(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,i=e,a=ne(s.shape),l=pW(o,a),u=ne(l);C(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||zw(s.shape,l)||null!==c.texture&&zw(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function dMe(n,t,e){const r=[Sh(n.shape),...Th(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},o=[Sh(t),...Th(t)],i=new V5(o,r),u=e.runWebGLProgram(i,[s],n.dtype,[r],!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(s,l,i)}const hMe={kernelName:iv,backendName:"webgl",kernelFunc:Te};class Q5{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=t;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${Wd(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class pMe{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=t;this.outputShape=[s,i];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function _c(n,t,e,r){const s=function fMe(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=Zv(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let o=n;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===e?0===i?new Q5({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new Q5({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):new pMe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},e),d=o,o=r.runWebGLProgram(c,[o],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class mMe{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[e[i]];this.outputShape=r,this.rank=r.length;const s=dn(this.rank),o=function gMe(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class yMe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let c=0;c<r.length;c++)r[c]=t[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=dn(this.rank),o=L5("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function qw(n,t,e){const r=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yMe(n.shape,t):new mMe(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function Kw(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r;return function bMe(n,t,e,r){const o=n.shape.length,i=bt(t,n.shape);let a=i;const l=Dn(a,o),u=null!=l;let c=n;u&&(c=qw(n,l,r),a=jn(a.length,o)),$r("sum",a,o);const[d,h]=Sr(c.shape,a);let p=d;e&&(p=Hn(d,i));const f=ne(h),y=Te({inputs:{x:c},attrs:{shape:[ne(n.shape)/f,f]},backend:r}),_=_c(y,VI(n.dtype),"sum",r),v=Te({inputs:{x:_},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(_),u&&r.disposeIntermediateTensorInfo(c),v}(s,o,i,e)}const _Me={kernelName:hv,backendName:"webgl",kernelFunc:Kw};function ds(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:o}=r,i=e,l=new Array(s.shape.length);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=VD(d,s.shape,s.dtype,o,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=h}else u=qw(s,o,i);return u}const vMe={kernelName:qd,backendName:"webgl",kernelFunc:ds};function Xw({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=t.shape.length,d=e?n.shape[u-2]:n.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=e?n.shape[u-1]:n.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=n.shape.slice(0,-2),g=t.shape.slice(0,-2),y=ne(m),b=ne(g),v=tt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);C(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=e?[y,d,p]:[y,p,d],S=r?[b,f,h]:[b,h,f],T=Te({inputs:{x:n},backend:s,attrs:{shape:w}}),I=Te({inputs:{x:t},backend:s,attrs:{shape:S}}),N=[T,I],R=Math.max(y,b),F=e?T.shape[1]:T.shape[2],j=null!=o,q=null!=i,X="leakyrelu"===l,Q=null!=l?gg(l,!0):null;let G;if((1===p||1===f)&&F>1e3&&!1===(j||q||X||null!=Q)){let Y=T,se=I;e&&(Y=ds({inputs:{x:T},backend:s,attrs:{perm:[0,2,1]}}),N.push(Y)),r&&(se=ds({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(se));const pe=1===f;let he=Y;1!==f&&(he=Te({inputs:{x:Y},backend:s,attrs:{shape:[R,F,1]}}),N.push(he));const me=1===f?2:1;let be=se;pe&&(be=Te({inputs:{x:se},backend:s,attrs:{shape:[R,1,F]}}),N.push(be));const Ne=zD({inputs:{a:he,b:be},backend:s});G=Kw({inputs:{x:Ne},backend:s,attrs:{axis:me,keepDims:!0}}),N.push(Ne)}else{const Y=Fs(n.dtype,t.dtype),se=new K5(w,S,[R,p,f],e,r,j,Q,q,X),le=[T,I];if(null!=o&&le.push(o),q&&le.push(i),X){const pe=s.makeTensorInfo([],"float32",Nl(a,"float32"));le.push(pe),N.push(pe)}G=s.runWebGLProgram(se,le,Y)}const W=Te({inputs:{x:G},backend:s,attrs:{shape:v}});N.push(G);for(const Y of N)s.disposeIntermediateTensorInfo(Y);return W}const xMe={kernelName:_v,backendName:"webgl",kernelFunc:function wMe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return Xw({a:s,b:o,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},eq="return abs(x);",TMe={kernelName:__,backendName:"webgl",kernelFunc:function SMe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=M5(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Jl(r.shape,eq):new ra(r.shape,eq),e.runWebGLProgram(s,[r],r.dtype)}},EMe=Ot({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),IMe={kernelName:Rf,backendName:"webgl",kernelFunc:EMe},NMe=Ot({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),DMe={kernelName:$f,backendName:"webgl",kernelFunc:NMe},tq="return a + b;",AMe=Or({opSnippet:tq,packedOpSnippet:tq,supportsComplex:!0,cpuKernelImpl:BOe}),RMe={kernelName:jd,backendName:"webgl",kernelFunc:AMe};class $Me{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class OMe{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const FMe={kernelName:VE,backendName:"webgl",kernelFunc:function Yw(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return Bs({inputs:{x:r[0]},backend:e});if(r.length>ee().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=Yw({inputs:r.slice(0,l),backend:e}),c=Yw({inputs:r.slice(l),backend:e});return Yw({inputs:[u,c],backend:e})}const s=r.map(l=>l.dtype).reduce((l,u)=>Fs(l,u)),o=r.map(l=>l.shape),a=ee().getBool("WEBGL_PACK")?new OMe(r[0].shape,o):new $Me(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},PMe={kernelName:"All",backendName:"webgl",kernelFunc:function MMe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Dn(u,a);let d=s;null!=c&&(d=ds({inputs:{x:s},backend:e,attrs:{perm:c}}),u=jn(u.length,a)),$r("all",u,a);const[h,p]=Sr(d.shape,u),m=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,ne(p)]}}),g=_c(m,m.dtype,"all",e);let y;return y=Te(i?{inputs:{x:g},backend:e,attrs:{shape:Hn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}},VMe={kernelName:"Any",backendName:"webgl",kernelFunc:function LMe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Dn(u,a);let d=s;null!=c&&(d=ds({inputs:{x:s},backend:e,attrs:{perm:c}}),u=jn(u.length,a)),$r("any",u,a);const[h,p]=Sr(d.shape,u),m=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,ne(p)]}}),g=_c(m,m.dtype,"any",e);let y;return y=Te(i?{inputs:{x:g},backend:e,attrs:{shape:Hn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class BMe{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class zMe{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=dn(l),c=cs("coords",l);let d,h;if(1===i){h=l+1;const I=dn(h);d=`\n        ${I} sourceLocR = ${I}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${I} sourceLocG = ${I}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${I} sourceLocA = ${I}(${c.join()}, 0);\n        --${c[l-1]};\n        ${I} sourceLocB = ${I}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map(I=>"int "+I),g=cs("sourceLocR",h-1).concat("inIdx.r"),y=cs("sourceLocG",h-1).concat("inIdx.g"),b=cs("sourceLocB",h-1).concat("inIdx.b"),_=cs("sourceLocA",h-1).concat("inIdx.a"),v="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${_.join()})));`,S=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${_.join()}) : 0.)`,T=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${T}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${S};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${S};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function nq(n,t,e,r=null){let s=t.shape[0],o=t.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=Zv(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new BMe(a,e,null==r),u=[t];null!=r&&u.push(r);const c=n.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=nq(n,t,e,c);return n.disposeIntermediateTensorInfo(c),d}function rq(n,t,e,r=null){const s=null!=r?r.shape:t.shape,i=Zv(s[s.length-1]),a=new zMe(s,i,e,null==r),u=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(u.shape.length===t.shape.length){const c=rq(n,t,e,u);return n.disposeIntermediateTensorInfo(u),c}return u}function sq(n,t,e,r){const s=[e];if($r("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ee().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const o=[],i=n.texData.get(t.dataId);let l=t;null!==i&&i.isPacked&&(l=n.unpackTensor(t),o.push(l));const[u,c]=Sr(l.shape,s),d=ne(c),h=Te({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});o.push(h);const p=nq(n,h,r);o.push(p);const f=Te({inputs:{x:p},backend:n,attrs:{shape:u}});return o.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}return rq(n,t,r)}const WMe={kernelName:v_,backendName:"webgl",kernelFunc:function UMe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let i=bt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=ds({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=jn(i.length,l.shape.length)),$r("argMax",[i[0]],l.shape.length);const c=sq(e,l,i[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},HMe={kernelName:w_,backendName:"webgl",kernelFunc:function GMe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let i=bt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=ds({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=jn(i.length,l.shape.length)),$r("argMin",[i[0]],l.shape.length);const c=sq(e,l,i[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},qMe=Ot({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),KMe={kernelName:Of,backendName:"webgl",kernelFunc:qMe},YMe=Ot({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),ZMe={kernelName:Ff,backendName:"webgl",kernelFunc:YMe},JMe=Ot({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),ePe={kernelName:Mf,backendName:"webgl",kernelFunc:JMe},rPe=Or({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),sPe={kernelName:Lf,backendName:"webgl",kernelFunc:rPe},iPe=Ot({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),aPe={kernelName:Pf,backendName:"webgl",kernelFunc:iPe};class yg{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const m="avg"===e;let b="0.0";if(m||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${p}, ${f});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(i/4),S=i%4,T=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${p}, ${f});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${T}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===S}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${T}\n          } else if (${2===S}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${T}\n          } else if (${3===S}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${T}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class UD{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const _="avg"===e;let v="0.0";if(_||(v="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${g}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${f};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let S=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(S="avgValue / max(count, 1.0)");const T=4*Math.floor(i/4),I=i%4,N=`\n      if (${_}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${g}, ${y}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${T}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${N}\n            }\n\n            int xC = xCCorner + ${T};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${N}\n            }\n          }\n        }\n        setOutput(${S});\n      }\n    `}}const uPe={kernelName:x_,backendName:"webgl",kernelFunc:function lPe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;hg(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;C(Rr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fo(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))return Bs({inputs:{x:s},backend:e});const d=new yg(c,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},dPe={kernelName:S_,backendName:"webgl",kernelFunc:function cPe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,d=Da(s.shape,o,i,[1,1,1],a,l,u),h=new UD(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class hPe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class pPe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const mPe={kernelName:WE,backendName:"webgl",kernelFunc:function fPe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=Da(i.shape,a,l,[1,1,1],u,c),p=new pPe(h);return e.runWebGLProgram(p,[s],i.dtype)}},yPe={kernelName:UE,backendName:"webgl",kernelFunc:function gPe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o;hg([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Fo(i.shape,a,l,1,u),d=new hPe(c);return e.runWebGLProgram(d,[s],i.dtype)}},_Pe={kernelName:T_,backendName:"webgl",kernelFunc:function bPe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;return Xw({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class vPe{constructor(t,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],tt(t,e),tt(t,r);let a="0.0";null!=s&&(tt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(tt(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class wPe{constructor(t,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],tt(t,e),tt(t,r);let a="vec4(0.0)";null!=s&&(tt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(tt(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const xPe={kernelName:M_,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=n;C(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[r,s,o];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=a&&(d=a.shape,u.push(a));const h=ee().getBool("WEBGL_PACK_NORMALIZATION")?new wPe(r.shape,s.shape,o.shape,c,d,l):new vPe(r.shape,s.shape,o.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}};class SPe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=dn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function TPe(n){if(1===n)return"sourceLoc";if(n<=6)return WD.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((i,a)=>`sourceLoc.${WD[a]} = start[${a}] + coords.${WD[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const WD=["x","y","z","w","u","v"];class CPe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=dn(this.rank),r=cs("coords",this.rank),s=cs("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((c,d)=>`start[${d}]`).join()});`:t.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Ah(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:i}=r,[a,l]=Fv(s,o,i);if(hk(s,a,l),0===ne(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=yFe(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=e.texData.get(s.dataId),c=fk(s.shape,a,l);if(u||!c){const d=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CPe(l):new SPe(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function EPe(n,t,e,r){const s=r.texData.get(n.dataId),o=r.makeTensorInfo(e,n.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=n.dtype;let a=mk(t,Be(n.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,e)}const IPe={kernelName:dv,backendName:"webgl",kernelFunc:Ah},kPe={kernelName:C_,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:i}=r;C(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((b,_)=>b*_),l=Gm(s.shape,o,a),u=Hm(l.length,o.length),c=jm(s.shape,o,a),d=Yk(i,o.length),h=Zk(c,i,o.length),p=[],f=Te({inputs:{x:s},backend:e,attrs:{shape:l}}),m=ds({inputs:{x:f},backend:e,attrs:{perm:u}}),g=Te({inputs:{x:m},backend:e,attrs:{shape:c}}),y=Ah({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},DPe={kernelName:GE,backendName:"webgl",kernelFunc:function NPe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i}=r,a=e.readSync(s.dataId),l=e.readSync(o.dataId),u=F5(a,l,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},RPe={kernelName:vW,backendName:"webgl",kernelFunc:function APe(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.readSync(r.dataId),i=e.readSync(s.dataId),a=tt(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},oq=Or({opSnippet:"return float(a != b);",cpuKernelImpl:lFe,dtype:"bool"}),$Pe={kernelName:J_,backendName:"webgl",kernelFunc:oq};function bg(n){const{inputs:t,backend:e}=n,{input:r}=t;return Bs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const OPe={kernelName:gI,backendName:"webgl",kernelFunc:bg},PPe={kernelName:Vf,backendName:"webgl",kernelFunc:function GD(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Bs({inputs:{x:s},backend:e});const i=Tr(s.shape),a=GD({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=eu({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=bg({inputs:{input:s},backend:e}),a=GD({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!fW(s.dtype,o)){const i=Bs({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId).values,[a,l,u]=UOe(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}if("int32"===o)return function MPe(n,t){const e=new ra(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",Ar("bool",1)),l=oq({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},iq="return ceil(x);",LPe=Ot({opSnippet:iq,packedOpSnippet:iq,cpuKernelImpl:WOe}),VPe={kernelName:Bf,backendName:"webgl",kernelFunc:LPe};class BPe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class zPe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const WPe={kernelName:zf,backendName:"webgl",kernelFunc:function UPe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:o,clipValueMax:i}=r;let a;return a=ee().getBool("WEBGL_PACK_CLIP")?new zPe(s.shape):new BPe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[o],[i]])}};class GPe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function aq(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const jPe={kernelName:E_,backendName:"webgl",kernelFunc:function HPe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),o=new GPe(r.shape),i=[aq(r,s.complexTensorInfos.real),aq(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class qPe{constructor(t){this.outputShape=[],this.outputShape=Xi(t,1),this.variableNames=t.map((i,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class KPe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Xi(t,e);const r=this.outputShape,s=r.length,o=dn(s),i=cs("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];const u=a[e],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${Zw(a,u,g)}),\n            vec2(${Zw(c,u,g)}));\n        }`}const f=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Zw(a,u,f)}),\n          vec2(${Zw(c,u,f)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Zw(n,t,e){const r=n.indexOf(t);return n.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function Qw(n){const{inputs:t,backend:e}=n,{input:r}=t;return Bs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const XPe={kernelName:lI,backendName:"webgl",kernelFunc:Qw};function _g(n,t,e){const r=n[0].dtype;if("complex64"===r){const p=n.map(b=>bg({inputs:{input:b},backend:e})),f=n.map(b=>Qw({inputs:{input:b},backend:e})),m=_g(p,t,e),g=_g(f,t,e),y=eu({inputs:{real:m,imag:g},backend:e});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),y}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const p=n.map(v=>{const w=ne(v.shape.slice(t));return Te({inputs:{x:v},backend:e,attrs:{shape:[-1,w]}})}),f=p.map(v=>({vals:e.readSync(v.dataId),shape:v.shape})),m=Xi(p.map(v=>v.shape),1),y=GOe(f,m,r,1===p[0].shape[0]),b=Xi(n.map(v=>v.shape),t),_=e.makeTensorInfo(b,r,y);return p.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}const o=n.filter(p=>ne(p.shape)>0),i=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const p=i?new ra(n[0].shape,Ql):new Jl(n[0].shape,Ql);return e.runWebGLProgram(p,n,r)}const a=ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const p=[];for(let m=0;m<o.length;m+=a){const g=o.slice(m,m+a);p.push(_g(g,t,e))}const f=_g(p,t,e);for(const m of p)e.disposeIntermediateTensorInfo(m);return f}if(i){const p=new KPe(o.map(f=>f.shape),t);return e.runWebGLProgram(p,o,r)}const{tensors2D:l,outShape:u}=function YPe(n,t,e){const r=Xi(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>Te({inputs:{x:o},attrs:{shape:[-1,ne(o.shape.slice(t))]},backend:e})),outShape:r}}(o,t,e),c=new qPe(l.map(p=>p.shape)),d=e.runWebGLProgram(c,l,r);l.forEach(p=>e.disposeIntermediateTensorInfo(p));const h=Te({inputs:{x:d},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(d),h}function lq(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=bt(s,t[0].shape)[0];qk(t.map(u=>u.shape),o);const a=Xi(t.map(u=>u.shape),o);if(0===ne(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(u=>ne(u.shape)>0);return 1===l.length?Bs({inputs:{x:l[0]},backend:e}):_g(l,o,e)}const ZPe={kernelName:I_,backendName:"webgl",kernelFunc:lq};class uq{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),m=t.inChannels%4,g="channelsLast"===t.dataFormat,y=g?1:2,b=g?2:3,_=g?3:1;let v="",w="";r&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const S=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${_}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${f}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${f}) *\n                    getW(wR, wC, ${f}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${f}, xR, xC) *\n                    getW(wR, wC, ${f}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2),\n                getW(wR, wC, ${f} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1),\n                  getX(batch, xR, xC, ${f} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC),\n                  getX(batch, ${f} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${S}\n        ${w}\n        setOutput(result);\n      }\n    `}}class QPe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,o=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),m=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class cq{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=us(this.outputShape.length);const i=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let g=0;g<c;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(d+1)/2;g++){const y=2*g;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<c)){const b=i%2==0?DE(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===b?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<c&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<c&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<c&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";r&&(p=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,f="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${f}\n         setOutput(result);\n       }\n     `}}class JPe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=us(this.outputShape.length);const{dataFormat:r}=e,s=ls(),o="channelsLast"===r,i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${c};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${s.output} = result;\n      }\n    `}}function Jw(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function dq({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.shape,u=r.texData.get(n.dataId),c=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,p="channelsLast"===e.dataFormat;let g;const y=[];if(null!=o){const v=Jw(o.shape,p);null!=v&&(o=Te({inputs:{x:o},backend:r,attrs:{shape:v}}),y.push(o))}if(null!=s){const v=Jw(s.shape,p);null!=v&&(s=Te({inputs:{x:s},backend:r,attrs:{shape:v}}),y.push(s))}if((1!==d&&1!==h||!(c>1e3))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&zt(u.shape.slice(-3),l.slice(-3))){const w={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},S=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,C(zw(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);const T=Te({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(T);const I=Xw({a:w,b:T,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),N=r.texData.get(I.dataId);C(N.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=S,N.shape=e.outShape,g=Bs({inputs:{x:I},backend:r}),g.shape=e.outShape,y.push(I)}else{const v=e.outHeight*e.outWidth,w=Te({inputs:{x:n},backend:r,attrs:{shape:p?[e.batchSize,v,e.inChannels]:[e.batchSize,e.inChannels,v]}}),S=Te({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),T=Xw({a:p?w:S,b:p?S:w,transposeA:!p,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});g=Te({inputs:{x:T},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(S),y.push(T)}for(const v of y)r.disposeIntermediateTensorInfo(v);return g}function hq({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=e,f="channelsLast"===p,m=l*u*c,g=h*d,y=[e.batchSize,m,g],v=[];if(null!=o){const W=Jw(o.shape,f);null!=W&&(o=Te({inputs:{x:o},backend:r,attrs:{shape:W}}),v.push(o))}if(null!=s){const W=Jw(s.shape,f);null!=W&&(s=Te({inputs:{x:s},backend:r,attrs:{shape:W}}),v.push(s))}const w=Te({inputs:{x:t},backend:r,attrs:{shape:[1,m,ne(t.shape)/m]}});v.push(w);const S=new JPe(y,e),I=r.runWebGLProgram(S,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),N=Te({inputs:{x:I},backend:r,attrs:{shape:y}});v.push(I),v.push(N);const R=null!=s,F=null!=o,j="leakyrelu"===a,q=a?gg(a,!0):null,X=new K5(f?N.shape:w.shape,f?w.shape:N.shape,f?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],!0,!1,R,q,F,j),Q=f?[N,w]:[w,N];if(s&&Q.push(s),F&&Q.push(o),j){const W=r.makeTensorInfo([],"float32",Nl(i,"float32"));Q.push(W),v.push(W)}const V=r.runWebGLProgram(X,Q,"float32"),G=Te({inputs:{x:V},backend:r,attrs:{shape:e.outShape}});v.push(V);for(const W of v)r.disposeIntermediateTensorInfo(W);return G}const tLe={kernelName:k_,backendName:"webgl",kernelFunc:function eLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=Aa(l),h=xr(s.shape,o.shape,i,u,a,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&ee().getBool("WEBGL_EXP_CONV")){const m=new cq(h);p=e.runWebGLProgram(m,[s,o],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(ee().getBool("WEBGL_CONV_IM2COL"))p=hq({x:s,filter:o,convInfo:h,backend:e});else{const m=new uq(h);p=e.runWebGLProgram(m,[s,o],"float32")}else p=dq({x:s,filter:o,convInfo:h,backend:e});const f=Te({inputs:{x:p},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(p),f}};class nLe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rLe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,i="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class sLe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class oLe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const aLe={kernelName:jE,backendName:"webgl",kernelFunc:function iLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=Aa(l),h=xr(s.shape,c,i,1,a,u,!1,d),p=new nLe(h);return e.runWebGLProgram(p,[s,o],"float32")}},uLe={kernelName:N_,backendName:"webgl",kernelFunc:function lLe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=Aa(u),h=xr(i,o.shape,a,1,l,c,!1,d),p=new rLe(h);return e.runWebGLProgram(p,[s,o],"float32")}},dLe={kernelName:D_,backendName:"webgl",kernelFunc:function cLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r,u=Ml(s.shape,o.shape,i,l,a),c=new QPe(u);return e.runWebGLProgram(c,[s,o],"float32")}},pLe={kernelName:qE,backendName:"webgl",kernelFunc:function hLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:l}=r,u=Ml(s.shape,l,i,1,a),c=new sLe(u);return e.runWebGLProgram(c,[s,o],"float32")}},mLe={kernelName:KE,backendName:"webgl",kernelFunc:function fLe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:l}=r,u=Ml(l,o.shape,a,1,i),c=new oLe(u);return e.runWebGLProgram(c,[s,o],"float32")}},yLe=Ot({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),bLe={kernelName:Uf,backendName:"webgl",kernelFunc:yLe},_Le=Ot({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),vLe={kernelName:Wf,backendName:"webgl",kernelFunc:_Le};class wLe{constructor(t,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=t,[c]=e,[d,h]=r;this.outputShape=[c,d,h,u];const p="bilinear"===s?1:0,[f,m]=[a-1+".0",l-1+".0"],[g,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[_,v,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${_});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const xLe={kernelName:YE,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=r,c=new wLe(s.shape,o.shape,a,l,u);return e.runWebGLProgram(c,[s,o,i],"float32")}};var Rh=(()=>{return(n=Rh||(Rh={})).Prod="*",n.Sum="+",Rh;var n})();class pq{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===Rh.Prod?"1.0":"0.0":`getX(${fq(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?"end != "+(l-1):"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${dn(o)} coords = getOutputCoords();\n        int end = ${mq(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${c};\n          ${mq(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${fq(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function fq(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function mq(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function gq(n,t,e,r,s,o){const i=t.shape.length,a=Dn([r],i);let l=t;null!=a&&(l=ds({inputs:{x:t},backend:e,attrs:{perm:a}}));const u=jn(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=Bs({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new pq(n,l.shape,!1,o),m=d;d=e.runWebGLProgram(p,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(m)}if(s){const h=new pq(n,l.shape,s,o),p=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(p)}if(null!=a){const p=ds({inputs:{x:d},backend:e,attrs:{perm:Ll(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),p}return d}const TLe={kernelName:XE,backendName:"webgl",kernelFunc:function SLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;return gq(Rh.Prod,s,e,o,i,a)}},ELe={kernelName:A_,backendName:"webgl",kernelFunc:function CLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r;return gq(Rh.Sum,s,e,o,i,a)}},kLe={kernelName:ZE,backendName:"webgl",kernelFunc:function ILe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=F5(l,u,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const l=e.bufferSync(s),u=e.bufferSync(o),c=zOe(l,u,i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class NLe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ALe={kernelName:QE,backendName:"webgl",kernelFunc:function DLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:i}=r,a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,h=("NHWC"===i?s.shape[2]:s.shape[3])*o,p=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),m=new NLe("NHWC"===i?[a,d,h,p]:[a,p,d,h],o,i);return e.runWebGLProgram(m,[s],s.dtype)}};class yq{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=us(this.outputShape.length);const i=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";r&&(u=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,c="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${c}\n        setOutput(result);\n      }\n    `}}class bq{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=us(this.outputShape.length);const i=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,h=d;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)p+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;p+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let y=0;y<d;y++)p+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const b=2*y;if(p+=`\n          xC = xCCorner + ${b*u};\n          `,1===l){if(b<d&&(a%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,p+=1===u&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<d)){const _=a%2==0?DE(u):u;u%2==0&&a%2==1||u%2!=0&&a%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${_};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,p+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):p+=1===_?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${_};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<d&&(a%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<d&&(p+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<d&&(p+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<d&&(p+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",m="";r&&(f=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const $Le={kernelName:R_,backendName:"webgl",kernelFunc:function RLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),C(Rr(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=xr(s.shape,o.shape,i,c,a,u,!0);let h;return h=ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new bq(d):new yq(d),e.runWebGLProgram(h,[s,o],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class OLe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FLe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const PLe={kernelName:JE,backendName:"webgl",kernelFunc:function MLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=xr(s.shape,c,i,a,l,u,!0),h=new OLe(d);return e.runWebGLProgram(h,[s,o],"float32")}},VLe={kernelName:eI,backendName:"webgl",kernelFunc:function LLe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=xr(c,o.shape,i,a,l,u,!0),h=new FLe(d);return e.runWebGLProgram(h,[s,o],"float32")}};class BLe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const ULe={kernelName:"Diag",backendName:"webgl",kernelFunc:function zLe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],o=ne(r.shape),i=Te({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new BLe(o),l=e.runWebGLProgram(a,[i],i.dtype),u=Te({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}};class WLe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const HLe={kernelName:$_,backendName:"webgl",kernelFunc:function GLe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:i,pad:a,dilations:l}=r,u=Fm(s.shape,o.shape,i,a,"NHWC",l);let c;const d=new WLe(u);c=e.runWebGLProgram(d,[s,o],"float32");const h=Te({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},qLe={kernelName:"Einsum",backendName:"webgl",kernelFunc:function jLe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:l}=aN(s,o.length);uN(i.length,l,o);const{path:u,steps:c}=cN(a,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=lN(p,l[g]);let _;dN(y)?_=o[g]:(_=ds({inputs:{x:o[g]},backend:e,attrs:{perm:y}}),f.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);zt(_.shape,v)||(_=Te({inputs:{x:_},backend:e,attrs:{shape:v}}),f.push(_)),null===h?h=_:(h=zD({inputs:{a:_,b:h},backend:e}),f.push(h))}m<d-1&&(u[m]>=0&&(h=Kw({inputs:{x:h},backend:e,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},KLe=Ot({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),XLe={kernelName:Hf,backendName:"webgl",kernelFunc:KLe},QLe={kernelName:rI,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,o=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mg("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Nh("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},JLe=Or({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:HOe}),e3e={kernelName:O_,backendName:"webgl",kernelFunc:JLe},n3e=Ot({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Jk};\n  float a1 = ${eN};\n  float a2 = ${tN};\n  float a3 = ${nN};\n  float a4 = ${rN};\n  float a5 = ${sN};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),r3e={kernelName:jf,backendName:"webgl",kernelFunc:n3e},_q=Ot({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:jOe,dtype:"float32"}),o3e={kernelName:qf,backendName:"webgl",kernelFunc:_q};function HD(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:o}=t,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(C(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Te({inputs:{x:o},backend:r,attrs:{shape:a}})}const i3e={kernelName:F_,backendName:"webgl",kernelFunc:HD},vq="return exp(x) - 1.0;",a3e=Ot({opSnippet:vq,packedOpSnippet:vq,cpuKernelImpl:qOe}),l3e={kernelName:Kf,backendName:"webgl",kernelFunc:a3e};class wq{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function xq(n,t,e){const r=e.texData.get(n.dataId),s=ne(n.shape),o=n.shape[n.shape.length-1],a=Te({inputs:{x:n},backend:e,attrs:{shape:[s/o,o]}}),l=a.shape,u=new wq("real",l,t),c=new wq("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=eu({inputs:{real:h,imag:p},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p);const m=Te({inputs:{x:f},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(f),m}const c3e={kernelName:"FFT",backendName:"webgl",kernelFunc:function u3e(n){const{inputs:t,backend:e}=n,{input:r}=t;return xq(r,!1,e)}};class d3e{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function vg(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||Af(s),"string"===o){const i=Jn(o,ne(r));return i.fill(s),t.makeTensorInfo(r,o,i)}{const i=new d3e(r,s);return t.runWebGLProgram(i,[],o,[[s]])}}const h3e={kernelName:oI,backendName:"webgl",kernelFunc:vg};class p3e{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const f3e={kernelName:iI,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new p3e(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},Sq="return floor(x);",m3e=Ot({opSnippet:Sq,packedOpSnippet:Sq,cpuKernelImpl:KOe}),g3e={kernelName:Xf,backendName:"webgl",kernelFunc:m3e},y3e=Or({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),b3e={kernelName:Yf,backendName:"webgl",kernelFunc:y3e};class _3e{constructor(t){this.variableNames=["A"];const e=ls(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class v3e{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=ls(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const w3e={kernelName:AI,backendName:"webgl",kernelFunc:function x3e(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:o}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,o];if(a||i){const m=ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==$h||m!==jD)&&(jD=m,$h=document.createElement("canvas").getContext("2d",{willReadFrequently:jD})),$h.canvas.width=l,$h.canvas.height=u,$h.drawImage(s,0,0,l,u),s=$h.canvas}const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=Vs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const p=ee().getBool("WEBGL_PACK")?new v3e(d):new _3e(d),f=e.runWebGLProgram(p,[h],"int32");return e.disposeData(h.dataId),f}};let $h,jD=ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const T3e={kernelName:vv,backendName:"webgl",kernelFunc:function S3e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=Aa(c),g=xr(s.shape,o.shape,l,d,u,h,!1,m);let y;const b=[],_=null!=i,v=null!=a,w="leakyrelu"===p,S=()=>{const I=[s,o],N=(R,F)=>{if("NCHW"===F&&1===R.shape.length&&1!==R.shape[0]){const j=Te({inputs:{x:R},backend:e,attrs:{shape:[R.shape[0],1,1]}});return b.push(j),j}return R};if(_&&I.push(N(i,c)),v&&I.push(N(a,c)),w){const R=e.makeTensorInfo([],"float32",Nl(f,"float32"));I.push(R),b.push(R)}return I};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&ee().getBool("WEBGL_EXP_CONV")){const I=p?gg(p,!0):null,N=new cq(g,_,I,v,w),R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=S();y=e.runWebGLProgram(N,F,"float32",R)}else if(ee().getBool("WEBGL_CONV_IM2COL"))y=hq({x:s,filter:o,convInfo:g,backend:e,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const I=p?gg(p,!1):null,N=new uq(g,_,I,v,w),R=S();y=e.runWebGLProgram(N,R,"float32")}else y=dq({x:s,filter:o,convInfo:g,backend:e,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const T=Te({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(I=>e.disposeIntermediateTensorInfo(I)),T}},E3e={kernelName:wv,backendName:"webgl",kernelFunc:function C3e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),C(Rr(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=xr(s.shape,o.shape,l,m,u,d,!0),y=ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?gg(h,y):null,_=[s,o],v=null!=i,w=null!=a,S="leakyrelu"===h;if(v&&_.push(i),w&&_.push(a),S){const R=e.makeTensorInfo([],"float32",Nl(p,"float32"));_.push(R),f.push(R)}let T;T=y?new bq(g,v,b,w,S):new yq(g,v,b,w,S);const N=e.runWebGLProgram(T,_,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return f.forEach(R=>e.disposeIntermediateTensorInfo(R)),N}};class I3e{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=dn(r.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const N3e={kernelName:SW,backendName:"webgl",kernelFunc:function k3e(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=s.shape,i=o[o.length-1],a=ne(r.shape),[l,u,c,d]=Qk(r,s),h=Te({inputs:{x:s},backend:e,attrs:{shape:[u,i]}}),p=Te({inputs:{x:r},backend:e,attrs:{shape:[ne(r.shape)/c,c]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=e.readSync(s.dataId),b=e.bufferSync(r),_=XOe(y,b,r.dtype,u,i,c,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,_.values)}const f=new I3e(i,d,[u,c],r.shape),m=e.runWebGLProgram(f,[p,h],p.dtype),g=Te({inputs:{x:m},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};class D3e{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=dn(this.rank),s=function A3e(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function Tq(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:i,batchDims:a}=r,l=bt(i,s.shape)[0];if(ee().get("DEBUG")){const b=e.readSync(o.dataId),_=s.shape[l];for(let v=0;v<b.length;++v){const w=b[v];C(w<=_-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${_-1}]`)}}const u=fN(s,o,l,a),c=ne(o.shape),d=[],h=Te({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Te({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const b=e.bufferSync(p),_=e.bufferSync(h),v=YOe(_,b,f);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(u.outputShape,v.dtype,v.values)}const m=new D3e(h.shape,f),g=e.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=Te({inputs:{x:g},backend:e,attrs:{shape:u.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const R3e={kernelName:P_,backendName:"webgl",kernelFunc:Tq},$3e=Or({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:ZOe,dtype:"bool"}),O3e={kernelName:L_,backendName:"webgl",kernelFunc:$3e},F3e=Or({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:QOe}),M3e={kernelName:Zf,backendName:"webgl",kernelFunc:F3e},L3e={kernelName:aI,backendName:"webgl",kernelFunc:function P3e(n){const{inputs:t,backend:e}=n,{input:r}=t;return xq(r,!0,e)}},V3e=Ot({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),B3e={kernelName:Jf,backendName:"webgl",kernelFunc:V3e},z3e=Ot({opSnippet:"return float(isinf(x));",dtype:"bool"}),U3e={kernelName:em,backendName:"webgl",kernelFunc:z3e},W3e=Ot({opSnippet:"return float(isnan(x));",dtype:"bool"}),G3e={kernelName:tm,backendName:"webgl",kernelFunc:W3e},H3e=Or({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:JOe,dtype:"bool"}),j3e={kernelName:B_,backendName:"webgl",kernelFunc:H3e},q3e=Or({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:eFe,dtype:"bool"}),K3e={kernelName:z_,backendName:"webgl",kernelFunc:q3e},Y3e={kernelName:TW,backendName:"webgl",kernelFunc:function X3e(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,i=tFe(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},Q3e=Ot({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:nFe}),J3e={kernelName:nm,backendName:"webgl",kernelFunc:Q3e},tVe=Ot({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),nVe={kernelName:rm,backendName:"webgl",kernelFunc:tVe},rVe=Or({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),sVe={kernelName:U_,backendName:"webgl",kernelFunc:rVe},oVe=Ot({opSnippet:"return float(!(x >= 1.0));"}),iVe={kernelName:W_,backendName:"webgl",kernelFunc:oVe},aVe=Or({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),lVe={kernelName:G_,backendName:"webgl",kernelFunc:aVe};class uVe{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=t[3]-1;let l;this.outputShape=t;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class cVe{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=t[3]-1;let l;this.outputShape=t;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const dVe={kernelName:H_,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:l}=r,u=ee().getBool("WEBGL_PACK_NORMALIZATION")?new cVe(s.shape,o,i,a,l):new uVe(s.shape,o,i,a,l);return e.runWebGLProgram(u,[s],s.dtype)}};class hVe{constructor(t,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const pVe={kernelName:uI,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new hVe(s.shape,a,l,u,c);return e.runWebGLProgram(d,[s,o,i],s.dtype)}};function Cq(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Dn(u,a),d=null!=c,h=e.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const _=e.texData.get(p.dataId).values,v=new Array(a);for(let T=0;T<v.length;T++)v[T]=s.shape[c[T]];const w=VD(_,s.shape,s.dtype,c,v);p=e.makeTensorInfo(v,s.dtype),e.texData.get(p.dataId).values=w}else p=qw(s,c,e);u=jn(u.length,a)}$r("max",u,a);const[f,m]=Sr(p.shape,u);let y,g=f;if(i&&(g=Hn(f,l)),h){const _=e.texData.get(p.dataId).values,v=rFe(_,ne(m),g,s.dtype);y=e.makeTensorInfo(g,s.dtype),e.texData.get(y.dataId).values=v}else y=function fVe(n,t,e,r){const s=ne(t),a=Te({inputs:{x:n},attrs:{shape:[ne(n.shape)/s,s]},backend:r}),l=_c(a,n.dtype,"max",r),u=Te({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(p,m,g,e);return d&&e.disposeIntermediateTensorInfo(p),y}const mVe={kernelName:j_,backendName:"webgl",kernelFunc:Cq},bVe=Or({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:sFe}),_Ve={kernelName:sm,backendName:"webgl",kernelFunc:bVe},wVe={kernelName:q_,backendName:"webgl",kernelFunc:function vVe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;hg(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;C(Rr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Fo(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&zt(c.inShape,c.outShape))return Bs({inputs:{x:s},backend:e});const d=new yg(c,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},SVe={kernelName:K_,backendName:"webgl",kernelFunc:function xVe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,d=Da(s.shape,o,i,[1,1,1],a,u,l),h=new UD(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class TVe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const o=t.effectiveFilterHeight,i=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class CVe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${u-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const IVe={kernelName:dI,backendName:"webgl",kernelFunc:function EVe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=Da(i.shape,a,l,[1,1,1],u,c),p=new UD(h,"max",!0),f=e.runWebGLProgram(p,[i],i.dtype),m=new CVe(h),g=e.runWebGLProgram(m,[s,f],i.dtype);return e.disposeIntermediateTensorInfo(f),g}},NVe={kernelName:cI,backendName:"webgl",kernelFunc:function kVe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:i}=t,a=o;hg([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Fo(a.shape,l,u,1,c,d),f=new yg(h,"max",!0),m=e.runWebGLProgram(f,[a],a.dtype),g=new TVe(h),y=e.runWebGLProgram(g,[s,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}},AVe={kernelName:CW,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,l=e;C(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];C(Rr(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Fo(r.shape,s,o,u,i),[d,h]=function DVe(n,t,e,r){let s=new yg(e,"max",!1);const o=r.runWebGLProgram(s,[n],"float32");return s=new yg(e,"max",!0,!0,t),[o,r.runWebGLProgram(s,[n],"float32")]}(r,a,c,l);return[d,h]}},$Ve={kernelName:X_,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:o}=t,i=e,a=r.shape.length,l=bt(o,r.shape);let u=l;const c=Dn(u,a),d=null!=c,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const v=i.texData.get(f.dataId).values,w=new Array(a);for(let I=0;I<w.length;I++)w[I]=r.shape[c[I]];const S=VD(v,r.shape,r.dtype,c,w);f=i.makeTensorInfo(w,r.dtype),i.texData.get(f.dataId).values=S}else f=qw(r,c,i);p.push(f),u=jn(u.length,a)}$r("sum",u,a);const[m,g]=Sr(f.shape,u);let y=m;s&&(y=Hn(m,l));const b=function RVe(n,t,e,r){const s=ne(t),a=Te({inputs:{x:n},attrs:{shape:[ne(n.shape)/s,s]},backend:r}),l=_c(a,"float32","mean",r),u=Te({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(f,g,y,i);for(const _ of p)i.disposeIntermediateTensorInfo(_);return b}},FVe={kernelName:Y_,backendName:"webgl",kernelFunc:function OVe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Dn(u,a);let d=s;null!=c&&(d=ds({inputs:{x:s},backend:e,attrs:{perm:c}}),u=jn(u.length,s.shape.length)),$r("min",u,a);const[h,p]=Sr(d.shape,u),m=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,ne(p)]}}),g=_c(m,m.dtype,"min",e);let y;return y=Te(i?{inputs:{x:g},backend:e,attrs:{shape:Hn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}},LVe=Or({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:oFe}),VVe={kernelName:om,backendName:"webgl",kernelFunc:LVe};class BVe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+t[d]+c[1]);const s=t.length,o=dn(s),i=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class zVe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,m)=>f[0]+t[m]+f[1]);const s=t.length,o=dn(s),i=e.map(f=>f[0]).join(","),a=e.map((f,m)=>f[0]+t[m]).join(","),l=cs("rc",s),u=cs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===r?0:1;let p="";if(1===s){const f=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;p=`\n        ${o} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const f=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;p=`\n        ${o} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${f}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${c}) {\n            ${f}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const UVe={kernelName:Z_,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:o}=e,i=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zVe(r.shape,s,o):new BVe(r.shape,s,o);return t.runWebGLProgram(i,[r],r.dtype)}},HVe=Or({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),jVe={kernelName:im,backendName:"webgl",kernelFunc:HVe};class qVe{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const Eq=Or({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),KVe={kernelName:Gf,backendName:"webgl",kernelFunc:Eq},Iq="return a - b;",kq=Or({opSnippet:Iq,packedOpSnippet:Iq,supportsComplex:!0,cpuKernelImpl:CFe}),XVe={kernelName:xm,backendName:"webgl",kernelFunc:kq};function Nq(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,i=bt([o],s.shape),a=Cq({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=Hn(a.shape,i),u=Te({inputs:{x:a},backend:e,attrs:{shape:l}}),c=kq({inputs:{a:s,b:u},backend:e}),d=_q({inputs:{x:c},backend:e}),h=Kw({inputs:{x:d},backend:e,attrs:{axis:i,keepDims:!1}}),p=Te({inputs:{x:h},backend:e,attrs:{shape:l}}),f=Eq({inputs:{a:d,b:p},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}const YVe={kernelName:mv,backendName:"webgl",kernelFunc:Nq},QVe={kernelName:EW,backendName:"webgl",kernelFunc:function ZVe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r,l=a?s:Nq({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new qVe(l.shape[0],l.shape[1],o),p=e.runWebGLProgram(d,[l],"int32",[[i]]);return a||e.disposeIntermediateTensorInfo(l),p}},nBe={kernelName:Q_,backendName:"webgl",kernelFunc:function tBe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=aFe(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Jl(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new ra(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(s,[r],r.dtype)}},rBe=Bk,oBe={kernelName:hI,backendName:"webgl",kernelFunc:function sBe(n){to("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),{selectedIndices:d}=rBe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},iBe=zk,lBe={kernelName:pI,backendName:"webgl",kernelFunc:function aBe(n){to("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=iBe(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},uBe=Uk,dBe={kernelName:fI,backendName:"webgl",kernelFunc:function cBe(n){to("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),h=i,p=a,f=l,m=u,{selectedIndices:g,selectedScores:y}=uBe(c,d,h,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class hBe{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const pBe={kernelName:tv,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:i,onValue:a,offValue:l}=r,u=ne(s.shape),c=new hBe(u,i,a,l),d=Te({inputs:{x:s},backend:e,attrs:{shape:[u]}}),h=e.runWebGLProgram(c,[d],o);e.disposeIntermediateTensorInfo(d);const f=Te({inputs:{x:h},backend:e,attrs:{shape:[...s.shape,i]}});return e.disposeIntermediateTensorInfo(h),f}};function e0(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=bg({inputs:{input:r},backend:e}),o=e0({inputs:{x:s},backend:e}),i=Qw({inputs:{input:r},backend:e}),a=e0({inputs:{x:i},backend:e}),l=eu({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return vg({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const fBe={kernelName:bv,backendName:"webgl",kernelFunc:e0},mBe={kernelName:ev,backendName:"webgl",kernelFunc:function Dq(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=bg({inputs:{input:r},backend:e}),o=Dq({inputs:{x:s},backend:e}),i=Qw({inputs:{input:r},backend:e}),a=e0({inputs:{x:i},backend:e}),l=eu({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return vg({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},yBe={kernelName:nv,backendName:"webgl",kernelFunc:function gBe(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return HD({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(c=>{Ro(o,c.shape,"All tensors passed to stack must have matching shapes"),C(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=lq({inputs:t.map(c=>{const d=HD({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class bBe{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);const s=t.length,o=dn(s),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class _Be{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,o=dn(s),i=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),l=cs("rc",s),u=cs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${c}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${c}) {`],p=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=1===s?2:4;m<g;m++)f+=`\n        ${h[m]}\n        if (${p}) {\n          result[${m}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${m}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;f+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const Aq=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:i}=r;if(0===ne(s.shape))return vg({backend:e,attrs:{shape:o.map((c,d)=>c[0]+s.shape[d]+c[1]),value:i,dtype:s.dtype}});const a=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _Be(s.shape,o,i):new bBe(s.shape,o,i);return e.runWebGLProgram(a,[s],s.dtype,[[i]])},vBe={kernelName:rv,backendName:"webgl",kernelFunc:Aq},SBe=Or({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),TBe={kernelName:lm,backendName:"webgl",kernelFunc:SBe},EBe={kernelName:ov,backendName:"webgl",kernelFunc:function CBe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],u=bt(o,s.shape);let c=u;const d=Dn(c,a);let p,h=s;if(null!=d&&(h=ds({inputs:{x:s},backend:e,attrs:{perm:d}}),c=jn(c.length,a),l.push(h)),$r("prod",c,a),e.shouldExecuteOnCPU([h])){const f=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=uFe(h.shape,h.dtype,f,c);p=e.makeTensorInfo(g,y,m)}else{const[f,m]=Sr(h.shape,c),g=ne(m),y=Te({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),_=_c(y,VI(s.dtype),"prod",e);p=Te({inputs:{x:_},backend:e,attrs:{shape:f}}),l.push(y),l.push(_)}if(i){l.push(p);const f=Hn(p.shape,u);p=Te({inputs:{x:p},backend:e,attrs:{shape:f}})}return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},kBe={kernelName:IW,backendName:"webgl",kernelFunc:function IBe(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=t,{outputRaggedRank:a}=r,l=s.map(y=>e.readSync(y.dataId)),u=s.map(y=>y.shape),c=e.readSync(o.dataId),d=e.readSync(i.dataId),[h,p,f]=cFe(l,u,c,o.shape,o.dtype,d,i.shape,a),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(f,o.dtype,p);return m.concat([g])}},DBe={kernelName:kW,backendName:"webgl",kernelFunc:function NBe(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=dFe(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}},RBe={kernelName:NW,backendName:"webgl",kernelFunc:function ABe(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),d=e.readSync(i.dataId),h=a.map(g=>e.readSync(g.dataId)),p=a.map(g=>g.shape),[f,m]=hFe(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,p,l);return e.makeTensorInfo(f,o.dtype,m)}},Rq=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:o,dtype:i}=e,a=pFe(r,s,o,i);return t.makeTensorInfo([a.length],i,a)},$Be={kernelName:mI,backendName:"webgl",kernelFunc:Rq},OBe=Ot({opSnippet:"return 1.0 / x;"}),FBe={kernelName:um,backendName:"webgl",kernelFunc:OBe},PBe=Ot({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),LBe={kernelName:cm,backendName:"webgl",kernelFunc:PBe},BBe=Ot({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),zBe={kernelName:dm,backendName:"webgl",kernelFunc:BBe};class UBe{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class WBe{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const HBe={kernelName:lv,backendName:"webgl",kernelFunc:function GBe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new WBe(s.shape,l,u,o,i):new UBe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],"float32")}};class jBe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=t,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,m=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const KBe={kernelName:bI,backendName:"webgl",kernelFunc:function qBe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r,a=new jBe(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class XBe{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class YBe{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=t;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const QBe={kernelName:av,backendName:"webgl",kernelFunc:function ZBe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new YBe(s.shape,l,u,o,i):new XBe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],s.dtype)}};class JBe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=t,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,m=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const tze={kernelName:yI,backendName:"webgl",kernelFunc:function eze(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:i}=r,a=new JBe(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class nze{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const o=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=dn(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class rze{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=cs("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=dn(r);function h(f){const m=t.map((b,_)=>function p(f,m){return-1!==e.indexOf(f)&&1!==t[f]?`${t[f]} - ${m[f]} - 1`:`${m[f]}`}(_,f));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(f){return h(f)}(s.slice())};\n          if(${o}){\n            result.g = ${function u(f){return f[r-1]="("+f[r-1]+" + 1)",h(f)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function c(f){return f[r-2]="("+f[r-2]+" + 1)",h(f)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",h(f)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const oze={kernelName:uv,backendName:"webgl",kernelFunc:function sze(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r,i=s.shape.length,a=bt(o,s.shape);if(0===i)return Bs({inputs:{x:s},backend:e});const l=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rze(s.shape,a):new nze(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class ize{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const aze={kernelName:RI,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=t,a=e,l=new ize(r.shape,o),[u,c]=Xk(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},lze=Ot({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),uze={kernelName:hm,backendName:"webgl",kernelFunc:lze},cze=Ot({opSnippet:"return inversesqrt(x);",cpuKernelImpl:fFe}),dze={kernelName:pm,backendName:"webgl",kernelFunc:cze};class $q{constructor(t,e,r,s,o,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const l=dn(o.length),u=dn(i.length);let c="";1===r?c="i":2===r&&(c="i, j");let h="";1===s?h="i":2===s&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${c}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const pze={kernelName:DW,backendName:"webgl",kernelFunc:function hze(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=qm(0,s,i),h=[d/u,u];if(0===d)return e.makeTensorInfo(i,s.dtype);const p=Te({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),f=Te({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new $q(l,a,p.shape.length,f.shape.length,c,h),y=e.runWebGLProgram(g,[f,p,m],f.dtype),b=Te({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}};class fze{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===ee().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const gze={kernelName:AW,backendName:"webgl",kernelFunc:function mze(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:i}=r,a=new fze(s.shape[0],s.shape[1],o.shape[1],i);return e.runWebGLProgram(a,[s,o],"int32",[[s.shape[1]]])}};class yze{constructor(t,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<t&&l.push(`${a[c]}`);s=l.join(),o=u.join()}const i=dn(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const _ze={kernelName:cv,backendName:"webgl",kernelFunc:function bze(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t,i=new yze(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],Fs(s.dtype,o.dtype))}},wze=Ot({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Qv};\n  float scale = ${Jv};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),xze={kernelName:fm,backendName:"webgl",kernelFunc:wze},Tze=Ot({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:gFe}),Cze={kernelName:bm,backendName:"webgl",kernelFunc:Tze},Eze=Ot({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Ize={kernelName:ym,backendName:"webgl",kernelFunc:Eze},Nze=Ot({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),Dze={kernelName:mm,backendName:"webgl",kernelFunc:Nze},Aze=Ot({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Rze={kernelName:gm,backendName:"webgl",kernelFunc:Aze},$ze=Ot({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Oze={kernelName:_m,backendName:"webgl",kernelFunc:$ze},Fze={kernelName:pv,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:i}=r;C(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=Aq({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Gm(c.shape,o,a,!1),h=Hm(d.length,o.length,!1),p=jm(c.shape,o,a,!1),f=Te({inputs:{x:c},backend:e,attrs:{shape:d}}),m=ds({inputs:{x:f},backend:e,attrs:{perm:h}}),g=Te({inputs:{x:m},backend:e,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}},Pze={kernelName:_I,backendName:"webgl",kernelFunc:function Mze(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=e.readSync(i.dataId)[0],[d,h,p,f,m]=bFe(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},Vze={kernelName:vI,backendName:"webgl",kernelFunc:function Lze(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(o.dataId)),[u,c,d]=_Fe(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},zze={kernelName:wI,backendName:"webgl",kernelFunc:function Bze(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=P5(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},Wze={kernelName:xI,backendName:"webgl",kernelFunc:function Uze(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=P5(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},Hze={kernelName:RW,backendName:"webgl",kernelFunc:function Gze(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=qm(0,s,a);if("string"===o.dtype){const y=e.bufferSync(s),b=e.bufferSync(o),_=Al(e.readSync(i.dataId)[0]),v=mFe(y,b,a,h,c,u,l,d,_,!1);return e.makeTensorInfo(a,v.dtype,v.values)}const f=new $q(u,l,s.shape.length,o.shape.length,d,[h,1],!1),m=e.runWebGLProgram(f,[o,s,i],o.dtype),g=Te({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(m),g}},qze={kernelName:fv,backendName:"webgl",kernelFunc:function jze(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=bt(i,s.shape)[0],l=hN(s,o,a),c=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const p=[...d];p[a]=h;const f=Ah({inputs:{x:s},backend:e,attrs:{begin:c,size:p}});return c[a]+=h,f})}},Oq="return sqrt(x);",Kze=Ot({opSnippet:Oq,packedOpSnippet:Oq,cpuKernelImpl:vFe}),Xze={kernelName:vm,backendName:"webgl",kernelFunc:Kze},Zze={kernelName:SI,backendName:"webgl",kernelFunc:Ot({opSnippet:"return x * x;"})},Fq="return (a - b) * (a - b);",Qze=Or({opSnippet:Fq,packedOpSnippet:Fq}),Jze={kernelName:wm,backendName:"webgl",kernelFunc:Qze},t4e={kernelName:Em,backendName:"webgl",kernelFunc:function e4e({inputs:n,attrs:t,backend:e}){const{x:r}=n,o=new ra(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class n4e{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=dn(r.length),i=dn(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,1===r.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const s4e={kernelName:TI,backendName:"webgl",kernelFunc:function r4e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=gk(s.shape,o,i,a,l,u,c,d,h);let w;if(m)w=Te({inputs:{x:s},backend:e,attrs:{shape:f}});else if(g||y){C(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const T=pk(b,_,v),I=Ah({inputs:{x:s},backend:e,attrs:{begin:b,size:T}});w=Te({inputs:{x:I},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(I)}else if(e.shouldExecuteOnCPU([s])){const I=e.readSync(s.dataId),N=_t(s.shape,s.dtype,I),R=wFe(p,N,v,b);w=e.makeTensorInfo(f,s.dtype,R.values)}else{const I=new n4e(b,v,p);w=e.runWebGLProgram(I,[s],s.dtype)}const S=Te({inputs:{x:w},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(w),S}},i4e={kernelName:CI,backendName:"webgl",kernelFunc:function o4e(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=e.readSync(c.dataId),p=e.readSync(d.dataId),[f,m]=xFe(h,p,s,o,i,a,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",m)]}},l4e={kernelName:EI,backendName:"webgl",kernelFunc:function a4e(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.readSync(o.dataId),l=e.readSync(i.dataId)[0],[u,c,d]=SFe(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},c4e={kernelName:II,backendName:"webgl",kernelFunc:function u4e(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=e.readSync(o.dataId),a=TFe(i,s);return e.makeTensorInfo(o.shape,"int32",a)}},d4e=Ot({opSnippet:"return tan(x);"}),h4e={kernelName:Sm,backendName:"webgl",kernelFunc:d4e},p4e=Ot({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),f4e={kernelName:Tm,backendName:"webgl",kernelFunc:p4e};class m4e{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*e[i];this.outputShape=r,this.rank=r.length;const s=dn(this.rank),o=function g4e(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function Mq(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),u="string"===s.dtype?l.map(h=>Al(h)):l,c=_t(s.shape,s.dtype,u),d=EFe(c,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new m4e(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const y4e={kernelName:Cm,backendName:"webgl",kernelFunc:Mq};class b4e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class _4e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function vc(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function Pq(n){let t=1;for(;t<n;)t*=2;return t}const w4e={kernelName:kI,backendName:"webgl",kernelFunc:function v4e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:i}=r,a=ee().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ee().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([s])||c<a||o>l){const R=e.readSync(s.dataId),[F,j]=IFe(R,u,s.dtype,o,i);return[e.makeTensorInfo(F.shape,F.dtype,F.values),e.makeTensorInfo(j.shape,j.dtype,j.values)]}if(0===o)return u[u.length-1]=0,[e.makeTensorInfo(u,s.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(1===c)return[s,vg({attrs:{shape:u,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,p=h?e.unpackTensor(s):s,m=ne(u)/c,g=Te({inputs:{x:p},attrs:{shape:[m,c]},backend:e});h&&vc(e,p);const y=Pq(o),b=Pq(c);let _=null;const v=()=>null===_?[g,g]:[g,_],w=(R,F,j)=>{const q=v(),X=new b4e(j),G=_;_=e.runWebGLProgram(X,q,"int32",[[c],[null===_?1:0],[Number.NEGATIVE_INFINITY],[R],[F]]),vc(e,G)};for(let R=1;R<y;R*=2){const F=2*R;for(let j=R;j>=1;j/=2)w(F,j,[m,b])}for(let R=b;R>y;R/=2){const F=v(),j=new _4e([m,R/2]),Q=_;_=e.runWebGLProgram(j,F,"int32",[[c],[null===_?1:0],[y]]),vc(e,Q);const V=y/2,G=2*V;for(let W=V;W>=1;W/=2)w(G,W,_.shape)}let S=_;_=Ah({inputs:{x:_},backend:e,attrs:{begin:0,size:[m,o]}}),vc(e,S);let T=Tq({inputs:{x:g,indices:_},backend:e,attrs:{axis:1,batchDims:1}});vc(e,g);const I=u.slice(0,-1);I.push(o),S=_,_=Te({inputs:{x:_},attrs:{shape:I},backend:e}),vc(e,S);const N=T;return T=Te({inputs:{x:T},attrs:{shape:I},backend:e}),vc(e,N),[T,_]}};class x4e{constructor(t,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const T4e={kernelName:NI,backendName:"webgl",kernelFunc:function S4e(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],y=new x4e(d,h,i,a,l,[c,f,m,p]);return e.runWebGLProgram(y,[s,o],"float32")}},E4e={kernelName:DI,backendName:"webgl",kernelFunc:function C4e(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;hg(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=kFe(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},k4e={kernelName:gv,backendName:"webgl",kernelFunc:function I4e(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],u=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==o&&(u[c++]=i.shape[m]);const d=[],h=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[o]=m;const g=Ah({inputs:{x:i},backend:e,attrs:{begin:h,size:p}}),y=Te({inputs:{x:g},backend:e,attrs:{shape:u}});f[m]=y,d.push(g)}return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}};class N4e{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,o=t.inSize,i=t.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${f}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const R4e=[xMe,TMe,IMe,DMe,RMe,FMe,PMe,VMe,WMe,HMe,KMe,ZMe,ePe,sPe,aPe,uPe,dPe,mPe,yPe,_Pe,xPe,kPe,DPe,RPe,PPe,VPe,WPe,oMe,jPe,ZPe,tLe,aLe,uLe,dLe,pLe,mLe,bLe,vLe,xLe,TLe,ELe,kLe,ALe,$Le,PLe,VLe,ULe,HLe,qLe,XLe,QLe,e3e,r3e,o3e,i3e,l3e,c3e,h3e,f3e,g3e,b3e,w3e,T3e,E3e,N3e,R3e,O3e,M3e,sMe,L3e,XPe,B3e,U3e,G3e,aMe,j3e,K3e,Y3e,J3e,nVe,sVe,iVe,lVe,dVe,pVe,mVe,_Ve,wVe,SVe,IVe,NVe,AVe,$Ve,FVe,VVe,UVe,jVe,QVe,cMe,nBe,oBe,lBe,dBe,$Pe,pBe,mBe,yBe,vBe,TBe,uMe,EBe,kBe,DBe,RBe,$Be,OPe,KVe,FBe,LBe,zBe,hMe,HBe,KBe,QBe,tze,oze,aze,uze,dze,pze,gze,_ze,xze,Cze,Ize,Dze,Rze,IPe,YVe,Oze,Fze,Pze,Vze,zze,Wze,Hze,qze,Xze,Zze,Jze,t4e,s4e,i4e,l4e,c4e,XVe,_Me,h4e,f4e,y4e,w4e,T4e,vMe,E4e,k4e,{kernelName:yv,backendName:"webgl",kernelFunc:function D4e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:i}=r,a=s.shape.length,l=[];let u=0;const c=Dn([u],a);let d=s;null!=c&&(d=ds({inputs:{x:s},backend:e,attrs:{perm:c}}),l.push(d),u=jn(1,a)[0]);const h=$H(d.shape,u,i),p=ne([d.shape[u]]),f=Te({inputs:{x:d},backend:e,attrs:{shape:[-1,p]}});l.push(f);const m=VI(s.dtype),g=(v,w,S,T,I)=>{const N=v.shape[0],R=v.shape[1],F=RH(R,I),q=new N4e({windowSize:F,inSize:R,batchSize:N,numSegments:I},w),X=e.compileAndRun(q,[v,S],T);if(l.push(X),X.shape[1]===I)return X;const Q=Rq({backend:e,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),V=Mq({inputs:{x:Q},backend:e,attrs:{reps:[R/F]}});return l.push(Q),l.push(V),g(X,w,V,T,I)},b=Te({inputs:{x:g(f,"unsortedSegmentSum",o,m,i)},backend:e,attrs:{shape:h}});let _=b;if(null!=c){l.push(b);const v=Ll(c);_=ds({inputs:{x:_},backend:e,attrs:{perm:v}})}return l.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}},fBe];for(const n of R4e)FI(n);let qD,Lq=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({}),n})();try{qD="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(n){qD=!1}let wg,XD,Oh=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function _re(n){return n===sP}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!qD)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Ce(pT))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function KD(n){return function M4e(){if(null==wg&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>wg=!0}))}finally{wg=wg||!1}return wg}()?n:!!n.capture}function zq(n){if(function P4e(){if(null==XD){const n="undefined"!=typeof document?document.head:null;XD=!(!n||!n.createShadowRoot&&!n.attachShadow)}return XD}()){const t=n.getRootNode?n.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}function xg(n){return n.composedPath?n.composedPath()[0]:n.target}function j4e(n,t){return n===t}function Uq(n){return null!=n&&"false"!=`${n}`}function YD(n,t=0){return function K4e(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function Sg(n){return n instanceof So?n.nativeElement:n}function jq(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function qq(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const nUe=new Qe("cdk-input-modality-detector-options"),rUe={ignoreKeys:[18,17,224,91,16]},Mh=KD({passive:!0,capture:!0});let sUe=(()=>{class n{constructor(e,r,s,o){this._platform=e,this._mostRecentTarget=null,this._modality=new Eo(null),this._lastTouchMs=0,this._onKeydown=i=>{var a,l;(null===(l=null===(a=this._options)||void 0===a?void 0:a.ignoreKeys)||void 0===l?void 0:l.some(u=>u===i.keyCode))||(this._modality.next("keyboard"),this._mostRecentTarget=xg(i))},this._onMousedown=i=>{Date.now()-this._lastTouchMs<650||(this._modality.next(jq(i)?"keyboard":"mouse"),this._mostRecentTarget=xg(i))},this._onTouchstart=i=>{qq(i)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=xg(i))},this._options=Object.assign(Object.assign({},rUe),o),this.modalityDetected=this._modality.pipe(function G4e(n){return Eu((t,e)=>n<=e)}(1)),this.modalityChanged=this.modalityDetected.pipe(function H4e(n,t=ja){return n=null!=n?n:j4e,or((e,r)=>{let s,o=!0;e.subscribe(Xn(r,i=>{const a=t(i);(o||!n(s,a))&&(o=!1,s=a,r.next(i))}))})}()),e.isBrowser&&r.runOutsideAngular(()=>{s.addEventListener("keydown",this._onKeydown,Mh),s.addEventListener("mousedown",this._onMousedown,Mh),s.addEventListener("touchstart",this._onTouchstart,Mh)})}get mostRecentModality(){return this._modality.value}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,Mh),document.removeEventListener("mousedown",this._onMousedown,Mh),document.removeEventListener("touchstart",this._onTouchstart,Mh))}}return n.\u0275fac=function(e){return new(e||n)(Ce(Oh),Ce(Cn),Ce(Yn),Ce(nUe,8))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const iUe=new Qe("cdk-focus-monitor-default-options"),n0=KD({passive:!0,capture:!0});let aUe=(()=>{class n{constructor(e,r,s,o,i){this._ngZone=e,this._platform=r,this._inputModalityDetector=s,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new go,this._rootNodeFocusAndBlurListener=a=>{const l=xg(a),u="focus"===a.type?this._onFocus:this._onBlur;for(let c=l;c;c=c.parentElement)u.call(this,a,c)},this._document=o,this._detectionMode=(null==i?void 0:i.detectionMode)||0}monitor(e,r=!1){const s=Sg(e);if(!this._platform.isBrowser||1!==s.nodeType)return dt(null);const o=zq(s)||this._getDocument(),i=this._elementInfo.get(s);if(i)return r&&(i.checkChildren=!0),i.subject;const a={checkChildren:r,subject:new go,rootNode:o};return this._elementInfo.set(s,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=Sg(e),s=this._elementInfo.get(r);s&&(s.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(s))}focusVia(e,r,s){const o=Sg(e);o===this._getDocument().activeElement?this._getClosestElementsInfo(o).forEach(([a,l])=>this._originChanged(a,r,l)):(this._setOrigin(r),"function"==typeof o.focus&&o.focus(s))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!(null==e?void 0:e.contains(this._inputModalityDetector._mostRecentTarget))}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const s=this._elementInfo.get(r),o=xg(e);!s||!s.checkChildren&&r!==o||this._originChanged(r,this._getFocusOrigin(o),s)}_onBlur(e,r){const s=this._elementInfo.get(r);!s||s.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(s.subject,null))}_emitOrigin(e,r){this._ngZone.run(()=>e.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,s=this._rootNodeFocusListenerCount.get(r)||0;s||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,n0),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,n0)}),this._rootNodeFocusListenerCount.set(r,s+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(function q4e(n){return or((t,e)=>{yo(n).subscribe(Xn(e,()=>e.complete(),A0)),!e.closed&&t.subscribe(e)})}(this._stopInputModalityDetector)).subscribe(o=>{this._setOrigin(o,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const s=this._rootNodeFocusListenerCount.get(r);s>1?this._rootNodeFocusListenerCount.set(r,s-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,n0),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,n0),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,s){this._setClasses(e,r),this._emitOrigin(s.subject,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((s,o)=>{(o===e||s.checkChildren&&o.contains(e))&&r.push([o,s])}),r}}return n.\u0275fac=function(e){return new(e||n)(Ce(Cn),Ce(Oh),Ce(sUe),Ce(Yn,8),Ce(iUe,8))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Xq="cdk-high-contrast-black-on-white",Yq="cdk-high-contrast-white-on-black",ZD="cdk-high-contrast-active";let lUe=(()=>{class n{constructor(e,r){this._platform=e,this._document=r}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,o=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),o){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(ZD),e.remove(Xq),e.remove(Yq),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?(e.add(ZD),e.add(Xq)):2===r&&(e.add(ZD),e.add(Yq))}}}return n.\u0275fac=function(e){return new(e||n)(Ce(Oh),Ce(Yn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class Zq{}const za="*";function Qq(n,t=null){return{type:2,steps:n,options:t}}function Jq(n){return{type:6,styles:n,offset:null}}function eK(n){Promise.resolve(null).then(n)}class Tg{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){eK(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class tK{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const o=this.players.length;0==o?eK(()=>this._onFinish()):this.players.forEach(i=>{i.onDone(()=>{++e==o&&this._onFinish()}),i.onDestroy(()=>{++r==o&&this._onDestroy()}),i.onStart(()=>{++s==o&&this._onStart()})}),this.totalTime=this.players.reduce((i,a)=>Math.max(i,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}const Rt=!1;function nK(n){return new Oe(3e3,Rt)}function WUe(){return"undefined"!=typeof window&&void 0!==window.document}function JD(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function tu(n){switch(n.length){case 0:return new Tg;case 1:return n[0];default:return new tK(n)}}function rK(n,t,e,r,s={},o={}){const i=[],a=[];let l=-1,u=null;if(r.forEach(c=>{const d=c.offset,h=d==l,p=h&&u||{};Object.keys(c).forEach(f=>{let m=f,g=c[f];if("offset"!==f)switch(m=t.normalizePropertyName(m,i),g){case"!":g=s[f];break;case za:g=o[f];break;default:g=t.normalizeStyleValue(f,m,g,i)}p[m]=g}),h||a.push(p),u=p,l=d}),i.length)throw function RUe(n){return new Oe(3502,Rt)}();return a}function eA(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&tA(e,"start",n)));break;case"done":n.onDone(()=>r(e&&tA(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&tA(e,"destroy",n)))}}function tA(n,t,e){const r=e.totalTime,o=nA(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,null==r?n.totalTime:r,!!e.disabled),i=n._data;return null!=i&&(o._data=i),o}function nA(n,t,e,r,s="",o=0,i){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:o,disabled:!!i}}function ho(n,t,e){let r;return n instanceof Map?(r=n.get(t),r||n.set(t,r=e)):(r=n[t],r||(r=n[t]=e)),r}function sK(n){const t=n.indexOf(":");return[n.substring(1,t),n.substr(t+1)]}let rA=(n,t)=>!1,oK=(n,t,e)=>[],iK=null;function sA(n){const t=n.parentNode||n.host;return t===iK?null:t}(JD()||"undefined"!=typeof Element)&&(WUe()?(iK=(()=>document.documentElement)(),rA=(n,t)=>{for(;t;){if(t===n)return!0;t=sA(t)}return!1}):rA=(n,t)=>n.contains(t),oK=(n,t,e)=>{if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]});let xc=null,aK=!1;function lK(n){xc||(xc=function HUe(){return"undefined"!=typeof document?document.body:null}()||{},aK=!!xc.style&&"WebkitAppearance"in xc.style);let t=!0;return xc.style&&!function GUe(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in xc.style,!t&&aK&&(t="Webkit"+n.charAt(0).toUpperCase()+n.substr(1)in xc.style)),t}const uK=rA,cK=oK;let dK=(()=>{class n{validateStyleProperty(e){return lK(e)}matchesElement(e,r){return!1}containsElement(e,r){return uK(e,r)}getParentElement(e){return sA(e)}query(e,r,s){return cK(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,o,i,a=[],l){return new Tg(s,o)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})(),oA=(()=>{class n{}return n.NOOP=new dK,n})();const iA="ng-enter",s0="ng-leave",o0="ng-trigger",a0=".ng-trigger",pK="ng-animating",aA=".ng-animating";function Sc(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:lA(parseFloat(t[1]),t[2])}function lA(n,t){return"s"===t?1e3*n:n}function l0(n,t,e){return n.hasOwnProperty("duration")?n:function KUe(n,t,e){let s,o=0,i="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(nK()),{duration:0,delay:0,easing:""};s=lA(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(o=lA(parseFloat(l),a[4]));const u=a[5];u&&(i=u)}else s=n;if(!e){let a=!1,l=t.length;s<0&&(t.push(function cUe(){return new Oe(3100,Rt)}()),a=!0),o<0&&(t.push(function dUe(){return new Oe(3101,Rt)}()),a=!0),a&&t.splice(l,0,nK())}return{duration:s,delay:o,easing:i}}(n,t,e)}function Ph(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function nu(n,t,e={}){if(t)for(let r in n)e[r]=n[r];else Ph(n,e);return e}function mK(n,t,e){return e?t+":"+e+";":""}function gK(n){let t="";for(let e=0;e<n.style.length;e++){const r=n.style.item(e);t+=mK(0,r,n.style.getPropertyValue(r))}for(const e in n.style)n.style.hasOwnProperty(e)&&!e.startsWith("_")&&(t+=mK(0,ZUe(e),n.style[e]));n.setAttribute("style",t)}function sa(n,t,e){n.style&&(Object.keys(t).forEach(r=>{const s=cA(r);e&&!e.hasOwnProperty(r)&&(e[r]=n.style[s]),n.style[s]=t[r]}),JD()&&gK(n))}function Tc(n,t){n.style&&(Object.keys(t).forEach(e=>{const r=cA(e);n.style[r]=""}),JD()&&gK(n))}function Cg(n){return Array.isArray(n)?1==n.length?n[0]:Qq(n):n}const uA=new RegExp("{{\\s*(.+?)\\s*}}","g");function yK(n){let t=[];if("string"==typeof n){let e;for(;e=uA.exec(n);)t.push(e[1]);uA.lastIndex=0}return t}function u0(n,t,e){const r=n.toString(),s=r.replace(uA,(o,i)=>{let a=t[i];return t.hasOwnProperty(i)||(e.push(function pUe(n){return new Oe(3003,Rt)}()),a=""),a.toString()});return s==r?n:s}function c0(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const YUe=/-+([a-z0-9])/g;function cA(n){return n.replace(YUe,(...t)=>t[1].toUpperCase())}function ZUe(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function po(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function fUe(n){return new Oe(3004,Rt)}()}}function bK(n,t){return window.getComputedStyle(n)[t]}function rWe(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function sWe(n,t,e){if(":"==n[0]){const l=function oWe(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function kUe(n){return new Oe(3016,Rt)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function IUe(n){return new Oe(3015,Rt)}()),t;const s=r[1],o=r[2],i=r[3];t.push(_K(s,i));"<"==o[0]&&!("*"==s&&"*"==i)&&t.push(_K(i,s))}(r,e,t)):e.push(n),e}const f0=new Set(["true","1"]),m0=new Set(["false","0"]);function _K(n,t){const e=f0.has(n)||m0.has(n),r=f0.has(t)||m0.has(t);return(s,o)=>{let i="*"==n||n==s,a="*"==t||t==o;return!i&&e&&"boolean"==typeof s&&(i=s?f0.has(n):m0.has(n)),!a&&r&&"boolean"==typeof o&&(a=o?f0.has(t):m0.has(t)),i&&a}}const iWe=new RegExp("s*:selfs*,?","g");function dA(n,t,e,r){return new aWe(n).build(t,e,r)}class aWe{constructor(t){this._driver=t}build(t,e,r){const s=new cWe(e);this._resetContextStyleTimingState(s);const o=po(this,Cg(t),s);return s.unsupportedCSSPropertiesFound.size&&s.unsupportedCSSPropertiesFound.keys(),o}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const o=[],i=[];return"@"==t.name.charAt(0)&&e.errors.push(function gUe(){return new Oe(3006,Rt)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,u=l.name;u.toString().split(/\s*,\s*/).forEach(c=>{l.name=c,o.push(this.visitState(l,e))}),l.name=u}else if(1==a.type){const l=this.visitTransition(a,e);r+=l.queryCount,s+=l.depCount,i.push(l)}else e.errors.push(function yUe(){return new Oe(3007,Rt)}())}),{type:7,name:t.name,states:o,transitions:i,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const o=new Set,i=s||{};r.styles.forEach(a=>{if(g0(a)){const l=a;Object.keys(l).forEach(u=>{yK(l[u]).forEach(c=>{i.hasOwnProperty(c)||o.add(c)})})}}),o.size&&(c0(o.values()),e.errors.push(function bUe(n,t){return new Oe(3008,Rt)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=po(this,Cg(t.animation),e);return{type:1,matchers:rWe(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:Cc(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>po(this,r,e)),options:Cc(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const o=t.steps.map(i=>{e.currentTime=r;const a=po(this,i,e);return s=Math.max(s,e.currentTime),a});return e.currentTime=s,{type:3,steps:o,options:Cc(t.options)}}visitAnimate(t,e){const r=function hWe(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return hA(l0(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(o=>"{"==o.charAt(0)&&"{"==o.charAt(1))){const o=hA(0,0,"");return o.dynamic=!0,o.strValue=e,o}const s=l0(e,t);return hA(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,o=t.styles?t.styles:Jq({});if(5==o.type)s=this.visitKeyframes(o,e);else{let i=t.styles,a=!1;if(!i){a=!0;const u={};r.easing&&(u.easing=r.easing),i=Jq(u)}e.currentTime+=r.duration+r.delay;const l=this.visitStyle(i,e);l.isEmptyStep=a,s=l}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[];Array.isArray(t.styles)?t.styles.forEach(i=>{"string"==typeof i?i==za?r.push(i):e.errors.push(function _Ue(n){return new Oe(3002,Rt)}()):r.push(i)}):r.push(t.styles);let s=!1,o=null;return r.forEach(i=>{if(g0(i)){const a=i,l=a.easing;if(l&&(o=l,delete a.easing),!s)for(let u in a)if(a[u].toString().indexOf("{{")>=0){s=!0;break}}}),{type:6,styles:r,easing:o,offset:t.offset,containsDynamicStyles:s,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,o=e.currentTime;r&&o>0&&(o-=r.duration+r.delay),t.styles.forEach(i=>{"string"!=typeof i&&Object.keys(i).forEach(a=>{if(!this._driver.validateStyleProperty(a))return delete i[a],void e.unsupportedCSSPropertiesFound.add(a);const l=e.collectedStyles[e.currentQuerySelector],u=l[a];let c=!0;u&&(o!=s&&o>=u.startTime&&s<=u.endTime&&(e.errors.push(function vUe(n,t,e,r,s){return new Oe(3010,Rt)}()),c=!1),o=u.startTime),c&&(l[a]={startTime:o,endTime:s}),e.options&&function XUe(n,t,e){const r=t.params||{},s=yK(n);s.length&&s.forEach(o=>{r.hasOwnProperty(o)||e.push(function hUe(n){return new Oe(3001,Rt)}())})}(i[a],e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function wUe(){return new Oe(3011,Rt)}()),r;let o=0;const i=[];let a=!1,l=!1,u=0;const c=t.steps.map(y=>{const b=this._makeStyleAst(y,e);let _=null!=b.offset?b.offset:function dWe(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(g0(e)&&e.hasOwnProperty("offset")){const r=e;t=parseFloat(r.offset),delete r.offset}});else if(g0(n)&&n.hasOwnProperty("offset")){const e=n;t=parseFloat(e.offset),delete e.offset}return t}(b.styles),v=0;return null!=_&&(o++,v=b.offset=_),l=l||v<0||v>1,a=a||v<u,u=v,i.push(v),b});l&&e.errors.push(function xUe(){return new Oe(3012,Rt)}()),a&&e.errors.push(function SUe(){return new Oe(3200,Rt)}());const d=t.steps.length;let h=0;o>0&&o<d?e.errors.push(function TUe(){return new Oe(3202,Rt)}()):0==o&&(h=1/(d-1));const p=d-1,f=e.currentTime,m=e.currentAnimateTimings,g=m.duration;return c.forEach((y,b)=>{const _=h>0?b==p?1:h*b:i[b],v=_*g;e.currentTime=f+m.delay+v,m.duration=v,this._validateStyleAst(y,e),y.offset=_,r.styles.push(y)}),r}visitReference(t,e){return{type:8,animation:po(this,Cg(t.animation),e),options:Cc(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Cc(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Cc(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[o,i]=function lWe(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(iWe,"")),n=n.replace(/@\*/g,a0).replace(/@\w+/g,e=>a0+"-"+e.substr(1)).replace(/:animating/g,aA),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+o:o,ho(e.collectedStyles,e.currentQuerySelector,{});const a=po(this,Cg(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:o,limit:s.limit||0,optional:!!s.optional,includeSelf:i,animation:a,originalSelector:t.selector,options:Cc(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function CUe(){return new Oe(3013,Rt)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:l0(t.timings,e.errors,!0);return{type:12,animation:po(this,Cg(t.animation),e),timings:r,options:null}}}class cWe{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function g0(n){return!Array.isArray(n)&&"object"==typeof n}function Cc(n){return n?(n=Ph(n)).params&&(n.params=function uWe(n){return n?Ph(n):null}(n.params)):n={},n}function hA(n,t,e){return{duration:n,delay:t,easing:e}}function pA(n,t,e,r,s,o,i=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:o,totalTime:s+o,easing:i,subTimeline:a}}class y0{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const mWe=new RegExp(":enter","g"),yWe=new RegExp(":leave","g");function fA(n,t,e,r,s,o={},i={},a,l,u=[]){return(new bWe).buildKeyframes(n,t,e,r,s,o,i,a,l,u)}class bWe{buildKeyframes(t,e,r,s,o,i,a,l,u,c=[]){u=u||new y0;const d=new mA(t,e,u,s,o,c,[]);d.options=l,d.currentTimeline.setStyles([i],null,d.errors,l),po(this,r,d);const h=d.timelines.filter(p=>p.containsAnimation());if(Object.keys(a).length){let p;for(let f=h.length-1;f>=0;f--){const m=h[f];if(m.element===e){p=m;break}}p&&!p.allowOnlyTimelineStyles()&&p.setStyles([a],null,d.errors,l)}return h.length?h.map(p=>p.buildKeyframes()):[pA(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),o=e.currentTimeline.currentTime,i=this._visitSubInstructions(r,s,s.options);o!=i&&e.transformIntoNewTimeline(i)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,r){let o=e.currentTimeline.currentTime;const i=null!=r.duration?Sc(r.duration):null,a=null!=r.delay?Sc(r.delay):null;return 0!==i&&t.forEach(l=>{const u=e.appendInstructionToTimeline(l,i,a);o=Math.max(o,u.duration+u.delay)}),o}visitReference(t,e){e.updateOptions(t.options,!0),po(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const o=t.options;if(o&&(o.params||o.delay)&&(s=e.createSubContext(o),s.transformIntoNewTimeline(),null!=o.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=b0);const i=Sc(o.delay);s.delayNextStep(i)}t.steps.length&&(t.steps.forEach(i=>po(this,i,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const o=t.options&&t.options.delay?Sc(t.options.delay):0;t.steps.forEach(i=>{const a=e.createSubContext(t.options);o&&a.delayNextStep(o),po(this,i,a),s=Math.max(s,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(i=>e.currentTimeline.mergeTimelineCollectedStyles(i)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return l0(e.params?u0(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const o=t.style;5==o.type?this.visitKeyframes(o,e):(e.incrementTime(r.duration),this.visitStyle(o,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.getCurrentStyleProperties().length&&r.forwardFrame();const o=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(o):r.setStyles(t.styles,o,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,o=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*o),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(s+o),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},o=s.delay?Sc(s.delay):0;o&&(6===e.previousNode.type||0==r&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=b0);let i=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((u,c)=>{e.currentQueryIndex=c;const d=e.createSubContext(t.options,u);o&&d.delayNextStep(o),u===e.element&&(l=d.currentTimeline),po(this,t.animation,d),d.currentTimeline.applyStylesToKeyframe(),i=Math.max(i,d.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(i),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,o=t.timings,i=Math.abs(o.duration),a=i*(e.currentQueryTotal-1);let l=i*e.currentQueryIndex;switch(o.duration<0?"reverse":o.easing){case"reverse":l=a-l;break;case"full":l=r.currentStaggerTime}const c=e.currentTimeline;l&&c.delayNextStep(l);const d=c.currentTime;po(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-d+(s.startTime-r.currentTimeline.startTime)}}const b0={};class mA{constructor(t,e,r,s,o,i,a,l){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=o,this.errors=i,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=b0,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new _0(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=Sc(r.duration)),null!=r.delay&&(s.delay=Sc(r.delay));const o=r.params;if(o){let i=s.params;i||(i=this.options.params={}),Object.keys(o).forEach(a=>{(!e||!i.hasOwnProperty(a))&&(i[a]=u0(o[a],i,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,o=new mA(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return o.previousNode=this.previousNode,o.currentAnimateTimings=this.currentAnimateTimings,o.options=this._copyOptions(),o.updateOptions(t),o.currentQueryIndex=this.currentQueryIndex,o.currentQueryTotal=this.currentQueryTotal,o.parentContext=this,this.subContextCount++,o}transformIntoNewTimeline(t){return this.previousNode=b0,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=r?r:0)+t.delay,easing:""},o=new _We(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(o),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,o,i){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(mWe,"."+this._enterClassName)).replace(yWe,"."+this._leaveClassName);let u=this._driver.query(this.element,t,1!=r);0!==r&&(u=r<0?u.slice(u.length+r,u.length):u.slice(0,r)),a.push(...u)}return!o&&0==a.length&&i.push(function EUe(n){return new Oe(3014,Rt)}()),a}}class _0{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new _0(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(e=>{this._backFill[e]=this._globalTimelineStyles[e]||za,this._currentKeyframe[e]=za}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){e&&(this._previousKeyframe.easing=e);const o=s&&s.params||{},i=function vWe(n,t){const e={};let r;return n.forEach(s=>{"*"===s?(r=r||Object.keys(t),r.forEach(o=>{e[o]=za})):nu(s,!1,e)}),e}(t,this._globalTimelineStyles);Object.keys(i).forEach(a=>{const l=u0(i[a],o,r);this._pendingStyles[a]=l,this._localTimelineStyles.hasOwnProperty(a)||(this._backFill[a]=this._globalTimelineStyles.hasOwnProperty(a)?this._globalTimelineStyles[a]:za),this._updateStyle(a,l)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(r=>{this._currentKeyframe[r]=t[r]}),Object.keys(this._localTimelineStyles).forEach(r=>{this._currentKeyframe.hasOwnProperty(r)||(this._currentKeyframe[r]=this._localTimelineStyles[r])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const r=this._styleSummary[e],s=t._styleSummary[e];(!r||s.time>r.time)&&this._updateStyle(e,s.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((a,l)=>{const u=nu(a,!0);Object.keys(u).forEach(c=>{const d=u[c];"!"==d?t.add(c):d==za&&e.add(c)}),r||(u.offset=l/this.duration),s.push(u)});const o=t.size?c0(t.values()):[],i=e.size?c0(e.values()):[];if(r){const a=s[0],l=Ph(a);a.offset=0,l.offset=1,s=[a,l]}return pA(this.element,s,o,i,this.duration,this.startTime,this.easing,!1)}}class _We extends _0{constructor(t,e,r,s,o,i,a=!1){super(t,e,i.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=o,this._stretchStartingKeyframe=a,this.timings={duration:i.duration,delay:i.delay,easing:i.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const o=[],i=r+e,a=e/i,l=nu(t[0],!1);l.offset=0,o.push(l);const u=nu(t[0],!1);u.offset=xK(a),o.push(u);const c=t.length-1;for(let d=1;d<=c;d++){let h=nu(t[d],!1);h.offset=xK((e+h.offset*r)/i),o.push(h)}r=i,e=0,s="",t=o}return pA(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function xK(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class gA{}class wWe extends gA{normalizePropertyName(t,e){return cA(t)}normalizeStyleValue(t,e,r,s){let o="";const i=r.toString().trim();if(xWe[e]&&0!==r&&"0"!==r)if("number"==typeof r)o="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&s.push(function mUe(n,t){return new Oe(3005,Rt)}())}return i+o}}const xWe=(()=>function SWe(n){const t={};return n.forEach(e=>t[e]=!0),t}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function SK(n,t,e,r,s,o,i,a,l,u,c,d,h){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:o,toState:r,toStyles:i,timelines:a,queriedElements:l,preStyleProps:u,postStyleProps:c,totalTime:d,errors:h}}const yA={};class TK{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function TWe(n,t,e,r,s){return n.some(o=>o(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){const s=this._stateStyles["*"],o=this._stateStyles[t],i=s?s.buildStyles(e,r):{};return o?o.buildStyles(e,r):i}build(t,e,r,s,o,i,a,l,u,c){const d=[],h=this.ast.options&&this.ast.options.params||yA,f=this.buildStyles(r,a&&a.params||yA,d),m=l&&l.params||yA,g=this.buildStyles(s,m,d),y=new Set,b=new Map,_=new Map,v="void"===s,w={params:Object.assign(Object.assign({},h),m)},S=c?[]:fA(t,e,this.ast.animation,o,i,f,g,w,u,d);let T=0;if(S.forEach(N=>{T=Math.max(N.duration+N.delay,T)}),d.length)return SK(e,this._triggerName,r,s,v,f,g,[],[],b,_,T,d);S.forEach(N=>{const R=N.element,F=ho(b,R,{});N.preStyleProps.forEach(q=>F[q]=!0);const j=ho(_,R,{});N.postStyleProps.forEach(q=>j[q]=!0),R!==e&&y.add(R)});const I=c0(y.values());return SK(e,this._triggerName,r,s,v,f,g,S,I,b,_,T)}}class CWe{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r={},s=Ph(this.defaultParams);return Object.keys(t).forEach(o=>{const i=t[o];null!=i&&(s[o]=i)}),this.styles.styles.forEach(o=>{if("string"!=typeof o){const i=o;Object.keys(i).forEach(a=>{let l=i[a];l.length>1&&(l=u0(l,s,e));const u=this.normalizer.normalizePropertyName(a,e);l=this.normalizer.normalizeStyleValue(a,u,l,e),r[u]=l})}}),r}}class IWe{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states={},e.states.forEach(s=>{this.states[s.name]=new CWe(s.style,s.options&&s.options.params||{},r)}),CK(this.states,"true","1"),CK(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new TK(t,s,this.states))}),this.fallbackTransition=function kWe(n,t,e){return new TK(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(i,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(i=>i.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function CK(n,t,e){n.hasOwnProperty(t)?n.hasOwnProperty(e)||(n[e]=n[t]):n.hasOwnProperty(e)&&(n[t]=n[e])}const NWe=new y0;class DWe{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations={},this._playersById={},this.players=[]}register(t,e){const r=[],o=dA(this._driver,e,r,[]);if(r.length)throw function $Ue(n){return new Oe(3503,Rt)}();this._animations[t]=o}_buildPlayer(t,e,r){const s=t.element,o=rK(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(s,o,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],o=this._animations[t];let i;const a=new Map;if(o?(i=fA(this._driver,e,o,iA,s0,{},{},r,NWe,s),i.forEach(c=>{const d=ho(a,c.element,{});c.postStyleProps.forEach(h=>d[h]=null)})):(s.push(function OUe(){return new Oe(3300,Rt)}()),i=[]),s.length)throw function FUe(n){return new Oe(3504,Rt)}();a.forEach((c,d)=>{Object.keys(c).forEach(h=>{c[h]=this._driver.computeStyle(d,h,za)})});const u=tu(i.map(c=>{const d=a.get(c.element);return this._buildPlayer(c,{},d)}));return this._playersById[t]=u,u.onDestroy(()=>this.destroy(t)),this.players.push(u),u}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw function MUe(n){return new Oe(3301,Rt)}();return e}listen(t,e,r,s){const o=nA(e,"","","");return eA(this._getPlayer(t),r,o,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const o=this._getPlayer(t);switch(r){case"play":o.play();break;case"pause":o.pause();break;case"reset":o.reset();break;case"restart":o.restart();break;case"finish":o.finish();break;case"init":o.init();break;case"setPosition":o.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const EK="ng-animate-queued",bA="ng-animate-disabled",FWe=[],IK={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},MWe={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Ho="__ng_removed";class _A{constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function BWe(n){return null!=n?n:null}(r?t.value:t),r){const o=Ph(t);delete o.value,this.options=o}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const Eg="void",vA=new _A(Eg);class PWe{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,jo(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.hasOwnProperty(e))throw function PUe(n,t){return new Oe(3302,Rt)}();if(null==r||0==r.length)throw function LUe(n){return new Oe(3303,Rt)}();if(!function zWe(n){return"start"==n||"done"==n}(r))throw function VUe(n,t){return new Oe(3400,Rt)}();const o=ho(this._elementListeners,t,[]),i={name:e,phase:r,callback:s};o.push(i);const a=ho(this._engine.statesByElement,t,{});return a.hasOwnProperty(e)||(jo(t,o0),jo(t,o0+"-"+e),a[e]=vA),()=>{this._engine.afterFlush(()=>{const l=o.indexOf(i);l>=0&&o.splice(l,1),this._triggers[e]||delete a[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw function BUe(n){return new Oe(3401,Rt)}();return e}trigger(t,e,r,s=!0){const o=this._getTrigger(e),i=new wA(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(jo(t,o0),jo(t,o0+"-"+e),this._engine.statesByElement.set(t,a={}));let l=a[e];const u=new _A(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&l&&u.absorbOptions(l.options),a[e]=u,l||(l=vA),u.value!==Eg&&l.value===u.value){if(!function GWe(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const o=e[s];if(!t.hasOwnProperty(o)||n[o]!==t[o])return!1}return!0}(l.params,u.params)){const m=[],g=o.matchStyles(l.value,l.params,m),y=o.matchStyles(u.value,u.params,m);m.length?this._engine.reportError(m):this._engine.afterFlush(()=>{Tc(t,g),sa(t,y)})}return}const h=ho(this._engine.playersByElement,t,[]);h.forEach(m=>{m.namespaceId==this.id&&m.triggerName==e&&m.queued&&m.destroy()});let p=o.matchTransition(l.value,u.value,t,u.params),f=!1;if(!p){if(!s)return;p=o.fallbackTransition,f=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:p,fromState:l,toState:u,player:i,isFallbackTransition:f}),f||(jo(t,EK),i.onStart(()=>{Lh(t,EK)})),i.onDone(()=>{let m=this.players.indexOf(i);m>=0&&this.players.splice(m,1);const g=this._engine.playersByElement.get(t);if(g){let y=g.indexOf(i);y>=0&&g.splice(y,1)}}),this.players.push(i),h.push(i),i}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,r)=>{delete e[t]}),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,a0,!0);r.forEach(s=>{if(s[Ho])return;const o=this._engine.fetchNamespacesByElement(s);o.size?o.forEach(i=>i.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const o=this._engine.statesByElement.get(t),i=new Map;if(o){const a=[];if(Object.keys(o).forEach(l=>{if(i.set(l,o[l].value),this._triggers[l]){const u=this.trigger(t,l,Eg,s);u&&a.push(u)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,i),r&&tu(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(o=>{const i=o.name;if(s.has(i))return;s.add(i);const l=this._triggers[i].fallbackTransition,u=r[i]||vA,c=new _A(Eg),d=new wA(this.id,i,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:i,transition:l,fromState:u,toState:c,player:d,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const o=r.players.length?r.playersByQueriedElement.get(t):[];if(o&&o.length)s=!0;else{let i=t;for(;i=i.parentNode;)if(r.statesByElement.get(i)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const o=t[Ho];(!o||o===IK)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){jo(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const o=r.element,i=this._elementListeners.get(o);i&&i.forEach(a=>{if(a.name==r.triggerName){const l=nA(o,r.triggerName,r.fromState.value,r.toState.value);l._data=t,eA(r.player,a.phase,l,a.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const o=r.transition.ast.depCount,i=s.transition.ast.depCount;return 0==o||0==i?o-i:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class LWe{constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,o)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new PWe(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement,o=r.length-1;if(o>=0){let i=!1;if(void 0!==this.driver.getParentElement){let a=this.driver.getParentElement(e);for(;a;){const l=s.get(a);if(l){const u=r.indexOf(l);r.splice(u+1,0,t),i=!0;break}a=this.driver.getParentElement(a)}}else for(let a=o;a>=0;a--)if(this.driver.containsElement(r[a].hostElement,e)){r.splice(a+1,0,t),i=!0;break}i||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r){const s=Object.keys(r);for(let o=0;o<s.length;o++){const i=r[s[o]].namespaceId;if(i){const a=this._fetchNamespace(i);a&&e.add(a)}}}return e}trigger(t,e,r,s){if(v0(e)){const o=this._fetchNamespace(t);if(o)return o.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!v0(e))return;const o=e[Ho];if(o&&o.setForRemoval){o.setForRemoval=!1,o.setForMove=!0;const i=this.collectedLeaveElements.indexOf(e);i>=0&&this.collectedLeaveElements.splice(i,1)}if(t){const i=this._fetchNamespace(t);i&&i.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),jo(t,bA)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Lh(t,bA))}removeNode(t,e,r,s){if(v0(e)){const o=t?this._fetchNamespace(t):null;if(o?o.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const i=this.namespacesByHostElement.get(e);i&&i.id!==t&&i.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,o){this.collectedLeaveElements.push(e),e[Ho]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:o}}listen(t,e,r,s,o){return v0(e)?this._fetchNamespace(t).listen(e,r,s,o):()=>{}}_buildInstruction(t,e,r,s,o){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,o)}destroyInnerAnimations(t){let e=this.driver.query(t,a0,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,aA,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return tu(this.players).onDone(()=>t());t()})}processLeaveNode(t){var e;const r=t[Ho];if(r&&r.setForRemoval){if(t[Ho]=IK,r.namespaceId){this.destroyInnerAnimations(t);const s=this._fetchNamespace(r.namespaceId);s&&s.clearElementCache(t)}this._onRemovalComplete(t,r.setForRemoval)}(null===(e=t.classList)||void 0===e?void 0:e.contains(bA))&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(s=>{this.markElementAsDisabled(s,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)jo(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?tu(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function zUe(n){return new Oe(3402,Rt)}()}_flushAnimations(t,e){const r=new y0,s=[],o=new Map,i=[],a=new Map,l=new Map,u=new Map,c=new Set;this.disabledNodes.forEach(V=>{c.add(V);const G=this.driver.query(V,".ng-animate-queued",!0);for(let W=0;W<G.length;W++)c.add(G[W])});const d=this.bodyNode,h=Array.from(this.statesByElement.keys()),p=DK(h,this.collectedEnterElements),f=new Map;let m=0;p.forEach((V,G)=>{const W=iA+m++;f.set(G,W),V.forEach(Y=>jo(Y,W))});const g=[],y=new Set,b=new Set;for(let V=0;V<this.collectedLeaveElements.length;V++){const G=this.collectedLeaveElements[V],W=G[Ho];W&&W.setForRemoval&&(g.push(G),y.add(G),W.hasAnimation?this.driver.query(G,".ng-star-inserted",!0).forEach(Y=>y.add(Y)):b.add(G))}const _=new Map,v=DK(h,Array.from(y));v.forEach((V,G)=>{const W=s0+m++;_.set(G,W),V.forEach(Y=>jo(Y,W))}),t.push(()=>{p.forEach((V,G)=>{const W=f.get(G);V.forEach(Y=>Lh(Y,W))}),v.forEach((V,G)=>{const W=_.get(G);V.forEach(Y=>Lh(Y,W))}),g.forEach(V=>{this.processLeaveNode(V)})});const w=[],S=[];for(let V=this._namespaceList.length-1;V>=0;V--)this._namespaceList[V].drainQueuedTransitions(e).forEach(W=>{const Y=W.player,se=W.element;if(w.push(Y),this.collectedEnterElements.length){const Ee=se[Ho];if(Ee&&Ee.setForMove){if(Ee.previousTriggersValues&&Ee.previousTriggersValues.has(W.triggerName)){const Ue=Ee.previousTriggersValues.get(W.triggerName),Ve=this.statesByElement.get(W.element);Ve&&Ve[W.triggerName]&&(Ve[W.triggerName].value=Ue)}return void Y.destroy()}}const le=!d||!this.driver.containsElement(d,se),pe=_.get(se),he=f.get(se),me=this._buildInstruction(W,r,he,pe,le);if(me.errors&&me.errors.length)return void S.push(me);if(le)return Y.onStart(()=>Tc(se,me.fromStyles)),Y.onDestroy(()=>sa(se,me.toStyles)),void s.push(Y);if(W.isFallbackTransition)return Y.onStart(()=>Tc(se,me.fromStyles)),Y.onDestroy(()=>sa(se,me.toStyles)),void s.push(Y);const be=[];me.timelines.forEach(Ee=>{Ee.stretchStartingKeyframe=!0,this.disabledNodes.has(Ee.element)||be.push(Ee)}),me.timelines=be,r.append(se,me.timelines),i.push({instruction:me,player:Y,element:se}),me.queriedElements.forEach(Ee=>ho(a,Ee,[]).push(Y)),me.preStyleProps.forEach((Ee,Ue)=>{const Ve=Object.keys(Ee);if(Ve.length){let Ke=l.get(Ue);Ke||l.set(Ue,Ke=new Set),Ve.forEach(rt=>Ke.add(rt))}}),me.postStyleProps.forEach((Ee,Ue)=>{const Ve=Object.keys(Ee);let Ke=u.get(Ue);Ke||u.set(Ue,Ke=new Set),Ve.forEach(rt=>Ke.add(rt))})});if(S.length){const V=[];S.forEach(G=>{V.push(function UUe(n,t){return new Oe(3505,Rt)}())}),w.forEach(G=>G.destroy()),this.reportError(V)}const T=new Map,I=new Map;i.forEach(V=>{const G=V.element;r.has(G)&&(I.set(G,G),this._beforeAnimationBuild(V.player.namespaceId,V.instruction,T))}),s.forEach(V=>{const G=V.element;this._getPreviousPlayers(G,!1,V.namespaceId,V.triggerName,null).forEach(Y=>{ho(T,G,[]).push(Y),Y.destroy()})});const N=g.filter(V=>RK(V,l,u)),R=new Map;NK(R,this.driver,b,u,za).forEach(V=>{RK(V,l,u)&&N.push(V)});const j=new Map;p.forEach((V,G)=>{NK(j,this.driver,new Set(V),l,"!")}),N.forEach(V=>{const G=R.get(V),W=j.get(V);R.set(V,Object.assign(Object.assign({},G),W))});const q=[],X=[],Q={};i.forEach(V=>{const{element:G,player:W,instruction:Y}=V;if(r.has(G)){if(c.has(G))return W.onDestroy(()=>sa(G,Y.toStyles)),W.disabled=!0,W.overrideTotalTime(Y.totalTime),void s.push(W);let se=Q;if(I.size>1){let pe=G;const he=[];for(;pe=pe.parentNode;){const me=I.get(pe);if(me){se=me;break}he.push(pe)}he.forEach(me=>I.set(me,se))}const le=this._buildAnimation(W.namespaceId,Y,T,o,j,R);if(W.setRealPlayer(le),se===Q)q.push(W);else{const pe=this.playersByElement.get(se);pe&&pe.length&&(W.parentPlayer=tu(pe)),s.push(W)}}else Tc(G,Y.fromStyles),W.onDestroy(()=>sa(G,Y.toStyles)),X.push(W),c.has(G)&&s.push(W)}),X.forEach(V=>{const G=o.get(V.element);if(G&&G.length){const W=tu(G);V.setRealPlayer(W)}}),s.forEach(V=>{V.parentPlayer?V.syncPlayerEvents(V.parentPlayer):V.destroy()});for(let V=0;V<g.length;V++){const G=g[V],W=G[Ho];if(Lh(G,s0),W&&W.hasAnimation)continue;let Y=[];if(a.size){let le=a.get(G);le&&le.length&&Y.push(...le);let pe=this.driver.query(G,aA,!0);for(let he=0;he<pe.length;he++){let me=a.get(pe[he]);me&&me.length&&Y.push(...me)}}const se=Y.filter(le=>!le.destroyed);se.length?UWe(this,G,se):this.processLeaveNode(G)}return g.length=0,q.forEach(V=>{this.players.push(V),V.onDone(()=>{V.destroy();const G=this.players.indexOf(V);this.players.splice(G,1)}),V.play()}),q}elementContainsData(t,e){let r=!1;const s=e[Ho];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,o){let i=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(i=a)}else{const a=this.playersByElement.get(t);if(a){const l=!o||o==Eg;a.forEach(u=>{u.queued||!l&&u.triggerName!=s||i.push(u)})}}return(r||s)&&(i=i.filter(a=>!(r&&r!=a.namespaceId||s&&s!=a.triggerName))),i}_beforeAnimationBuild(t,e,r){const o=e.element,i=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const u=l.element,c=u!==o,d=ho(r,u,[]);this._getPreviousPlayers(u,c,i,a,e.toState).forEach(p=>{const f=p.getRealPlayer();f.beforeDestroy&&f.beforeDestroy(),p.destroy(),d.push(p)})}Tc(o,e.fromStyles)}_buildAnimation(t,e,r,s,o,i){const a=e.triggerName,l=e.element,u=[],c=new Set,d=new Set,h=e.timelines.map(f=>{const m=f.element;c.add(m);const g=m[Ho];if(g&&g.removedBeforeQueried)return new Tg(f.duration,f.delay);const y=m!==l,b=function WWe(n){const t=[];return AK(n,t),t}((r.get(m)||FWe).map(T=>T.getRealPlayer())).filter(T=>!!T.element&&T.element===m),_=o.get(m),v=i.get(m),w=rK(0,this._normalizer,0,f.keyframes,_,v),S=this._buildPlayer(f,w,b);if(f.subTimeline&&s&&d.add(m),y){const T=new wA(t,a,m);T.setRealPlayer(S),u.push(T)}return S});u.forEach(f=>{ho(this.playersByQueriedElement,f.element,[]).push(f),f.onDone(()=>function VWe(n,t,e){let r;if(n instanceof Map){if(r=n.get(t),r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}}else if(r=n[t],r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&delete n[t]}return r}(this.playersByQueriedElement,f.element,f))}),c.forEach(f=>jo(f,pK));const p=tu(h);return p.onDestroy(()=>{c.forEach(f=>Lh(f,pK)),sa(l,e.toStyles)}),d.forEach(f=>{ho(s,f,[]).push(p)}),p}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new Tg(t.duration,t.delay)}}class wA{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new Tg,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(r=>eA(t,e,void 0,r))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){ho(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function v0(n){return n&&1===n.nodeType}function kK(n,t){const e=n.style.display;return n.style.display=null!=t?t:"none",e}function NK(n,t,e,r,s){const o=[];e.forEach(l=>o.push(kK(l)));const i=[];r.forEach((l,u)=>{const c={};l.forEach(d=>{const h=c[d]=t.computeStyle(u,d,s);(!h||0==h.length)&&(u[Ho]=MWe,i.push(u))}),n.set(u,c)});let a=0;return e.forEach(l=>kK(l,o[a++])),i}function DK(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const s=new Set(t),o=new Map;function i(a){if(!a)return 1;let l=o.get(a);if(l)return l;const u=a.parentNode;return l=e.has(u)?u:s.has(u)?1:i(u),o.set(a,l),l}return t.forEach(a=>{const l=i(a);1!==l&&e.get(l).push(a)}),e}function jo(n,t){var e;null===(e=n.classList)||void 0===e||e.add(t)}function Lh(n,t){var e;null===(e=n.classList)||void 0===e||e.remove(t)}function UWe(n,t,e){tu(e).onDone(()=>n.processLeaveNode(t))}function AK(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof tK?AK(r.players,t):t.push(r)}}function RK(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(o=>s.add(o)):t.set(n,r),e.delete(n),!0}class w0{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,o)=>{},this._transitionEngine=new LWe(t,e,r),this._timelineEngine=new DWe(t,e,r),this._transitionEngine.onRemovalComplete=(s,o)=>this.onRemovalComplete(s,o)}registerTrigger(t,e,r,s,o){const i=t+"-"+s;let a=this._triggerCache[i];if(!a){const l=[],c=dA(this._driver,o,l,[]);if(l.length)throw function AUe(n,t){return new Oe(3404,Rt)}();a=function EWe(n,t,e){return new IWe(n,t,e)}(s,c,this._normalizer),this._triggerCache[i]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[o,i]=sK(r);this._timelineEngine.command(o,e,i,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,o){if("@"==r.charAt(0)){const[i,a]=sK(r);return this._timelineEngine.listen(i,e,a,o)}return this._transitionEngine.listen(t,e,r,s,o)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let jWe=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let o=n.initialStylesByElement.get(e);o||n.initialStylesByElement.set(e,o={}),this._initialStyles=o}start(){this._state<1&&(this._startStyles&&sa(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(sa(this._element,this._initialStyles),this._endStyles&&(sa(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Tc(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Tc(this._element,this._endStyles),this._endStyles=null),sa(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function xA(n){let t=null;const e=Object.keys(n);for(let r=0;r<e.length;r++){const s=e[r];qWe(s)&&(t=t||{},t[s]=n[s])}return t}function qWe(n){return"display"===n||"position"===n}class $K{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,r){return t.animate(e,r)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};if(this.hasStarted()){const e=this._finalKeyframe;Object.keys(e).forEach(r=>{"offset"!=r&&(t[r]=this._finished?e[r]:bK(this.element,r))})}this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class KWe{validateStyleProperty(t){return lK(t)}matchesElement(t,e){return!1}containsElement(t,e){return uK(t,e)}getParentElement(t){return sA(t)}query(t,e,r){return cK(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,o,i=[]){const l={duration:r,delay:s,fill:0==s?"both":"forwards"};o&&(l.easing=o);const u={},c=i.filter(h=>h instanceof $K);(function QUe(n,t){return 0===n||0===t})(r,s)&&c.forEach(h=>{let p=h.currentSnapshot;Object.keys(p).forEach(f=>u[f]=p[f])}),e=function JUe(n,t,e){const r=Object.keys(e);if(r.length&&t.length){let o=t[0],i=[];if(r.forEach(a=>{o.hasOwnProperty(a)||i.push(a),o[a]=e[a]}),i.length)for(var s=1;s<t.length;s++){let a=t[s];i.forEach(function(l){a[l]=bK(n,l)})}}return t}(t,e=e.map(h=>nu(h,!1)),u);const d=function HWe(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=xA(t[0]),t.length>1&&(r=xA(t[t.length-1]))):t&&(e=xA(t)),e||r?new jWe(n,e,r):null}(t,e);return new $K(t,e,l,d)}}let XWe=(()=>{class n extends Zq{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:Ko.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?Qq(e):e;return OK(this._renderer,null,r,"register",[s]),new YWe(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Ce(Ep),Ce(Yn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();class YWe extends class uUe{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new ZWe(this._id,t,e||{},this._renderer)}}class ZWe{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return OK(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function OK(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const FK="@.disabled";let QWe=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(o,i)=>{const a=null==i?void 0:i.parentNode(o);a&&i.removeChild(a,o)}}createRenderer(e,r){const o=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let c=this._rendererCache.get(o);return c||(c=new MK("",o,this.engine),this._rendererCache.set(o,c)),c}const i=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=c=>{Array.isArray(c)?c.forEach(l):this.engine.registerTrigger(i,a,e,c.name,c)};return r.data.animation.forEach(l),new JWe(this,a,o,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(o=>{const[i,a]=o;i(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Ce(Ep),Ce(w0),Ce(Cn))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();class MK{constructor(t,e,r){this.namespaceId=t,this.delegate=e,this.engine=r,this.destroyNode=this.delegate.destroyNode?s=>e.destroyNode(s):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==FK?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class JWe extends MK{constructor(t,e,r,s){super(e,r,s),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==FK?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.substr(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function eGe(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let o=e.substr(1),i="";return"@"!=o.charAt(0)&&([o,i]=function tGe(n){const t=n.indexOf(".");return[n.substring(0,t),n.substr(t+1)]}(o)),this.engine.listen(this.namespaceId,s,o,i,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}let nGe=(()=>{class n extends w0{constructor(e,r,s){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Ce(Yn),Ce(oA),Ce(gA))},n.\u0275prov=lt({token:n,factory:n.\u0275fac}),n})();const Ig=new Qe("AnimationModuleType"),PK=[{provide:Zq,useClass:XWe},{provide:gA,useFactory:function rGe(){return new wWe}},{provide:w0,useClass:nGe},{provide:Ep,useFactory:function sGe(n,t,e){return new QWe(n,t,e)},deps:[ib,w0,Cn]}],LK=[{provide:oA,useFactory:()=>new KWe},{provide:Ig,useValue:"BrowserAnimations"},...PK],oGe=[{provide:oA,useClass:dK},{provide:Ig,useValue:"NoopAnimations"},...PK];let iGe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?oGe:LK}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({providers:LK,imports:[gP]}),n})();const lGe=new Qe("mat-sanity-checks",{providedIn:"root",factory:function aGe(){return!0}});let Vh=(()=>{class n{constructor(e,r,s){this._sanityChecks=r,this._document=s,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!function L4e(){return"undefined"!=typeof __karma__&&!!__karma__||"undefined"!=typeof jasmine&&!!jasmine||"undefined"!=typeof jest&&!!jest||"undefined"!=typeof Mocha&&!!Mocha}()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Ce(lUe),Ce(lGe,8),Ce(Yn))},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({imports:[[Lq],Lq]}),n})();function uGe(n){return class extends n{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Uq(t)}}}function BK(n,t){return class extends n{constructor(...e){super(...e),this.defaultColor=t,this.color=t}get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}}}function cGe(n){return class extends n{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Uq(t)}}}class hGe{constructor(t,e,r){this._renderer=t,this.element=e,this.config=r,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const zK={enterDuration:225,exitDuration:150},SA=KD({passive:!0}),UK=["mousedown","touchstart"],WK=["mouseup","mouseleave","touchend","touchcancel"];class fGe{constructor(t,e,r,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=Sg(r))}fadeInRipple(t,e,r={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),o=Object.assign(Object.assign({},zK),r.animation);r.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const i=r.radius||function gGe(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),s=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+s*s)}(t,e,s),a=t-s.left,l=e-s.top,u=o.enterDuration,c=document.createElement("div");c.classList.add("mat-ripple-element"),c.style.left=a-i+"px",c.style.top=l-i+"px",c.style.height=2*i+"px",c.style.width=2*i+"px",null!=r.color&&(c.style.backgroundColor=r.color),c.style.transitionDuration=`${u}ms`,this._containerElement.appendChild(c),function mGe(n){window.getComputedStyle(n).getPropertyValue("opacity")}(c),c.style.transform="scale(1)";const d=new hGe(this,c,r);return d.state=0,this._activeRipples.add(d),r.persistent||(this._mostRecentTransientRipple=d),this._runTimeoutOutsideZone(()=>{const h=d===this._mostRecentTransientRipple;d.state=1,!r.persistent&&(!h||!this._isPointerDown)&&d.fadeOut()},u),d}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const r=t.element,s=Object.assign(Object.assign({},zK),t.config.animation);r.style.transitionDuration=`${s.exitDuration}ms`,r.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,r.remove()},s.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._activeRipples.forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=Sg(t);!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(UK))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(WK),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=jq(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!qq(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){!this._isPointerDown||(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(e=>{this._triggerElement.addEventListener(e,this,SA)})})}_removeTriggerEvents(){this._triggerElement&&(UK.forEach(t=>{this._triggerElement.removeEventListener(t,this,SA)}),this._pointerUpEventsRegistered&&WK.forEach(t=>{this._triggerElement.removeEventListener(t,this,SA)}))}}const yGe=new Qe("mat-ripple-global-options");let GK=(()=>{class n{constructor(e,r,s,o,i){this._elementRef=e,this._animationMode=i,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=o||{},this._rippleRenderer=new fGe(this,r,e,s)}get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,s){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,Object.assign(Object.assign({},this.rippleConfig),s)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),e))}}return n.\u0275fac=function(e){return new(e||n)(De(So),De(Cn),De(Oh),De(yGe,8),De(Ig,8))},n.\u0275dir=Lr({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&cd("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),bGe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({imports:[[Vh],Vh]}),n})();const _Ge=["mat-button",""],vGe=["*"],xGe=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"],SGe=BK(uGe(cGe(class{constructor(n){this._elementRef=n}})));let TGe=(()=>{class n extends SGe{constructor(e,r,s){super(e),this._focusMonitor=r,this._animationMode=s,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const o of xGe)this._hasHostAttributes(o)&&this._getHostElement().classList.add(o);e.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e,r){e?this._focusMonitor.focusVia(this._getHostElement(),e,r):this._getHostElement().focus(r)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...e){return e.some(r=>this._getHostElement().hasAttribute(r))}}return n.\u0275fac=function(e){return new(e||n)(De(So),De(aUe),De(Ig,8))},n.\u0275cmp=cu({type:n,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(e,r){if(1&e&&rT(GK,5),2&e){let s;Dp(s=Ap())&&(r.ripple=s.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(e,r){2&e&&(rl("disabled",r.disabled||null),cd("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-button-disabled",r.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[xy],attrs:_Ge,ngContentSelectors:vGe,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(e,r){1&e&&(function hO(n){const t=ue()[16][6];if(!t.projection){const r=t.projection=tp(n?n.length:1,null),s=r.slice();let o=t.child;for(;null!==o;){const i=n?bQ(o,n):0;null!==i&&(s[i]?s[i].projectionNext=o:r[i]=o,s[i]=o),o=o.next}}}(),ti(0,"span",0),function pO(n,t=0,e){const r=ue(),s=Ft(),o=Hc(s,20+n,16,null,e||null);null===o.projection&&(o.projection=t),lx(),64!=(64&o.flags)&&function OX(n,t,e){TR(t[11],0,t,e,mR(n,e,t),_R(e.parent||t[6],e,t))}(s,r,o)}(1),ni(),ma(2,"span",1)(3,"span",2)),2&e&&(da(2),cd("mat-button-ripple-round",r.isRoundButton||r.isIconButton),fa("matRippleDisabled",r._isRippleDisabled())("matRippleCentered",r.isIconButton)("matRippleTrigger",r._getHostElement()))},directives:[GK],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),n})(),CGe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({imports:[[bGe,Vh],Vh]}),n})();class EGe extends hs{constructor(t,e){super()}schedule(t,e=0){return this}}const S0={setInterval(n,t,...e){const{delegate:r}=S0;return(null==r?void 0:r.setInterval)?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=S0;return((null==t?void 0:t.clearInterval)||clearInterval)(n)},delegate:void 0};class TA extends EGe{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const s=this.id,o=this.scheduler;return null!=s&&(this.id=this.recycleAsyncId(o,s,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(o,this.id,e),this}requestAsyncId(t,e,r=0){return S0.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&S0.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(o){r=!0,s=o||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,Rg(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const Ng={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=Ng;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(o=>{e=void 0,n(o)});return new hs(()=>null==e?void 0:e(s))},requestAnimationFrame(...n){const{delegate:t}=Ng;return((null==t?void 0:t.requestAnimationFrame)||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Ng;return((null==t?void 0:t.cancelAnimationFrame)||cancelAnimationFrame)(...n)},delegate:void 0},HK={now:()=>(HK.delegate||Date).now(),delegate:void 0};class Dg{constructor(t,e=Dg.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}Dg.now=HK.now;class CA extends Dg{constructor(t,e=Dg.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}new class kGe extends CA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class IGe extends TA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Ng.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(s=o[o.length-1])||void 0===s?void 0:s.id)!==e&&(Ng.cancelAnimationFrame(e),t._scheduled=void 0)}});let EA,DGe=1;const T0={};function jK(n){return n in T0&&(delete T0[n],!0)}const AGe={setImmediate(n){const t=DGe++;return T0[t]=!0,EA||(EA=Promise.resolve()),EA.then(()=>jK(t)&&n()),t},clearImmediate(n){jK(n)}},{setImmediate:RGe,clearImmediate:$Ge}=AGe,C0={setImmediate(...n){const{delegate:t}=C0;return((null==t?void 0:t.setImmediate)||RGe)(...n)},clearImmediate(n){const{delegate:t}=C0;return((null==t?void 0:t.clearImmediate)||$Ge)(n)},delegate:void 0},qK=(new class FGe extends CA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class OGe extends TA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=C0.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(s=o[o.length-1])||void 0===s?void 0:s.id)!==e&&(C0.clearImmediate(e),t._scheduled=void 0)}}),new CA(TA)),PGe=qK;function zGe(n,t=qK){return function LGe(n){return or((t,e)=>{let r=!1,s=null,o=null,i=!1;const a=()=>{if(null==o||o.unsubscribe(),o=null,r){r=!1;const u=s;s=null,e.next(u)}i&&e.complete()},l=()=>{o=null,i&&e.complete()};t.subscribe(Xn(e,u=>{r=!0,s=u,o||yo(n(u)).subscribe(o=Xn(e,a,l))},()=>{i=!0,(!r||!o||o.closed)&&e.complete()}))})}(()=>function BGe(n=0,t,e=PGe){let r=-1;return null!=t&&(ZA(t)?e=t:r=t),new sr(s=>{let o=function VGe(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;o<0&&(o=0);let i=0;return e.schedule(function(){s.closed||(s.next(i++),0<=r?this.schedule(void 0,r):s.complete())},o)})}(n,t))}let WGe=(()=>{class n{constructor(e,r,s){this._platform=e,this._change=new go,this._changeListener=o=>{this._change.next(o)},this._document=s,r.runOutsideAngular(()=>{if(e.isBrowser){const o=this._getWindow();o.addEventListener("resize",this._changeListener),o.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:s}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+s,right:e.left+r,height:s,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),s=e.documentElement,o=s.getBoundingClientRect();return{top:-o.top||e.body.scrollTop||r.scrollY||s.scrollTop||0,left:-o.left||e.body.scrollLeft||r.scrollX||s.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(zGe(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(Ce(Oh),Ce(Cn),Ce(Yn,8))},n.\u0275prov=lt({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function GGe(n,t){if(1&n&&(Kg(),ma(0,"circle",4)),2&n){const e=ad(),r=Cy(1);ud("animation-name","mat-progress-spinner-stroke-rotate-"+e._spinnerAnimationLabel)("stroke-dashoffset",e._getStrokeDashOffset(),"px")("stroke-dasharray",e._getStrokeCircumference(),"px")("stroke-width",e._getCircleStrokeWidth(),"%")("transform-origin",e._getCircleTransformOrigin(r)),rl("r",e._getCircleRadius())}}function HGe(n,t){if(1&n&&(Kg(),ma(0,"circle",4)),2&n){const e=ad(),r=Cy(1);ud("stroke-dashoffset",e._getStrokeDashOffset(),"px")("stroke-dasharray",e._getStrokeCircumference(),"px")("stroke-width",e._getCircleStrokeWidth(),"%")("transform-origin",e._getCircleTransformOrigin(r)),rl("r",e._getCircleRadius())}}const qGe=BK(class{constructor(n){this._elementRef=n}},"primary"),KGe=new Qe("mat-progress-spinner-default-options",{providedIn:"root",factory:function XGe(){return{diameter:100}}});class Ua extends qGe{constructor(t,e,r,s,o,i,a,l){super(t),this._document=r,this._diameter=100,this._value=0,this._resizeSubscription=hs.EMPTY,this.mode="determinate";const u=Ua._diameters;this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),u.has(r.head)||u.set(r.head,new Set([100])),this._noopAnimations="NoopAnimations"===s&&!!o&&!o._forceAnimations,"mat-spinner"===t.nativeElement.nodeName.toLowerCase()&&(this.mode="indeterminate"),o&&(o.diameter&&(this.diameter=o.diameter),o.strokeWidth&&(this.strokeWidth=o.strokeWidth)),e.isBrowser&&e.SAFARI&&a&&i&&l&&(this._resizeSubscription=a.change(150).subscribe(()=>{"indeterminate"===this.mode&&l.run(()=>i.markForCheck())}))}get diameter(){return this._diameter}set diameter(t){this._diameter=YD(t),this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),this._styleRoot&&this._attachStyleNode()}get strokeWidth(){return this._strokeWidth||this.diameter/10}set strokeWidth(t){this._strokeWidth=YD(t)}get value(){return"determinate"===this.mode?this._value:0}set value(t){this._value=Math.max(0,Math.min(100,YD(t)))}ngOnInit(){const t=this._elementRef.nativeElement;this._styleRoot=zq(t)||this._document.head,this._attachStyleNode(),t.classList.add("mat-progress-spinner-indeterminate-animation")}ngOnDestroy(){this._resizeSubscription.unsubscribe()}_getCircleRadius(){return(this.diameter-10)/2}_getViewBox(){const t=2*this._getCircleRadius()+this.strokeWidth;return`0 0 ${t} ${t}`}_getStrokeCircumference(){return 2*Math.PI*this._getCircleRadius()}_getStrokeDashOffset(){return"determinate"===this.mode?this._getStrokeCircumference()*(100-this._value)/100:null}_getCircleStrokeWidth(){return this.strokeWidth/this.diameter*100}_getCircleTransformOrigin(t){var e;const r=50*(null!==(e=t.currentScale)&&void 0!==e?e:1);return`${r}% ${r}%`}_attachStyleNode(){const t=this._styleRoot,e=this._diameter,r=Ua._diameters;let s=r.get(t);if(!s||!s.has(e)){const o=this._document.createElement("style");o.setAttribute("mat-spinner-animation",this._spinnerAnimationLabel),o.textContent=this._getAnimationText(),t.appendChild(o),s||(s=new Set,r.set(t,s)),s.add(e)}}_getAnimationText(){const t=this._getStrokeCircumference();return"\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g,""+.95*t).replace(/END_VALUE/g,""+.2*t).replace(/DIAMETER/g,`${this._spinnerAnimationLabel}`)}_getSpinnerAnimationLabel(){return this.diameter.toString().replace(".","_")}}Ua._diameters=new WeakMap,Ua.\u0275fac=function(t){return new(t||Ua)(De(So),De(Oh),De(Yn,8),De(Ig,8),De(KGe),De(Op),De(WGe),De(Cn))},Ua.\u0275cmp=cu({type:Ua,selectors:[["mat-progress-spinner"],["mat-spinner"]],hostAttrs:["role","progressbar","tabindex","-1",1,"mat-progress-spinner","mat-spinner"],hostVars:10,hostBindings:function(t,e){2&t&&(rl("aria-valuemin","determinate"===e.mode?0:null)("aria-valuemax","determinate"===e.mode?100:null)("aria-valuenow","determinate"===e.mode?e.value:null)("mode",e.mode),ud("width",e.diameter,"px")("height",e.diameter,"px"),cd("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color",diameter:"diameter",strokeWidth:"strokeWidth",mode:"mode",value:"value"},exportAs:["matProgressSpinner"],features:[xy],decls:4,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false","aria-hidden","true",3,"ngSwitch"],["svg",""],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width","transform-origin",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width","transform-origin",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(Kg(),ti(0,"svg",0,1),vu(2,GGe,1,11,"circle",2),vu(3,HGe,1,9,"circle",3),ni()),2&t&&(ud("width",e.diameter,"px")("height",e.diameter,"px"),fa("ngSwitch","indeterminate"===e.mode),rl("viewBox",e._getViewBox()),da(2),fa("ngSwitchCase",!0),da(1),fa("ngSwitchCase",!1))},directives:[tb,JM],styles:[".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}\n"],encapsulation:2,changeDetection:0});let ZGe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({imports:[[Vh,zT],Vh]}),n})();const QGe=["video"];function JGe(n,t){if(1&n&&(ti(0,"div",10)(1,"span",11),Ny(2),qS(3,"titlecase"),ni(),ti(4,"span",11),Ny(5),qS(6,"number"),ni()()),2&n){const e=t.$implicit;da(2),Dy(KS(3,2,e.className)),da(3),Dy(KS(6,4,e.probability))}}function eHe(n,t){if(1&n&&(ti(0,"div",8),vu(1,JGe,7,6,"div",9),ni()),2&n){const e=ad(2);da(1),fa("ngForOf",e.predictions)}}function tHe(n,t){if(1&n){const e=function iO(){return ue()}();ti(0,"div",3),ma(1,"video",4,5),ti(3,"button",6),_p("click",function(){return function w2(n){return ot.lFrame.contextLView=n,n[8]}(e),ad().snapObject()}),Ny(4,"SNAP"),ni(),vu(5,eHe,2,1,"div",7),ni()}if(2&n){const e=ad();da(5),fa("ngIf",e.predictions.length)}}function nHe(n,t){1&n&&ma(0,"mat-spinner",12)}let rHe=(()=>{class n{constructor(e){this.cdr=e,this.predictions=[],this.loading=!0}ngOnInit(){this.initModel()}snapObject(){var e=this;return $(function*(){const r=yield e.webcam.capture();e.predictions=yield e.model.classify(r),e.cdr.detectChanges(),r.dispose()})()}initModel(){var e=this;return $(function*(){yield function Pbe(){return B.ready()}(),e.model=yield function yye(n){return void 0===n&&(n={version:1,alpha:1}),m_(this,void 0,void 0,function(){var t,e,r,s,o,i,a;return g_(this,function(l){switch(l.label){case 0:if(null==nr)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(r=n.version.toFixed(2),s=n.alpha?n.alpha.toFixed(2):"",o=-1,i=1,null==n.modelUrl){if(!(r in Ud))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(Ud));if(!(s in Ud[r]))throw new Error("MobileNet constructed with invalid alpha "+n.alpha+". Valid multipliers for this version are: "+Object.keys(Ud[r])+".");o=(t=Ud[r][s].inputRange)[0],i=t[1]}return null!=n.inputRange&&(o=(e=n.inputRange)[0],i=e[1]),[4,(a=new bye(r,s,n.modelUrl,o,i)).load()];case 1:return l.sent(),[2,a]}})})}(),e.loading=!1,e.cdr.detectChanges(),e.webcam=yield function NIe(n,t){return bD.apply(this,arguments)}(e.video.nativeElement)})()}}return n.\u0275fac=function(e){return new(e||n)(De(Op))},n.\u0275cmp=cu({type:n,selectors:[["app-image-classifier"]],viewQuery:function(e,r){if(1&e&&rT(QGe,5),2&e){let s;Dp(s=Ap())&&(r.video=s.first)}},decls:4,vars:2,consts:[[1,"w-full","h-full","bg-base"],["class","w-full h-full flex items-center justify-start pt-[8rem] flex-col gap-4",4,"ngIf","ngIfElse"],["spinner",""],[1,"w-full","h-full","flex","items-center","justify-start","pt-[8rem]","flex-col","gap-4"],[1,"h-[30rem]","rounded"],["video",""],["mat-flat-button","",1,"text-2xl","h-[3rem]","w-[6rem]",3,"click"],["class","flex flex-col items-start p-4 rounded image-classifier__predictions-container",4,"ngIf"],[1,"flex","flex-col","items-start","p-4","rounded","image-classifier__predictions-container"],["class","flex gap-8 justify-center",4,"ngFor","ngForOf"],[1,"flex","gap-8","justify-center"],[1,"image-classifier__predictions-item","text-xl"],["diameter","80",1,"mat-spinner"]],template:function(e,r){if(1&e&&(ti(0,"div",0),vu(1,tHe,6,1,"div",1),vu(2,nHe,1,0,"ng-template",null,2,XF),ni()),2&e){const s=Cy(3);da(1),fa("ngIf",!r.loading)("ngIfElse",s)}},directives:[ZM,TGe,XM,Ua],pipes:[tP,rP],styles:[".image-classifier__predictions-item[_ngcontent-%COMP%]{color:var(--ic-text-light)}.image-classifier__predictions-container[_ngcontent-%COMP%]{background-color:var(--ic-surface-02)}"]}),n})(),sHe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=cu({type:n,selectors:[["app-root"]],decls:1,vars:0,template:function(e,r){1&e&&ma(0,"app-image-classifier")},directives:[rHe],styles:[""],changeDetection:0}),n})(),oHe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n}),n.\u0275inj=ps({imports:[[zT,ZGe,CGe]]}),n})(),iHe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Is({type:n,bootstrap:[sHe]}),n.\u0275inj=ps({providers:[],imports:[[gP,kie,oHe,iGe]]}),n})();(function $te(){CM=!1})(),jre().bootstrapModule(iHe).catch(n=>console.error(n))},658:It=>{It.exports=K;var Ct=null;try{Ct=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(oe){}function K(oe,O,we){this.low=0|oe,this.high=0|O,this.unsigned=!!we}function He(oe){return!0===(oe&&oe.__isLong__)}Object.defineProperty(K.prototype,"__isLong__",{value:!0}),K.isLong=He;var tr={},Xe={};function en(oe,O){var we,je,Nt;return O?(Nt=0<=(oe>>>=0)&&oe<256)&&(je=Xe[oe])?je:(we=We(oe,(0|oe)<0?-1:0,!0),Nt&&(Xe[oe]=we),we):(Nt=-128<=(oe|=0)&&oe<128)&&(je=tr[oe])?je:(we=We(oe,oe<0?-1:0,!1),Nt&&(tr[oe]=we),we)}function ht(oe,O){if(isNaN(oe))return O?nr:Gt;if(O){if(oe<0)return nr;if(oe>=ge)return Mt}else{if(oe<=-$e)return Pt;if(oe+1>=$e)return kt}return oe<0?ht(-oe,O).neg():We(oe%ae|0,oe/ae|0,O)}function We(oe,O,we){return new K(oe,O,we)}K.fromInt=en,K.fromNumber=ht,K.fromBits=We;var ut=Math.pow;function Ae(oe,O,we){if(0===oe.length)throw Error("empty string");if("NaN"===oe||"Infinity"===oe||"+Infinity"===oe||"-Infinity"===oe)return Gt;if("number"==typeof O?(we=O,O=!1):O=!!O,(we=we||10)<2||36<we)throw RangeError("radix");var je;if((je=oe.indexOf("-"))>0)throw Error("interior hyphen");if(0===je)return Ae(oe.substring(1),O,we).neg();for(var Nt=ht(ut(we,8)),gt=Gt,Bt=0;Bt<oe.length;Bt+=8){var On=Math.min(8,oe.length-Bt),Bn=parseInt(oe.substring(Bt,Bt+On),we);if(On<8){var rr=ht(ut(we,On));gt=gt.mul(rr).add(ht(Bn))}else gt=(gt=gt.mul(Nt)).add(ht(Bn))}return gt.unsigned=O,gt}function J(oe,O){return"number"==typeof oe?ht(oe,O):"string"==typeof oe?Ae(oe,O):We(oe.low,oe.high,"boolean"==typeof O?O:oe.unsigned)}K.fromString=Ae,K.fromValue=J;var ae=4294967296,ge=ae*ae,$e=ge/2,Le=en(1<<24),Gt=en(0);K.ZERO=Gt;var nr=en(0,!0);K.UZERO=nr;var Kn=en(1);K.ONE=Kn;var mo=en(1,!0);K.UONE=mo;var zs=en(-1);K.NEG_ONE=zs;var kt=We(-1,2147483647,!1);K.MAX_VALUE=kt;var Mt=We(-1,-1,!0);K.MAX_UNSIGNED_VALUE=Mt;var Pt=We(0,-2147483648,!1);K.MIN_VALUE=Pt;var ce=K.prototype;ce.toInt=function(){return this.unsigned?this.low>>>0:this.low},ce.toNumber=function(){return this.unsigned?(this.high>>>0)*ae+(this.low>>>0):this.high*ae+(this.low>>>0)},ce.toString=function(O){if((O=O||10)<2||36<O)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Pt)){var we=ht(O),je=this.div(we),Nt=je.mul(we).sub(this);return je.toString(O)+Nt.toInt().toString(O)}return"-"+this.neg().toString(O)}for(var gt=ht(ut(O,6),this.unsigned),Bt=this,On="";;){var Bn=Bt.div(gt),Sn=(Bt.sub(Bn.mul(gt)).toInt()>>>0).toString(O);if((Bt=Bn).isZero())return Sn+On;for(;Sn.length<6;)Sn="0"+Sn;On=""+Sn+On}},ce.getHighBits=function(){return this.high},ce.getHighBitsUnsigned=function(){return this.high>>>0},ce.getLowBits=function(){return this.low},ce.getLowBitsUnsigned=function(){return this.low>>>0},ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Pt)?64:this.neg().getNumBitsAbs();for(var O=0!=this.high?this.high:this.low,we=31;we>0&&0==(O&1<<we);we--);return 0!=this.high?we+33:we+1},ce.isZero=function(){return 0===this.high&&0===this.low},ce.eqz=ce.isZero,ce.isNegative=function(){return!this.unsigned&&this.high<0},ce.isPositive=function(){return this.unsigned||this.high>=0},ce.isOdd=function(){return 1==(1&this.low)},ce.isEven=function(){return 0==(1&this.low)},ce.equals=function(O){return He(O)||(O=J(O)),(this.unsigned===O.unsigned||this.high>>>31!=1||O.high>>>31!=1)&&this.high===O.high&&this.low===O.low},ce.eq=ce.equals,ce.notEquals=function(O){return!this.eq(O)},ce.neq=ce.notEquals,ce.ne=ce.notEquals,ce.lessThan=function(O){return this.comp(O)<0},ce.lt=ce.lessThan,ce.lessThanOrEqual=function(O){return this.comp(O)<=0},ce.lte=ce.lessThanOrEqual,ce.le=ce.lessThanOrEqual,ce.greaterThan=function(O){return this.comp(O)>0},ce.gt=ce.greaterThan,ce.greaterThanOrEqual=function(O){return this.comp(O)>=0},ce.gte=ce.greaterThanOrEqual,ce.ge=ce.greaterThanOrEqual,ce.compare=function(O){if(He(O)||(O=J(O)),this.eq(O))return 0;var we=this.isNegative(),je=O.isNegative();return we&&!je?-1:!we&&je?1:this.unsigned?O.high>>>0>this.high>>>0||O.high===this.high&&O.low>>>0>this.low>>>0?-1:1:this.sub(O).isNegative()?-1:1},ce.comp=ce.compare,ce.negate=function(){return!this.unsigned&&this.eq(Pt)?Pt:this.not().add(Kn)},ce.neg=ce.negate,ce.add=function(O){He(O)||(O=J(O));var Sn=0,Kr=0,wt=0,Mr=0;return wt+=(Mr+=(65535&this.low)+(65535&O.low))>>>16,Kr+=(wt+=(this.low>>>16)+(O.low>>>16))>>>16,Sn+=(Kr+=(65535&this.high)+(65535&O.high))>>>16,Sn+=(this.high>>>16)+(O.high>>>16),We((wt&=65535)<<16|(Mr&=65535),(Sn&=65535)<<16|(Kr&=65535),this.unsigned)},ce.subtract=function(O){return He(O)||(O=J(O)),this.add(O.neg())},ce.sub=ce.subtract,ce.multiply=function(O){if(this.isZero())return Gt;if(He(O)||(O=J(O)),Ct)return We(Ct.mul(this.low,this.high,O.low,O.high),Ct.get_high(),this.unsigned);if(O.isZero())return Gt;if(this.eq(Pt))return O.isOdd()?Pt:Gt;if(O.eq(Pt))return this.isOdd()?Pt:Gt;if(this.isNegative())return O.isNegative()?this.neg().mul(O.neg()):this.neg().mul(O).neg();if(O.isNegative())return this.mul(O.neg()).neg();if(this.lt(Le)&&O.lt(Le))return ht(this.toNumber()*O.toNumber(),this.unsigned);var Nt=65535&this.high,gt=this.low>>>16,Bt=65535&this.low,Bn=65535&O.high,rr=O.low>>>16,Sn=65535&O.low,Kr=0,wt=0,Mr=0,Ha=0;return Mr+=(Ha+=Bt*Sn)>>>16,wt+=(Mr+=gt*Sn)>>>16,Mr&=65535,wt+=(Mr+=Bt*rr)>>>16,Kr+=(wt+=Nt*Sn)>>>16,wt&=65535,Kr+=(wt+=gt*rr)>>>16,wt&=65535,Kr+=(wt+=Bt*Bn)>>>16,Kr+=(this.high>>>16)*Sn+Nt*rr+gt*Bn+Bt*(O.high>>>16),We((Mr&=65535)<<16|(Ha&=65535),(Kr&=65535)<<16|(wt&=65535),this.unsigned)},ce.mul=ce.multiply,ce.divide=function(O){if(He(O)||(O=J(O)),O.isZero())throw Error("division by zero");var je,Nt,gt;if(Ct)return this.unsigned||-2147483648!==this.high||-1!==O.low||-1!==O.high?We((this.unsigned?Ct.div_u:Ct.div_s)(this.low,this.high,O.low,O.high),Ct.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?nr:Gt;if(this.unsigned){if(O.unsigned||(O=O.toUnsigned()),O.gt(this))return nr;if(O.gt(this.shru(1)))return mo;gt=nr}else{if(this.eq(Pt))return O.eq(Kn)||O.eq(zs)?Pt:O.eq(Pt)?Kn:(je=this.shr(1).div(O).shl(1)).eq(Gt)?O.isNegative()?Kn:zs:(Nt=this.sub(O.mul(je)),gt=je.add(Nt.div(O)));if(O.eq(Pt))return this.unsigned?nr:Gt;if(this.isNegative())return O.isNegative()?this.neg().div(O.neg()):this.neg().div(O).neg();if(O.isNegative())return this.div(O.neg()).neg();gt=Gt}for(Nt=this;Nt.gte(O);){je=Math.max(1,Math.floor(Nt.toNumber()/O.toNumber()));for(var On=Math.ceil(Math.log(je)/Math.LN2),Bn=On<=48?1:ut(2,On-48),rr=ht(je),Sn=rr.mul(O);Sn.isNegative()||Sn.gt(Nt);)Sn=(rr=ht(je-=Bn,this.unsigned)).mul(O);rr.isZero()&&(rr=Kn),gt=gt.add(rr),Nt=Nt.sub(Sn)}return gt},ce.div=ce.divide,ce.modulo=function(O){return He(O)||(O=J(O)),Ct?We((this.unsigned?Ct.rem_u:Ct.rem_s)(this.low,this.high,O.low,O.high),Ct.get_high(),this.unsigned):this.sub(this.div(O).mul(O))},ce.mod=ce.modulo,ce.rem=ce.modulo,ce.not=function(){return We(~this.low,~this.high,this.unsigned)},ce.and=function(O){return He(O)||(O=J(O)),We(this.low&O.low,this.high&O.high,this.unsigned)},ce.or=function(O){return He(O)||(O=J(O)),We(this.low|O.low,this.high|O.high,this.unsigned)},ce.xor=function(O){return He(O)||(O=J(O)),We(this.low^O.low,this.high^O.high,this.unsigned)},ce.shiftLeft=function(O){return He(O)&&(O=O.toInt()),0==(O&=63)?this:O<32?We(this.low<<O,this.high<<O|this.low>>>32-O,this.unsigned):We(0,this.low<<O-32,this.unsigned)},ce.shl=ce.shiftLeft,ce.shiftRight=function(O){return He(O)&&(O=O.toInt()),0==(O&=63)?this:O<32?We(this.low>>>O|this.high<<32-O,this.high>>O,this.unsigned):We(this.high>>O-32,this.high>=0?0:-1,this.unsigned)},ce.shr=ce.shiftRight,ce.shiftRightUnsigned=function(O){if(He(O)&&(O=O.toInt()),0==(O&=63))return this;var we=this.high;return O<32?We(this.low>>>O|we<<32-O,we>>>O,this.unsigned):We(32===O?we:we>>>O-32,0,this.unsigned)},ce.shru=ce.shiftRightUnsigned,ce.shr_u=ce.shiftRightUnsigned,ce.toSigned=function(){return this.unsigned?We(this.low,this.high,!1):this},ce.toUnsigned=function(){return this.unsigned?this:We(this.low,this.high,!0)},ce.toBytes=function(O){return O?this.toBytesLE():this.toBytesBE()},ce.toBytesLE=function(){var O=this.high,we=this.low;return[255&we,we>>>8&255,we>>>16&255,we>>>24,255&O,O>>>8&255,O>>>16&255,O>>>24]},ce.toBytesBE=function(){var O=this.high,we=this.low;return[O>>>24,O>>>16&255,O>>>8&255,255&O,we>>>24,we>>>16&255,we>>>8&255,255&we]},K.fromBytes=function(O,we,je){return je?K.fromBytesLE(O,we):K.fromBytesBE(O,we)},K.fromBytesLE=function(O,we){return new K(O[0]|O[1]<<8|O[2]<<16|O[3]<<24,O[4]|O[5]<<8|O[6]<<16|O[7]<<24,we)},K.fromBytesBE=function(O,we){return new K(O[4]<<24|O[5]<<16|O[6]<<8|O[7],O[0]<<24|O[1]<<16|O[2]<<8|O[3],we)}},340:(It,Ct,K)=>{var He=K(471),tr=K(992),Xe=K(657),en=K(583),ht=K(929),We=K(83),ut=K(818);ut.alea=He,ut.xor128=tr,ut.xorwow=Xe,ut.xorshift7=en,ut.xor4096=ht,ut.tychei=We,It.exports=ut},471:function(It,Ct,K){var He;!function(tr,Xe,en){function ht(J){var ye=this,ve=function Ae(){var J=4022871197;return function(ve){ve=String(ve);for(var ae=0;ae<ve.length;ae++){var ge=.02519603282416938*(J+=ve.charCodeAt(ae));ge-=J=ge>>>0,J=(ge*=J)>>>0,J+=4294967296*(ge-=J)}return 2.3283064365386963e-10*(J>>>0)}}();ye.next=function(){var ae=2091639*ye.s0+2.3283064365386963e-10*ye.c;return ye.s0=ye.s1,ye.s1=ye.s2,ye.s2=ae-(ye.c=0|ae)},ye.c=1,ye.s0=ve(" "),ye.s1=ve(" "),ye.s2=ve(" "),ye.s0-=ve(J),ye.s0<0&&(ye.s0+=1),ye.s1-=ve(J),ye.s1<0&&(ye.s1+=1),ye.s2-=ve(J),ye.s2<0&&(ye.s2+=1),ve=null}function We(J,ye){return ye.c=J.c,ye.s0=J.s0,ye.s1=J.s1,ye.s2=J.s2,ye}function ut(J,ye){var ve=new ht(J),ae=ye&&ye.state,ge=ve.next;return ge.int32=function(){return 4294967296*ve.next()|0},ge.double=function(){return ge()+11102230246251565e-32*(2097152*ge()|0)},ge.quick=ge,ae&&("object"==typeof ae&&We(ae,ve),ge.state=function(){return We(ve,{})}),ge}Xe&&Xe.exports?Xe.exports=ut:K.amdD&&K.amdO?void 0!==(He=function(){return ut}.call(Ct,K,Ct,Xe))&&(Xe.exports=He):this.alea=ut}(0,It=K.nmd(It))},83:function(It,Ct,K){var He;!function(tr,Xe,en){function ht(Ae){var J=this,ye="";J.next=function(){var ae=J.b,ge=J.c,$e=J.d,Le=J.a;return ae=ae<<25^ae>>>7^ge,ge=ge-$e|0,$e=$e<<24^$e>>>8^Le,Le=Le-ae|0,J.b=ae=ae<<20^ae>>>12^ge,J.c=ge=ge-$e|0,J.d=$e<<16^ge>>>16^Le,J.a=Le-ae|0},J.a=0,J.b=0,J.c=-1640531527,J.d=1367130551,Ae===Math.floor(Ae)?(J.a=Ae/4294967296|0,J.b=0|Ae):ye+=Ae;for(var ve=0;ve<ye.length+20;ve++)J.b^=0|ye.charCodeAt(ve),J.next()}function We(Ae,J){return J.a=Ae.a,J.b=Ae.b,J.c=Ae.c,J.d=Ae.d,J}function ut(Ae,J){var ye=new ht(Ae),ve=J&&J.state,ae=function(){return(ye.next()>>>0)/4294967296};return ae.double=function(){do{var Le=((ye.next()>>>11)+(ye.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ae.int32=ye.next,ae.quick=ae,ve&&("object"==typeof ve&&We(ve,ye),ae.state=function(){return We(ye,{})}),ae}Xe&&Xe.exports?Xe.exports=ut:K.amdD&&K.amdO?void 0!==(He=function(){return ut}.call(Ct,K,Ct,Xe))&&(Xe.exports=He):this.tychei=ut}(0,It=K.nmd(It))},992:function(It,Ct,K){var He;!function(tr,Xe,en){function ht(Ae){var J=this,ye="";J.x=0,J.y=0,J.z=0,J.w=0,J.next=function(){var ae=J.x^J.x<<11;return J.x=J.y,J.y=J.z,J.z=J.w,J.w^=J.w>>>19^ae^ae>>>8},Ae===(0|Ae)?J.x=Ae:ye+=Ae;for(var ve=0;ve<ye.length+64;ve++)J.x^=0|ye.charCodeAt(ve),J.next()}function We(Ae,J){return J.x=Ae.x,J.y=Ae.y,J.z=Ae.z,J.w=Ae.w,J}function ut(Ae,J){var ye=new ht(Ae),ve=J&&J.state,ae=function(){return(ye.next()>>>0)/4294967296};return ae.double=function(){do{var Le=((ye.next()>>>11)+(ye.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ae.int32=ye.next,ae.quick=ae,ve&&("object"==typeof ve&&We(ve,ye),ae.state=function(){return We(ye,{})}),ae}Xe&&Xe.exports?Xe.exports=ut:K.amdD&&K.amdO?void 0!==(He=function(){return ut}.call(Ct,K,Ct,Xe))&&(Xe.exports=He):this.xor128=ut}(0,It=K.nmd(It))},929:function(It,Ct,K){var He;!function(tr,Xe,en){function ht(Ae){var J=this;J.next=function(){var $e,Le,ve=J.w,ae=J.X,ge=J.i;return J.w=ve=ve+1640531527|0,Le=ae[ge+34&127],$e=ae[ge=ge+1&127],Le^=Le<<13,$e^=$e<<17,Le=ae[ge]=(Le^=Le>>>15)^($e^=$e>>>12),J.i=ge,Le+(ve^ve>>>16)|0},function ye(ve,ae){var ge,$e,Le,Gt,nr,Kn=[],mo=128;for(ae===(0|ae)?($e=ae,ae=null):(ae+="\0",$e=0,mo=Math.max(mo,ae.length)),Le=0,Gt=-32;Gt<mo;++Gt)ae&&($e^=ae.charCodeAt((Gt+32)%ae.length)),0===Gt&&(nr=$e),$e^=$e<<10,$e^=$e>>>15,$e^=$e<<4,$e^=$e>>>13,Gt>=0&&(Le=0==(ge=Kn[127&Gt]^=$e+(nr=nr+1640531527|0))?Le+1:0);for(Le>=128&&(Kn[127&(ae&&ae.length||0)]=-1),Le=127,Gt=512;Gt>0;--Gt)$e=Kn[Le+34&127],ge=Kn[Le=Le+1&127],$e^=$e<<13,ge^=ge<<17,Kn[Le]=($e^=$e>>>15)^(ge^=ge>>>12);ve.w=nr,ve.X=Kn,ve.i=Le}(J,Ae)}function We(Ae,J){return J.i=Ae.i,J.w=Ae.w,J.X=Ae.X.slice(),J}function ut(Ae,J){null==Ae&&(Ae=+new Date);var ye=new ht(Ae),ve=J&&J.state,ae=function(){return(ye.next()>>>0)/4294967296};return ae.double=function(){do{var Le=((ye.next()>>>11)+(ye.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ae.int32=ye.next,ae.quick=ae,ve&&(ve.X&&We(ve,ye),ae.state=function(){return We(ye,{})}),ae}Xe&&Xe.exports?Xe.exports=ut:K.amdD&&K.amdO?void 0!==(He=function(){return ut}.call(Ct,K,Ct,Xe))&&(Xe.exports=He):this.xor4096=ut}(0,It=K.nmd(It))},583:function(It,Ct,K){var He;!function(tr,Xe,en){function ht(Ae){var J=this;J.next=function(){var ge,$e,ve=J.x,ae=J.i;return ge=ve[ae],$e=(ge^=ge>>>7)^ge<<24,$e^=(ge=ve[ae+1&7])^ge>>>10,$e^=(ge=ve[ae+3&7])^ge>>>3,$e^=(ge=ve[ae+4&7])^ge<<7,ge=ve[ae+7&7],ve[ae]=$e^=(ge^=ge<<13)^ge<<9,J.i=ae+1&7,$e},function ye(ve,ae){var ge,Le=[];if(ae===(0|ae))Le[0]=ae;else for(ae=""+ae,ge=0;ge<ae.length;++ge)Le[7&ge]=Le[7&ge]<<15^ae.charCodeAt(ge)+Le[ge+1&7]<<13;for(;Le.length<8;)Le.push(0);for(ge=0;ge<8&&0===Le[ge];++ge);for(8==ge&&(Le[7]=-1),ve.x=Le,ve.i=0,ge=256;ge>0;--ge)ve.next()}(J,Ae)}function We(Ae,J){return J.x=Ae.x.slice(),J.i=Ae.i,J}function ut(Ae,J){null==Ae&&(Ae=+new Date);var ye=new ht(Ae),ve=J&&J.state,ae=function(){return(ye.next()>>>0)/4294967296};return ae.double=function(){do{var Le=((ye.next()>>>11)+(ye.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ae.int32=ye.next,ae.quick=ae,ve&&(ve.x&&We(ve,ye),ae.state=function(){return We(ye,{})}),ae}Xe&&Xe.exports?Xe.exports=ut:K.amdD&&K.amdO?void 0!==(He=function(){return ut}.call(Ct,K,Ct,Xe))&&(Xe.exports=He):this.xorshift7=ut}(0,It=K.nmd(It))},657:function(It,Ct,K){var He;!function(tr,Xe,en){function ht(Ae){var J=this,ye="";J.next=function(){var ae=J.x^J.x>>>2;return J.x=J.y,J.y=J.z,J.z=J.w,J.w=J.v,(J.d=J.d+362437|0)+(J.v=J.v^J.v<<4^ae^ae<<1)|0},J.x=0,J.y=0,J.z=0,J.w=0,J.v=0,Ae===(0|Ae)?J.x=Ae:ye+=Ae;for(var ve=0;ve<ye.length+64;ve++)J.x^=0|ye.charCodeAt(ve),ve==ye.length&&(J.d=J.x<<10^J.x>>>4),J.next()}function We(Ae,J){return J.x=Ae.x,J.y=Ae.y,J.z=Ae.z,J.w=Ae.w,J.v=Ae.v,J.d=Ae.d,J}function ut(Ae,J){var ye=new ht(Ae),ve=J&&J.state,ae=function(){return(ye.next()>>>0)/4294967296};return ae.double=function(){do{var Le=((ye.next()>>>11)+(ye.next()>>>0)/4294967296)/(1<<21)}while(0===Le);return Le},ae.int32=ye.next,ae.quick=ae,ve&&("object"==typeof ve&&We(ve,ye),ae.state=function(){return We(ye,{})}),ae}Xe&&Xe.exports?Xe.exports=ut:K.amdD&&K.amdO?void 0!==(He=function(){return ut}.call(Ct,K,Ct,Xe))&&(Xe.exports=He):this.xorwow=ut}(0,It=K.nmd(It))},818:function(It,Ct,K){var He;!function(tr,Xe,en){var ge,ht=256,J=en.pow(ht,6),ye=en.pow(2,52),ve=2*ye;function $e(kt,Mt,Pt){var ce=[],oe=Kn(nr((Mt=1==Mt?{entropy:!0}:Mt||{}).entropy?[kt,zs(Xe)]:null==kt?function mo(){try{var kt;return ge&&(kt=ge.randomBytes)?kt=kt(ht):(kt=new Uint8Array(ht),(tr.crypto||tr.msCrypto).getRandomValues(kt)),zs(kt)}catch(ce){var Mt=tr.navigator,Pt=Mt&&Mt.plugins;return[+new Date,tr,Pt,tr.screen,zs(Xe)]}}():kt,3),ce),O=new Le(ce),we=function(){for(var je=O.g(6),Nt=J,gt=0;je<ye;)je=(je+gt)*ht,Nt*=ht,gt=O.g(1);for(;je>=ve;)je/=2,Nt/=2,gt>>>=1;return(je+gt)/Nt};return we.int32=function(){return 0|O.g(4)},we.quick=function(){return O.g(4)/4294967296},we.double=we,Kn(zs(O.S),Xe),(Mt.pass||Pt||function(je,Nt,gt,Bt){return Bt&&(Bt.S&&Gt(Bt,O),je.state=function(){return Gt(O,{})}),gt?(en.random=je,Nt):je})(we,oe,"global"in Mt?Mt.global:this==en,Mt.state)}function Le(kt){var Mt,Pt=kt.length,ce=this,oe=0,O=ce.i=ce.j=0,we=ce.S=[];for(Pt||(kt=[Pt++]);oe<ht;)we[oe]=oe++;for(oe=0;oe<ht;oe++)we[oe]=we[O=255&O+kt[oe%Pt]+(Mt=we[oe])],we[O]=Mt;(ce.g=function(je){for(var Nt,gt=0,Bt=ce.i,On=ce.j,Bn=ce.S;je--;)Nt=Bn[Bt=255&Bt+1],gt=gt*ht+Bn[255&(Bn[Bt]=Bn[On=255&On+Nt])+(Bn[On]=Nt)];return ce.i=Bt,ce.j=On,gt})(ht)}function Gt(kt,Mt){return Mt.i=kt.i,Mt.j=kt.j,Mt.S=kt.S.slice(),Mt}function nr(kt,Mt){var oe,Pt=[],ce=typeof kt;if(Mt&&"object"==ce)for(oe in kt)try{Pt.push(nr(kt[oe],Mt-1))}catch(O){}return Pt.length?Pt:"string"==ce?kt:kt+"\0"}function Kn(kt,Mt){for(var ce,Pt=kt+"",oe=0;oe<Pt.length;)Mt[255&oe]=255&(ce^=19*Mt[255&oe])+Pt.charCodeAt(oe++);return zs(Mt)}function zs(kt){return String.fromCharCode.apply(0,kt)}if(Kn(en.random(),Xe),It.exports){It.exports=$e;try{ge=K(42)}catch(kt){}}else void 0!==(He=function(){return $e}.call(Ct,K,Ct,It))&&(It.exports=He)}("undefined"!=typeof self?self:this,[],Math)},410:()=>{},628:()=>{},755:()=>{},4:()=>{},759:()=>{},549:()=>{},401:()=>{},42:()=>{}},It=>{It(It.s=951)}]);